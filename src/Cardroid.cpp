// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Cardroid.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include "Cardroid.h"

#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace {

namespace {

namespace {

const ::std::string __cardroid__data__zerocice__PlaceTyp__getName_name =
		"getName";

const ::std::string __cardroid__data__zerocice__PlaceTyp__setName_name =
		"setName";

const ::std::string __cardroid__data__zerocice__PlaceTyp__getCoords_name =
		"getCoords";

const ::std::string __cardroid__data__zerocice__PlaceTyp__setCoords_name =
		"setCoords";

const ::std::string __cardroid__data__zerocice__PlaceTyp__getDescription_name =
		"getDescription";

const ::std::string __cardroid__data__zerocice__PlaceTyp__setDescription_name =
		"setDescription";

const ::std::string __cardroid__data__zerocice__PlaceTyp__hasDescription_name =
		"hasDescription";

const ::std::string __cardroid__data__zerocice__PlaceTyp__getSnapshotBytes_name =
		"getSnapshotBytes";

const ::std::string __cardroid__data__zerocice__PlaceTyp__setSnapshotBytes_name =
		"setSnapshotBytes";

const ::std::string __cardroid__data__zerocice__PlaceTyp__hasSnapshot_name =
		"hasSnapshot";

const ::std::string __cardroid__data__zerocice__PlaceTyp__toString_name =
		"toString";

const ::std::string __cardroid__data__zerocice__CarTyp__getBrand_name =
		"getBrand";

const ::std::string __cardroid__data__zerocice__CarTyp__setBrand_name =
		"setBrand";

const ::std::string __cardroid__data__zerocice__CarTyp__getModel_name =
		"getModel";

const ::std::string __cardroid__data__zerocice__CarTyp__setModel_name =
		"setModel";

const ::std::string __cardroid__data__zerocice__CarTyp__getCarFuel_name =
		"getCarFuel";

const ::std::string __cardroid__data__zerocice__CarTyp__setCarFuel_name =
		"setCarFuel";

const ::std::string __cardroid__data__zerocice__CarTyp__getConsumptionPerKm_name =
		"getConsumptionPerKm";

const ::std::string __cardroid__data__zerocice__CarTyp__setConsumptionPerKm_name =
		"setConsumptionPerKm";

const ::std::string __cardroid__data__zerocice__CarTyp__getNSeats_name =
		"getNSeats";

const ::std::string __cardroid__data__zerocice__CarTyp__setNSeats_name =
		"setNSeats";

const ::std::string __cardroid__data__zerocice__CarTyp__getColor_name =
		"getColor";

const ::std::string __cardroid__data__zerocice__CarTyp__setColor_name =
		"setColor";

const ::std::string __cardroid__data__zerocice__CarTyp__getPlate_name =
		"getPlate";

const ::std::string __cardroid__data__zerocice__CarTyp__setPlate_name =
		"setPlate";

const ::std::string __cardroid__data__zerocice__CarTyp__toString_name =
		"toString";

const ::std::string __cardroid__data__zerocice__UserTyp__getName_name =
		"getName";

const ::std::string __cardroid__data__zerocice__UserTyp__setName_name =
		"setName";

const ::std::string __cardroid__data__zerocice__UserTyp__getSurname_name =
		"getSurname";

const ::std::string __cardroid__data__zerocice__UserTyp__setSurname_name =
		"setSurname";

const ::std::string __cardroid__data__zerocice__UserTyp__getAvatarBytes_name =
		"getAvatarBytes";

const ::std::string __cardroid__data__zerocice__UserTyp__setAvatarBytes_name =
		"setAvatarBytes";

const ::std::string __cardroid__data__zerocice__UserTyp__hasAvatar_name =
		"hasAvatar";

const ::std::string __cardroid__data__zerocice__UserTyp__getUserHome_name =
		"getUserHome";

const ::std::string __cardroid__data__zerocice__UserTyp__setUserHome_name =
		"setUserHome";

const ::std::string __cardroid__data__zerocice__UserTyp__getTelephone_name =
		"getTelephone";

const ::std::string __cardroid__data__zerocice__UserTyp__setTelephone_name =
		"setTelephone";

const ::std::string __cardroid__data__zerocice__UserTyp__getEmail_name =
		"getEmail";

const ::std::string __cardroid__data__zerocice__UserTyp__setEmail_name =
		"setEmail";

const ::std::string __cardroid__data__zerocice__UserTyp__getReputation_name =
		"getReputation";

const ::std::string __cardroid__data__zerocice__UserTyp__setReputation_name =
		"setReputation";

const ::std::string __cardroid__data__zerocice__UserTyp__hasReputation_name =
		"hasReputation";

const ::std::string __cardroid__data__zerocice__UserTyp__getUserCars_name =
		"getUserCars";

const ::std::string __cardroid__data__zerocice__UserTyp__setUserCars_name =
		"setUserCars";

const ::std::string __cardroid__data__zerocice__UserTyp__toString_name =
		"toString";

const ::std::string __cardroid__data__zerocice__UserTyp__increaseReputation1_name =
		"increaseReputation1";

const ::std::string __cardroid__data__zerocice__UserTyp__increaseReputation_name =
		"increaseReputation";

const ::std::string __cardroid__data__zerocice__UserTyp__decreaseReputation1_name =
		"decreaseReputation1";

const ::std::string __cardroid__data__zerocice__UserTyp__decreaseReputation_name =
		"decreaseReputation";

const ::std::string __cardroid__data__zerocice__UserTyp__addCar_name = "addCar";

const ::std::string __cardroid__data__zerocice__UserTyp__removeCar_name =
		"removeCar";

const ::std::string __cardroid__data__zerocice__UserTyp__getNCars_name =
		"getNCars";

const ::std::string __cardroid__data__zerocice__UserTyp__clearCars_name =
		"clearCars";

const ::std::string __cardroid__data__zerocice__DateTyp__getTimeInMillis_name =
		"getTimeInMillis";

const ::std::string __cardroid__data__zerocice__DateTyp__setTimeInMillis_name =
		"setTimeInMillis";

const ::std::string __cardroid__data__zerocice__DateTyp__toString_name =
		"toString";

const ::std::string __cardroid__data__zerocice__DateTimePrefsTyp__getToleranceDays_name =
		"getToleranceDays";

const ::std::string __cardroid__data__zerocice__DateTimePrefsTyp__setToleranceDays_name =
		"setToleranceDays";

const ::std::string __cardroid__data__zerocice__DateTimePrefsTyp__getTimePrefs_name =
		"getTimePrefs";

const ::std::string __cardroid__data__zerocice__DateTimePrefsTyp__setTimePrefs_name =
		"setTimePrefs";

const ::std::string __cardroid__data__zerocice__TripTyp__getTripId_name =
		"getTripId";

const ::std::string __cardroid__data__zerocice__TripTyp__setTripId_name =
		"setTripId";

const ::std::string __cardroid__data__zerocice__TripTyp__getPlace1_name =
		"getPlace1";

const ::std::string __cardroid__data__zerocice__TripTyp__setPlace1_name =
		"setPlace1";

const ::std::string __cardroid__data__zerocice__TripTyp__getPlace2_name =
		"getPlace2";

const ::std::string __cardroid__data__zerocice__TripTyp__setPlace2_name =
		"setPlace2";

const ::std::string __cardroid__data__zerocice__TripTyp__getTripDate_name =
		"getTripDate";

const ::std::string __cardroid__data__zerocice__TripTyp__setTripDate_name =
		"setTripDate";

const ::std::string __cardroid__data__zerocice__TripTyp__getNSeats_name =
		"getNSeats";

const ::std::string __cardroid__data__zerocice__TripTyp__setNSeats_name =
		"setNSeats";

const ::std::string __cardroid__data__zerocice__TripTyp__getTripReturnDate_name =
		"getTripReturnDate";

const ::std::string __cardroid__data__zerocice__TripTyp__setTripReturnDate_name =
		"setTripReturnDate";

const ::std::string __cardroid__data__zerocice__TripTyp__hasTripReturnDate_name =
		"hasTripReturnDate";

const ::std::string __cardroid__data__zerocice__TripTyp__getTripWeekDays_name =
		"getTripWeekDays";

const ::std::string __cardroid__data__zerocice__TripTyp__getTripPeriodicity_name =
		"getTripPeriodicity";

const ::std::string __cardroid__data__zerocice__TripTyp__setTripWeekDaysPeriodicity_name =
		"setTripWeekDaysPeriodicity";

const ::std::string __cardroid__data__zerocice__TripTyp__hasWeekDaysPeriodicity_name =
		"hasWeekDaysPeriodicity";

const ::std::string __cardroid__data__zerocice__TripTyp__getDistance_name =
		"getDistance";

const ::std::string __cardroid__data__zerocice__TripTyp__setDistance_name =
		"setDistance";

const ::std::string __cardroid__data__zerocice__TripTyp__hasDistance_name =
		"hasDistance";

const ::std::string __cardroid__data__zerocice__TripTyp__getCharacteristics_name =
		"getCharacteristics";

const ::std::string __cardroid__data__zerocice__TripTyp__setCharacteristics_name =
		"setCharacteristics";

const ::std::string __cardroid__data__zerocice__TripTyp__hasCharacteristics_name =
		"hasCharacteristics";

const ::std::string __cardroid__data__zerocice__TripTyp__setTripType_name =
		"setTripType";

const ::std::string __cardroid__data__zerocice__TripTyp__getTripType_name =
		"getTripType";

const ::std::string __cardroid__data__zerocice__TripTyp__toString_name =
		"toString";

const ::std::string __cardroid__data__zerocice__WaypointTyp__getNOrder_name =
		"getNOrder";

const ::std::string __cardroid__data__zerocice__WaypointTyp__setNOrder_name =
		"setNOrder";

const ::std::string __cardroid__data__zerocice__WaypointTyp__getWaypointPlace_name =
		"getWaypointPlace";

const ::std::string __cardroid__data__zerocice__WaypointTyp__setWaypointPlace_name =
		"setWaypointPlace";

const ::std::string __cardroid__data__zerocice__WaypointTyp__toString_name =
		"toString";

const ::std::string __cardroid__data__zerocice__PassengerTyp__getPassengerUser_name =
		"getPassengerUser";

const ::std::string __cardroid__data__zerocice__PassengerTyp__setPassengerUser_name =
		"setPassengerUser";

const ::std::string __cardroid__data__zerocice__PassengerTyp__getNSeats_name =
		"getNSeats";

const ::std::string __cardroid__data__zerocice__PassengerTyp__setNSeats_name =
		"setNSeats";

const ::std::string __cardroid__data__zerocice__PassengerTyp__toString_name =
		"toString";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__getTripDateTime_name =
		"getTripDateTime";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__setTripDateTime_name =
		"setTripDateTime";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__getTripReturnDateTime_name =
		"getTripReturnDateTime";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__setTripReturnDateTime_name =
		"setTripReturnDateTime";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__getTripDriver_name =
		"getTripDriver";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__setTripDriver_name =
		"setTripDriver";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__getTripWaypoints_name =
		"getTripWaypoints";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__setTripWaypoints_name =
		"setTripWaypoints";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__getTripCar_name =
		"getTripCar";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__setTripCar_name =
		"setTripCar";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__getTripPassengers_name =
		"getTripPassengers";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__setTripPassengers_name =
		"setTripPassengers";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__getPrice_name =
		"getPrice";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__setPrice_name =
		"setPrice";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__getAllowedFeatures_name =
		"getAllowedFeatures";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__setAllowedFeatures_name =
		"setAllowedFeatures";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__addTripWaypoint_name =
		"addTripWaypoint";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__removeTripWaypoint_name =
		"removeTripWaypoint";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__getNTripWaypoints_name =
		"getNTripWaypoints";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__clearTripWaypoints_name =
		"clearTripWaypoints";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__addTripPassenger_name =
		"addTripPassenger";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__removeTripPassenger_name =
		"removeTripPassenger";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__getNTripPassengers_name =
		"getNTripPassengers";

const ::std::string __cardroid__data__zerocice__TripOfferTyp__clearTripPassengers_name =
		"clearTripPassengers";

const ::std::string __cardroid__data__zerocice__TripRequestTyp__getTripDateTimePrefs_name =
		"getTripDateTimePrefs";

const ::std::string __cardroid__data__zerocice__TripRequestTyp__setTripDateTimePrefs_name =
		"setTripDateTimePrefs";

const ::std::string __cardroid__data__zerocice__TripRequestTyp__getTripReturnDateTimePrefs_name =
		"getTripReturnDateTimePrefs";

const ::std::string __cardroid__data__zerocice__TripRequestTyp__setTripReturnDateTimePrefs_name =
		"setTripReturnDateTimePrefs";

const ::std::string __cardroid__data__zerocice__TripRequestTyp__getTripRequester_name =
		"getTripRequester";

const ::std::string __cardroid__data__zerocice__TripRequestTyp__setTripRequester_name =
		"setTripRequester";

const ::std::string __cardroid__data__zerocice__UserActivityTyp__getActivityUser_name =
		"getActivityUser";

const ::std::string __cardroid__data__zerocice__UserActivityTyp__setActivityUser_name =
		"setActivityUser";

const ::std::string __cardroid__data__zerocice__UserActivityTyp__getActivityTrip_name =
		"getActivityTrip";

const ::std::string __cardroid__data__zerocice__UserActivityTyp__setActivityTrip_name =
		"setActivityTrip";

const ::std::string __cardroid__data__zerocice__UserActivityTyp__getUserActivityType_name =
		"getUserActivityType";

const ::std::string __cardroid__data__zerocice__UserActivityTyp__setUserActivityType_name =
		"setUserActivityType";

const ::std::string __cardroid__data__zerocice__UserActivityTyp__getTimeStampInMillis_name =
		"getTimeStampInMillis";

const ::std::string __cardroid__data__zerocice__UserActivityTyp__setTimeStampInMillis_name =
		"setTimeStampInMillis";

const ::std::string __cardroid__data__zerocice__UserActivityTyp__toString_name =
		"toString";

const ::std::string __cardroid__data__zerocice__MessageTyp__getUser1_name =
		"getUser1";

const ::std::string __cardroid__data__zerocice__MessageTyp__setUser1_name =
		"setUser1";

const ::std::string __cardroid__data__zerocice__MessageTyp__getUser2_name =
		"getUser2";

const ::std::string __cardroid__data__zerocice__MessageTyp__setUser2_name =
		"setUser2";

const ::std::string __cardroid__data__zerocice__MessageTyp__getMessageText_name =
		"getMessageText";

const ::std::string __cardroid__data__zerocice__MessageTyp__setMessageText_name =
		"setMessageText";

const ::std::string __cardroid__data__zerocice__MessageTyp__getTimeStampInMillis_name =
		"getTimeStampInMillis";

const ::std::string __cardroid__data__zerocice__MessageTyp__setTimeStampInMillis_name =
		"setTimeStampInMillis";

const ::std::string __cardroid__data__zerocice__MessageTyp__toString_name =
		"toString";

}

}

const ::std::string __cardroid__QueryResult__next_name = "next";

const ::std::string __cardroid__QueryResult__destroy_name = "destroy";

namespace {

const ::std::string __cardroid__zerocice__CardroidManager__getUserPlaces_name =
		"getUserPlaces";

const ::std::string __cardroid__zerocice__CardroidManager__searchTrips_name =
		"searchTrips";

const ::std::string __cardroid__zerocice__CardroidManager__getTripFromId_name =
		"getTripFromId";

const ::std::string __cardroid__zerocice__CardroidManager__getTripOfferFromId_name =
		"getTripOfferFromId";

const ::std::string __cardroid__zerocice__CardroidManager__getTripRequestFromId_name =
		"getTripRequestFromId";

const ::std::string __cardroid__zerocice__CardroidManager__joinTrip_name =
		"joinTrip";

const ::std::string __cardroid__zerocice__CardroidManager__organizeTrip_name =
		"organizeTrip";

const ::std::string __cardroid__zerocice__CardroidManager__getUserTrips_name =
		"getUserTrips";

const ::std::string __cardroid__zerocice__CardroidManager__getPassengerTrips_name =
		"getPassengerTrips";

const ::std::string __cardroid__zerocice__CardroidManager__userTripRegistered_name =
		"userTripRegistered";

const ::std::string __cardroid__zerocice__CardroidManager__calculatePriceEstimation_name =
		"calculatePriceEstimation";

const ::std::string __cardroid__zerocice__CardroidManager__newTripOffer_name =
		"newTripOffer";

const ::std::string __cardroid__zerocice__CardroidManager__newTripRequest_name =
		"newTripRequest";

const ::std::string __cardroid__zerocice__CardroidManager__getMessageTalksSpeakers_name =
		"getMessageTalksSpeakers";

const ::std::string __cardroid__zerocice__CardroidManager__getMessageTalks_name =
		"getMessageTalks";

const ::std::string __cardroid__zerocice__CardroidManager__newMessage_name =
		"newMessage";

const ::std::string __cardroid__zerocice__CardroidManager__getUserActivity_name =
		"getUserActivity";

const ::std::string __cardroid__zerocice__CardroidManager__getUserFromEmail_name =
		"getUserFromEmail";

const ::std::string __cardroid__zerocice__CardroidManager__getCarFromPlate_name =
		"getCarFromPlate";

const ::std::string __cardroid__zerocice__CardroidManager__getCarFromPlateEmail_name =
		"getCarFromPlateEmail";

const ::std::string __cardroid__zerocice__CardroidManager__updateUserData_name =
		"updateUserData";

const ::std::string __cardroid__zerocice__CardroidManager__updateCarData_name =
		"updateCarData";

const ::std::string __cardroid__zerocice__CardroidManager__updateCarDataEmail_name =
		"updateCarDataEmail";

const ::std::string __cardroid__zerocice__CardroidManager__addCar_name =
		"addCar";

const ::std::string __cardroid__zerocice__CardroidManager__addCarEmail_name =
		"addCarEmail";

const ::std::string __cardroid__zerocice__CardroidManager__removeCar_name =
		"removeCar";

const ::std::string __cardroid__zerocice__CardroidManager__removeCarPlateEmail_name =
		"removeCarPlateEmail";

}

}

namespace {

const char* __cardroid__zerocice__OCCIException_name =
		"cardroid::zerocice::OCCIException";

}

cardroid::zerocice::OCCIException::OCCIException(const char* __file, int __line) :
		::Ice::LocalException(__file, __line) {
}

cardroid::zerocice::OCCIException::~OCCIException() throw () {
}

::std::string cardroid::zerocice::OCCIException::ice_name() const {
	return __cardroid__zerocice__OCCIException_name;
}

cardroid::zerocice::OCCIException*
cardroid::zerocice::OCCIException::ice_clone() const {
	return new OCCIException(*this);
}

void cardroid::zerocice::OCCIException::ice_throw() const {
	throw *this;
}

namespace Ice {
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::PlaceTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::data::zerocice::PlaceTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::PlaceTyp;
		v->__copyFrom(proxy);
	}
}

::std::string IceProxy::cardroid::data::zerocice::PlaceTyp::getName(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PlaceTyp__getName_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__PlaceTyp__getName_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PlaceTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PlaceTyp*>(__delBase.get());
			return __del->getName(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PlaceTyp::begin_getName(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__PlaceTyp__getName_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PlaceTyp__getName_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__PlaceTyp__getName_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::PlaceTyp::end_getName(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__PlaceTyp__getName_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::PlaceTyp::setName(
		const ::std::string& name, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PlaceTyp__setName_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PlaceTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PlaceTyp*>(__delBase.get());
			__del->setName(name, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PlaceTyp::begin_setName(
		const ::std::string& name, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PlaceTyp__setName_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__PlaceTyp__setName_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(name);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::PlaceTyp::end_setName(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__PlaceTyp__setName_name);
}

::cardroid::data::zerocice::LatLngTyp IceProxy::cardroid::data::zerocice::PlaceTyp::getCoords(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PlaceTyp__getCoords_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__PlaceTyp__getCoords_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PlaceTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PlaceTyp*>(__delBase.get());
			return __del->getCoords(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PlaceTyp::begin_getCoords(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__PlaceTyp__getCoords_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PlaceTyp__getCoords_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PlaceTyp__getCoords_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::LatLngTyp IceProxy::cardroid::data::zerocice::PlaceTyp::end_getCoords(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__PlaceTyp__getCoords_name);
	::cardroid::data::zerocice::LatLngTyp __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::PlaceTyp::setCoords(
		const ::cardroid::data::zerocice::LatLngTyp& coords,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PlaceTyp__setCoords_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PlaceTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PlaceTyp*>(__delBase.get());
			__del->setCoords(coords, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PlaceTyp::begin_setCoords(
		const ::cardroid::data::zerocice::LatLngTyp& coords,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PlaceTyp__setCoords_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PlaceTyp__setCoords_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(coords);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::PlaceTyp::end_setCoords(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__PlaceTyp__setCoords_name);
}

::std::string IceProxy::cardroid::data::zerocice::PlaceTyp::getDescription(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PlaceTyp__getDescription_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__PlaceTyp__getDescription_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PlaceTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PlaceTyp*>(__delBase.get());
			return __del->getDescription(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PlaceTyp::begin_getDescription(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__PlaceTyp__getDescription_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PlaceTyp__getDescription_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PlaceTyp__getDescription_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::PlaceTyp::end_getDescription(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__PlaceTyp__getDescription_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::PlaceTyp::setDescription(
		const ::std::string& description, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PlaceTyp__setDescription_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PlaceTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PlaceTyp*>(__delBase.get());
			__del->setDescription(description, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PlaceTyp::begin_setDescription(
		const ::std::string& description, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PlaceTyp__setDescription_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PlaceTyp__setDescription_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(description);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::PlaceTyp::end_setDescription(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__PlaceTyp__setDescription_name);
}

bool IceProxy::cardroid::data::zerocice::PlaceTyp::hasDescription(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PlaceTyp__hasDescription_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__PlaceTyp__hasDescription_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PlaceTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PlaceTyp*>(__delBase.get());
			return __del->hasDescription(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PlaceTyp::begin_hasDescription(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__PlaceTyp__hasDescription_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PlaceTyp__hasDescription_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PlaceTyp__hasDescription_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::PlaceTyp::end_hasDescription(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__PlaceTyp__hasDescription_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::Blob IceProxy::cardroid::data::zerocice::PlaceTyp::getSnapshotBytes(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PlaceTyp__getSnapshotBytes_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__PlaceTyp__getSnapshotBytes_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PlaceTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PlaceTyp*>(__delBase.get());
			return __del->getSnapshotBytes(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PlaceTyp::begin_getSnapshotBytes(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__PlaceTyp__getSnapshotBytes_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PlaceTyp__getSnapshotBytes_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PlaceTyp__getSnapshotBytes_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::Blob IceProxy::cardroid::data::zerocice::PlaceTyp::end_getSnapshotBytes(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__PlaceTyp__getSnapshotBytes_name);
	::cardroid::data::zerocice::Blob __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::PlaceTyp::setSnapshotBytes(
		const ::cardroid::data::zerocice::Blob& snapshotBytes,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PlaceTyp__setSnapshotBytes_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PlaceTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PlaceTyp*>(__delBase.get());
			__del->setSnapshotBytes(snapshotBytes, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PlaceTyp::begin_setSnapshotBytes(
		const ::cardroid::data::zerocice::Blob& snapshotBytes,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PlaceTyp__setSnapshotBytes_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PlaceTyp__setSnapshotBytes_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(snapshotBytes);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::PlaceTyp::end_setSnapshotBytes(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__PlaceTyp__setSnapshotBytes_name);
}

bool IceProxy::cardroid::data::zerocice::PlaceTyp::hasSnapshot(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PlaceTyp__hasSnapshot_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__PlaceTyp__hasSnapshot_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PlaceTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PlaceTyp*>(__delBase.get());
			return __del->hasSnapshot(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PlaceTyp::begin_hasSnapshot(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__PlaceTyp__hasSnapshot_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PlaceTyp__hasSnapshot_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PlaceTyp__hasSnapshot_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::PlaceTyp::end_hasSnapshot(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__PlaceTyp__hasSnapshot_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::std::string IceProxy::cardroid::data::zerocice::PlaceTyp::toString(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PlaceTyp__toString_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__PlaceTyp__toString_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PlaceTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PlaceTyp*>(__delBase.get());
			return __del->toString(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PlaceTyp::begin_toString(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__PlaceTyp__toString_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PlaceTyp__toString_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__PlaceTyp__toString_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::PlaceTyp::end_toString(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__PlaceTyp__toString_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

const ::std::string&
IceProxy::cardroid::data::zerocice::PlaceTyp::ice_staticId() {
	return ::cardroid::data::zerocice::PlaceTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::PlaceTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::PlaceTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::PlaceTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::PlaceTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::PlaceTyp::__newInstance() const {
	return new PlaceTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::CarTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle< ::IceProxy::cardroid::data::zerocice::CarTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::CarTyp;
		v->__copyFrom(proxy);
	}
}

::std::string IceProxy::cardroid::data::zerocice::CarTyp::getBrand(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__getBrand_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__CarTyp__getBrand_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			return __del->getBrand(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_getBrand(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__CarTyp__getBrand_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__getBrand_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__getBrand_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::CarTyp::end_getBrand(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__CarTyp__getBrand_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::CarTyp::setBrand(
		const ::std::string& brand, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__setBrand_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			__del->setBrand(brand, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_setBrand(
		const ::std::string& brand, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__setBrand_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__setBrand_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(brand);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::CarTyp::end_setBrand(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__CarTyp__setBrand_name);
}

::std::string IceProxy::cardroid::data::zerocice::CarTyp::getModel(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__getModel_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__CarTyp__getModel_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			return __del->getModel(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_getModel(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__CarTyp__getModel_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__getModel_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__getModel_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::CarTyp::end_getModel(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__CarTyp__getModel_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::CarTyp::setModel(
		const ::std::string& model, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__setModel_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			__del->setModel(model, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_setModel(
		const ::std::string& model, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__setModel_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__setModel_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(model);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::CarTyp::end_setModel(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__CarTyp__setModel_name);
}

::cardroid::data::zerocice::Fuel IceProxy::cardroid::data::zerocice::CarTyp::getCarFuel(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__getCarFuel_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__CarTyp__getCarFuel_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			return __del->getCarFuel(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_getCarFuel(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__CarTyp__getCarFuel_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__getCarFuel_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__getCarFuel_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::Fuel IceProxy::cardroid::data::zerocice::CarTyp::end_getCarFuel(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__CarTyp__getCarFuel_name);
	::cardroid::data::zerocice::Fuel __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::CarTyp::setCarFuel(
		::cardroid::data::zerocice::Fuel carFuel, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__setCarFuel_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			__del->setCarFuel(carFuel, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_setCarFuel(
		::cardroid::data::zerocice::Fuel carFuel, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__setCarFuel_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__setCarFuel_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(carFuel);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::CarTyp::end_setCarFuel(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__CarTyp__setCarFuel_name);
}

::Ice::Double IceProxy::cardroid::data::zerocice::CarTyp::getConsumptionPerKm(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__getConsumptionPerKm_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__CarTyp__getConsumptionPerKm_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			return __del->getConsumptionPerKm(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_getConsumptionPerKm(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__CarTyp__getConsumptionPerKm_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__getConsumptionPerKm_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__CarTyp__getConsumptionPerKm_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Double IceProxy::cardroid::data::zerocice::CarTyp::end_getConsumptionPerKm(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__CarTyp__getConsumptionPerKm_name);
	::Ice::Double __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::CarTyp::setConsumptionPerKm(
		::Ice::Double consumptionPerKm, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__setConsumptionPerKm_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			__del->setConsumptionPerKm(consumptionPerKm, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_setConsumptionPerKm(
		::Ice::Double consumptionPerKm, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__setConsumptionPerKm_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__CarTyp__setConsumptionPerKm_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(consumptionPerKm);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::CarTyp::end_setConsumptionPerKm(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__CarTyp__setConsumptionPerKm_name);
}

::Ice::Int IceProxy::cardroid::data::zerocice::CarTyp::getNSeats(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__getNSeats_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__CarTyp__getNSeats_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			return __del->getNSeats(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_getNSeats(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__CarTyp__getNSeats_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__getNSeats_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__getNSeats_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::CarTyp::end_getNSeats(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__CarTyp__getNSeats_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::CarTyp::setNSeats(::Ice::Int nSeats,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__setNSeats_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			__del->setNSeats(nSeats, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_setNSeats(
		::Ice::Int nSeats, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__setNSeats_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__setNSeats_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(nSeats);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::CarTyp::end_setNSeats(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__CarTyp__setNSeats_name);
}

::std::string IceProxy::cardroid::data::zerocice::CarTyp::getColor(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__getColor_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__CarTyp__getColor_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			return __del->getColor(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_getColor(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__CarTyp__getColor_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__getColor_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__getColor_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::CarTyp::end_getColor(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__CarTyp__getColor_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::CarTyp::setColor(
		const ::std::string& color, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__setColor_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			__del->setColor(color, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_setColor(
		const ::std::string& color, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__setColor_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__setColor_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(color);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::CarTyp::end_setColor(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__CarTyp__setColor_name);
}

::std::string IceProxy::cardroid::data::zerocice::CarTyp::getPlate(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__getPlate_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__CarTyp__getPlate_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			return __del->getPlate(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_getPlate(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__CarTyp__getPlate_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__getPlate_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__getPlate_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::CarTyp::end_getPlate(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__CarTyp__getPlate_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::CarTyp::setPlate(
		const ::std::string& plate, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__setPlate_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			__del->setPlate(plate, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_setPlate(
		const ::std::string& plate, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__setPlate_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__setPlate_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(plate);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::CarTyp::end_setPlate(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__CarTyp__setPlate_name);
}

::std::string IceProxy::cardroid::data::zerocice::CarTyp::toString(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__CarTyp__toString_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__CarTyp__toString_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::CarTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::CarTyp*>(__delBase.get());
			return __del->toString(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::CarTyp::begin_toString(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__CarTyp__toString_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__CarTyp__toString_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__CarTyp__toString_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::CarTyp::end_toString(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__CarTyp__toString_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

const ::std::string&
IceProxy::cardroid::data::zerocice::CarTyp::ice_staticId() {
	return ::cardroid::data::zerocice::CarTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::CarTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::CarTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::CarTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::CarTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::CarTyp::__newInstance() const {
	return new CarTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::UserTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle< ::IceProxy::cardroid::data::zerocice::UserTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::UserTyp;
		v->__copyFrom(proxy);
	}
}

::std::string IceProxy::cardroid::data::zerocice::UserTyp::getName(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__getName_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__getName_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->getName(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_getName(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__UserTyp__getName_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__getName_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__UserTyp__getName_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::UserTyp::end_getName(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__getName_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserTyp::setName(
		const ::std::string& name, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__setName_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->setName(name, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_setName(
		const ::std::string& name, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__setName_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__UserTyp__setName_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(name);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_setName(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__UserTyp__setName_name);
}

::std::string IceProxy::cardroid::data::zerocice::UserTyp::getSurname(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__getSurname_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__getSurname_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->getSurname(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_getSurname(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__UserTyp__getSurname_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__getSurname_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__getSurname_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::UserTyp::end_getSurname(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__getSurname_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserTyp::setSurname(
		const ::std::string& surname, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__setSurname_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->setSurname(surname, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_setSurname(
		const ::std::string& surname, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__setSurname_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__setSurname_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(surname);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_setSurname(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__UserTyp__setSurname_name);
}

::cardroid::data::zerocice::Blob IceProxy::cardroid::data::zerocice::UserTyp::getAvatarBytes(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__getAvatarBytes_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__getAvatarBytes_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->getAvatarBytes(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_getAvatarBytes(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__UserTyp__getAvatarBytes_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__getAvatarBytes_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__getAvatarBytes_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::Blob IceProxy::cardroid::data::zerocice::UserTyp::end_getAvatarBytes(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__getAvatarBytes_name);
	::cardroid::data::zerocice::Blob __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserTyp::setAvatarBytes(
		const ::cardroid::data::zerocice::Blob& avatarBytes,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__setAvatarBytes_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->setAvatarBytes(avatarBytes, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_setAvatarBytes(
		const ::cardroid::data::zerocice::Blob& avatarBytes,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__setAvatarBytes_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__setAvatarBytes_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(avatarBytes);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_setAvatarBytes(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__UserTyp__setAvatarBytes_name);
}

bool IceProxy::cardroid::data::zerocice::UserTyp::hasAvatar(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__hasAvatar_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__hasAvatar_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->hasAvatar(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_hasAvatar(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__UserTyp__hasAvatar_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__hasAvatar_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__UserTyp__hasAvatar_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::UserTyp::end_hasAvatar(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__hasAvatar_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::PlaceTypPtr IceProxy::cardroid::data::zerocice::UserTyp::getUserHome(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__getUserHome_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__getUserHome_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->getUserHome(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_getUserHome(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__UserTyp__getUserHome_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__getUserHome_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__getUserHome_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::PlaceTypPtr IceProxy::cardroid::data::zerocice::UserTyp::end_getUserHome(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__getUserHome_name);
	::cardroid::data::zerocice::PlaceTypPtr __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserTyp::setUserHome(
		const ::cardroid::data::zerocice::PlaceTypPtr& home,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__setUserHome_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->setUserHome(home, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_setUserHome(
		const ::cardroid::data::zerocice::PlaceTypPtr& home,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__setUserHome_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__setUserHome_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(home);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_setUserHome(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__UserTyp__setUserHome_name);
}

::Ice::Int IceProxy::cardroid::data::zerocice::UserTyp::getTelephone(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__getTelephone_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__getTelephone_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->getTelephone(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_getTelephone(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__UserTyp__getTelephone_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__getTelephone_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__getTelephone_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::UserTyp::end_getTelephone(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__getTelephone_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserTyp::setTelephone(
		::Ice::Int telephone, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__setTelephone_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->setTelephone(telephone, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_setTelephone(
		::Ice::Int telephone, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__setTelephone_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__setTelephone_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(telephone);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_setTelephone(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__UserTyp__setTelephone_name);
}

::std::string IceProxy::cardroid::data::zerocice::UserTyp::getEmail(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__getEmail_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__getEmail_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->getEmail(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_getEmail(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__UserTyp__getEmail_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__getEmail_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__UserTyp__getEmail_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::UserTyp::end_getEmail(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__getEmail_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserTyp::setEmail(
		const ::std::string& email, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__setEmail_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->setEmail(email, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_setEmail(
		const ::std::string& email, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__setEmail_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__UserTyp__setEmail_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(email);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_setEmail(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__UserTyp__setEmail_name);
}

::Ice::Int IceProxy::cardroid::data::zerocice::UserTyp::getReputation(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__getReputation_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__getReputation_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->getReputation(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_getReputation(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__UserTyp__getReputation_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__getReputation_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__getReputation_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::UserTyp::end_getReputation(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__getReputation_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserTyp::setReputation(
		::Ice::Int reputation, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__setReputation_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->setReputation(reputation, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_setReputation(
		::Ice::Int reputation, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__setReputation_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__setReputation_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(reputation);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_setReputation(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__UserTyp__setReputation_name);
}

bool IceProxy::cardroid::data::zerocice::UserTyp::hasReputation(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__hasReputation_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__hasReputation_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->hasReputation(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_hasReputation(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__UserTyp__hasReputation_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__hasReputation_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__hasReputation_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::UserTyp::end_hasReputation(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__hasReputation_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::CarCollection IceProxy::cardroid::data::zerocice::UserTyp::getUserCars(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__getUserCars_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__getUserCars_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->getUserCars(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_getUserCars(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__UserTyp__getUserCars_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__getUserCars_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__getUserCars_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::CarCollection IceProxy::cardroid::data::zerocice::UserTyp::end_getUserCars(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__getUserCars_name);
	::cardroid::data::zerocice::CarCollection __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserTyp::setUserCars(
		const ::cardroid::data::zerocice::CarCollection& cars,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__setUserCars_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->setUserCars(cars, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_setUserCars(
		const ::cardroid::data::zerocice::CarCollection& cars,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__setUserCars_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__setUserCars_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(cars);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_setUserCars(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__UserTyp__setUserCars_name);
}

::std::string IceProxy::cardroid::data::zerocice::UserTyp::toString(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__toString_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__toString_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->toString(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_toString(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__UserTyp__toString_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__toString_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__UserTyp__toString_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::UserTyp::end_toString(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__toString_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserTyp::increaseReputation1(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__increaseReputation1_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->increaseReputation1(__ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_increaseReputation1(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__increaseReputation1_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__increaseReputation1_name,
				::Ice::Normal, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_increaseReputation1(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__UserTyp__increaseReputation1_name);
}

void IceProxy::cardroid::data::zerocice::UserTyp::increaseReputation(
		::Ice::Int increase, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__increaseReputation_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->increaseReputation(increase, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_increaseReputation(
		::Ice::Int increase, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__increaseReputation_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__increaseReputation_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(increase);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_increaseReputation(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__UserTyp__increaseReputation_name);
}

void IceProxy::cardroid::data::zerocice::UserTyp::decreaseReputation1(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__decreaseReputation1_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->decreaseReputation1(__ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_decreaseReputation1(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__decreaseReputation1_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__decreaseReputation1_name,
				::Ice::Normal, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_decreaseReputation1(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__UserTyp__decreaseReputation1_name);
}

void IceProxy::cardroid::data::zerocice::UserTyp::decreaseReputation(
		::Ice::Int decrease, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__decreaseReputation_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->decreaseReputation(decrease, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_decreaseReputation(
		::Ice::Int decrease, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__decreaseReputation_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserTyp__decreaseReputation_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(decrease);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_decreaseReputation(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__UserTyp__decreaseReputation_name);
}

bool IceProxy::cardroid::data::zerocice::UserTyp::addCar(
		const ::cardroid::data::zerocice::CarTypPtr& c,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__addCar_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(__cardroid__data__zerocice__UserTyp__addCar_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->addCar(c, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_addCar(
		const ::cardroid::data::zerocice::CarTypPtr& c,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__UserTyp__addCar_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__addCar_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__UserTyp__addCar_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(c);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::UserTyp::end_addCar(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__addCar_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

bool IceProxy::cardroid::data::zerocice::UserTyp::removeCar(
		const ::cardroid::data::zerocice::CarTypPtr& c,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__removeCar_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__removeCar_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->removeCar(c, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_removeCar(
		const ::cardroid::data::zerocice::CarTypPtr& c,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__UserTyp__removeCar_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__removeCar_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__UserTyp__removeCar_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(c);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::UserTyp::end_removeCar(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__removeCar_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::Ice::Int IceProxy::cardroid::data::zerocice::UserTyp::getNCars(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__getNCars_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserTyp__getNCars_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			return __del->getNCars(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_getNCars(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__UserTyp__getNCars_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__getNCars_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__UserTyp__getNCars_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::UserTyp::end_getNCars(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserTyp__getNCars_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserTyp::clearCars(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserTyp__clearCars_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserTyp*>(__delBase.get());
			__del->clearCars(__ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserTyp::begin_clearCars(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserTyp__clearCars_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__UserTyp__clearCars_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserTyp::end_clearCars(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__UserTyp__clearCars_name);
}

const ::std::string&
IceProxy::cardroid::data::zerocice::UserTyp::ice_staticId() {
	return ::cardroid::data::zerocice::UserTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::UserTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::UserTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::UserTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::UserTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::UserTyp::__newInstance() const {
	return new UserTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::DateTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle< ::IceProxy::cardroid::data::zerocice::DateTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::DateTyp;
		v->__copyFrom(proxy);
	}
}

::Ice::Long IceProxy::cardroid::data::zerocice::DateTyp::getTimeInMillis(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__DateTyp__getTimeInMillis_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__DateTyp__getTimeInMillis_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::DateTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::DateTyp*>(__delBase.get());
			return __del->getTimeInMillis(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::DateTyp::begin_getTimeInMillis(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__DateTyp__getTimeInMillis_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__DateTyp__getTimeInMillis_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__DateTyp__getTimeInMillis_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Long IceProxy::cardroid::data::zerocice::DateTyp::end_getTimeInMillis(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__DateTyp__getTimeInMillis_name);
	::Ice::Long __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::DateTyp::setTimeInMillis(
		::Ice::Long datetime, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__DateTyp__setTimeInMillis_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::DateTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::DateTyp*>(__delBase.get());
			__del->setTimeInMillis(datetime, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::DateTyp::begin_setTimeInMillis(
		::Ice::Long datetime, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__DateTyp__setTimeInMillis_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__DateTyp__setTimeInMillis_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(datetime);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::DateTyp::end_setTimeInMillis(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__DateTyp__setTimeInMillis_name);
}

::std::string IceProxy::cardroid::data::zerocice::DateTyp::toString(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__DateTyp__toString_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__DateTyp__toString_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::DateTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::DateTyp*>(__delBase.get());
			return __del->toString(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::DateTyp::begin_toString(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__DateTyp__toString_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__DateTyp__toString_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__DateTyp__toString_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::DateTyp::end_toString(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__DateTyp__toString_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

const ::std::string&
IceProxy::cardroid::data::zerocice::DateTyp::ice_staticId() {
	return ::cardroid::data::zerocice::DateTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::DateTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::DateTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::DateTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::DateTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::DateTyp::__newInstance() const {
	return new DateTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::DateTimeTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::data::zerocice::DateTimeTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::DateTimeTyp;
		v->__copyFrom(proxy);
	}
}

const ::std::string&
IceProxy::cardroid::data::zerocice::DateTimeTyp::ice_staticId() {
	return ::cardroid::data::zerocice::DateTimeTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::DateTimeTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::DateTimeTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::DateTimeTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::DateTimeTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::DateTimeTyp::__newInstance() const {
	return new DateTimeTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::DateTimePrefsTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::data::zerocice::DateTimePrefsTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::DateTimePrefsTyp;
		v->__copyFrom(proxy);
	}
}

::Ice::Int IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::getToleranceDays(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__DateTimePrefsTyp__getToleranceDays_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__DateTimePrefsTyp__getToleranceDays_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::DateTimePrefsTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::DateTimePrefsTyp*>(__delBase.get());
			return __del->getToleranceDays(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::begin_getToleranceDays(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__DateTimePrefsTyp__getToleranceDays_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__DateTimePrefsTyp__getToleranceDays_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__DateTimePrefsTyp__getToleranceDays_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::end_getToleranceDays(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__DateTimePrefsTyp__getToleranceDays_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::setToleranceDays(
		::Ice::Int toleranceDays, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__DateTimePrefsTyp__setToleranceDays_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::DateTimePrefsTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::DateTimePrefsTyp*>(__delBase.get());
			__del->setToleranceDays(toleranceDays, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::begin_setToleranceDays(
		::Ice::Int toleranceDays, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__DateTimePrefsTyp__setToleranceDays_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__DateTimePrefsTyp__setToleranceDays_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(toleranceDays);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::end_setToleranceDays(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__DateTimePrefsTyp__setToleranceDays_name);
}

::cardroid::data::zerocice::TimePreferences IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::getTimePrefs(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__DateTimePrefsTyp__getTimePrefs_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__DateTimePrefsTyp__getTimePrefs_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::DateTimePrefsTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::DateTimePrefsTyp*>(__delBase.get());
			return __del->getTimePrefs(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::begin_getTimePrefs(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__DateTimePrefsTyp__getTimePrefs_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__DateTimePrefsTyp__getTimePrefs_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__DateTimePrefsTyp__getTimePrefs_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::TimePreferences IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::end_getTimePrefs(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__DateTimePrefsTyp__getTimePrefs_name);
	::cardroid::data::zerocice::TimePreferences __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::setTimePrefs(
		::cardroid::data::zerocice::TimePreferences timePrefs,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__DateTimePrefsTyp__setTimePrefs_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::DateTimePrefsTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::DateTimePrefsTyp*>(__delBase.get());
			__del->setTimePrefs(timePrefs, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::begin_setTimePrefs(
		::cardroid::data::zerocice::TimePreferences timePrefs,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__DateTimePrefsTyp__setTimePrefs_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__DateTimePrefsTyp__setTimePrefs_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(timePrefs);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::end_setTimePrefs(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__DateTimePrefsTyp__setTimePrefs_name);
}

const ::std::string&
IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::ice_staticId() {
	return ::cardroid::data::zerocice::DateTimePrefsTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::DateTimePrefsTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::DateTimePrefsTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::DateTimePrefsTyp::__newInstance() const {
	return new DateTimePrefsTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::TripTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle< ::IceProxy::cardroid::data::zerocice::TripTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::TripTyp;
		v->__copyFrom(proxy);
	}
}

::Ice::Int IceProxy::cardroid::data::zerocice::TripTyp::getTripId(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__getTripId_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__getTripId_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->getTripId(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_getTripId(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__TripTyp__getTripId_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__getTripId_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__TripTyp__getTripId_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::TripTyp::end_getTripId(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__getTripId_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripTyp::setTripId(::Ice::Int tripId,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__setTripId_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			__del->setTripId(tripId, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_setTripId(
		::Ice::Int tripId, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__setTripId_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__TripTyp__setTripId_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripId);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripTyp::end_setTripId(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__TripTyp__setTripId_name);
}

::cardroid::data::zerocice::PlaceTypPtr IceProxy::cardroid::data::zerocice::TripTyp::getPlace1(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__getPlace1_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__getPlace1_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->getPlace1(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_getPlace1(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__TripTyp__getPlace1_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__getPlace1_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__TripTyp__getPlace1_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::PlaceTypPtr IceProxy::cardroid::data::zerocice::TripTyp::end_getPlace1(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__getPlace1_name);
	::cardroid::data::zerocice::PlaceTypPtr __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripTyp::setPlace1(
		const ::cardroid::data::zerocice::PlaceTypPtr& fromPlace,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__setPlace1_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			__del->setPlace1(fromPlace, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_setPlace1(
		const ::cardroid::data::zerocice::PlaceTypPtr& fromPlace,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__setPlace1_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__TripTyp__setPlace1_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(fromPlace);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripTyp::end_setPlace1(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__TripTyp__setPlace1_name);
}

::cardroid::data::zerocice::PlaceTypPtr IceProxy::cardroid::data::zerocice::TripTyp::getPlace2(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__getPlace2_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__getPlace2_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->getPlace2(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_getPlace2(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__TripTyp__getPlace2_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__getPlace2_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__TripTyp__getPlace2_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::PlaceTypPtr IceProxy::cardroid::data::zerocice::TripTyp::end_getPlace2(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__getPlace2_name);
	::cardroid::data::zerocice::PlaceTypPtr __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripTyp::setPlace2(
		const ::cardroid::data::zerocice::PlaceTypPtr& toPlace,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__setPlace2_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			__del->setPlace2(toPlace, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_setPlace2(
		const ::cardroid::data::zerocice::PlaceTypPtr& toPlace,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__setPlace2_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__TripTyp__setPlace2_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(toPlace);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripTyp::end_setPlace2(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__TripTyp__setPlace2_name);
}

::cardroid::data::zerocice::DateTypPtr IceProxy::cardroid::data::zerocice::TripTyp::getTripDate(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__getTripDate_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__getTripDate_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->getTripDate(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_getTripDate(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripTyp__getTripDate_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__getTripDate_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__getTripDate_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::DateTypPtr IceProxy::cardroid::data::zerocice::TripTyp::end_getTripDate(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__getTripDate_name);
	::cardroid::data::zerocice::DateTypPtr __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripTyp::setTripDate(
		const ::cardroid::data::zerocice::DateTypPtr& tripDate,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__setTripDate_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			__del->setTripDate(tripDate, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_setTripDate(
		const ::cardroid::data::zerocice::DateTypPtr& tripDate,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__setTripDate_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__setTripDate_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripDate);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripTyp::end_setTripDate(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__TripTyp__setTripDate_name);
}

::Ice::Int IceProxy::cardroid::data::zerocice::TripTyp::getNSeats(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__getNSeats_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__getNSeats_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->getNSeats(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_getNSeats(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__TripTyp__getNSeats_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__getNSeats_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__TripTyp__getNSeats_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::TripTyp::end_getNSeats(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__getNSeats_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripTyp::setNSeats(::Ice::Int nSeats,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__setNSeats_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			__del->setNSeats(nSeats, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_setNSeats(
		::Ice::Int nSeats, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__setNSeats_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__TripTyp__setNSeats_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(nSeats);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripTyp::end_setNSeats(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__TripTyp__setNSeats_name);
}

::cardroid::data::zerocice::DateTypPtr IceProxy::cardroid::data::zerocice::TripTyp::getTripReturnDate(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__getTripReturnDate_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__getTripReturnDate_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->getTripReturnDate(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_getTripReturnDate(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripTyp__getTripReturnDate_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__getTripReturnDate_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__getTripReturnDate_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::DateTypPtr IceProxy::cardroid::data::zerocice::TripTyp::end_getTripReturnDate(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__getTripReturnDate_name);
	::cardroid::data::zerocice::DateTypPtr __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripTyp::setTripReturnDate(
		const ::cardroid::data::zerocice::DateTypPtr& tripReturnDate,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__setTripReturnDate_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			__del->setTripReturnDate(tripReturnDate, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_setTripReturnDate(
		const ::cardroid::data::zerocice::DateTypPtr& tripReturnDate,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__setTripReturnDate_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__setTripReturnDate_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripReturnDate);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripTyp::end_setTripReturnDate(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripTyp__setTripReturnDate_name);
}

bool IceProxy::cardroid::data::zerocice::TripTyp::hasTripReturnDate(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__hasTripReturnDate_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__hasTripReturnDate_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->hasTripReturnDate(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_hasTripReturnDate(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripTyp__hasTripReturnDate_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__hasTripReturnDate_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__hasTripReturnDate_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::TripTyp::end_hasTripReturnDate(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__hasTripReturnDate_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::WeekdaysV IceProxy::cardroid::data::zerocice::TripTyp::getTripWeekDays(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__getTripWeekDays_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__getTripWeekDays_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->getTripWeekDays(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_getTripWeekDays(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripTyp__getTripWeekDays_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__getTripWeekDays_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__getTripWeekDays_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::WeekdaysV IceProxy::cardroid::data::zerocice::TripTyp::end_getTripWeekDays(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__getTripWeekDays_name);
	::cardroid::data::zerocice::WeekdaysV __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::Periodicity IceProxy::cardroid::data::zerocice::TripTyp::getTripPeriodicity(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__getTripPeriodicity_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__getTripPeriodicity_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->getTripPeriodicity(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_getTripPeriodicity(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripTyp__getTripPeriodicity_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__getTripPeriodicity_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__getTripPeriodicity_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::Periodicity IceProxy::cardroid::data::zerocice::TripTyp::end_getTripPeriodicity(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__getTripPeriodicity_name);
	::cardroid::data::zerocice::Periodicity __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripTyp::setTripWeekDaysPeriodicity(
		const ::cardroid::data::zerocice::WeekdaysV& tripWeekDays,
		::cardroid::data::zerocice::Periodicity tripPeriodicity,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__setTripWeekDaysPeriodicity_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			__del->setTripWeekDaysPeriodicity(tripWeekDays, tripPeriodicity,
					__ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_setTripWeekDaysPeriodicity(
		const ::cardroid::data::zerocice::WeekdaysV& tripWeekDays,
		::cardroid::data::zerocice::Periodicity tripPeriodicity,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__data__zerocice__TripTyp__setTripWeekDaysPeriodicity_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__setTripWeekDaysPeriodicity_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripWeekDays);
		__os->write(tripPeriodicity);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripTyp::end_setTripWeekDaysPeriodicity(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripTyp__setTripWeekDaysPeriodicity_name);
}

bool IceProxy::cardroid::data::zerocice::TripTyp::hasWeekDaysPeriodicity(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__hasWeekDaysPeriodicity_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__hasWeekDaysPeriodicity_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->hasWeekDaysPeriodicity(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_hasWeekDaysPeriodicity(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripTyp__hasWeekDaysPeriodicity_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripTyp__hasWeekDaysPeriodicity_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__hasWeekDaysPeriodicity_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::TripTyp::end_hasWeekDaysPeriodicity(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__hasWeekDaysPeriodicity_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::Ice::Int IceProxy::cardroid::data::zerocice::TripTyp::getDistance(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__getDistance_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__getDistance_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->getDistance(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_getDistance(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripTyp__getDistance_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__getDistance_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__getDistance_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::TripTyp::end_getDistance(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__getDistance_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripTyp::setDistance(
		::Ice::Int distance, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__setDistance_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			__del->setDistance(distance, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_setDistance(
		::Ice::Int distance, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__setDistance_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__setDistance_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(distance);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripTyp::end_setDistance(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__TripTyp__setDistance_name);
}

bool IceProxy::cardroid::data::zerocice::TripTyp::hasDistance(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__hasDistance_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__hasDistance_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->hasDistance(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_hasDistance(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripTyp__hasDistance_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__hasDistance_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__hasDistance_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::TripTyp::end_hasDistance(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__hasDistance_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::std::string IceProxy::cardroid::data::zerocice::TripTyp::getCharacteristics(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__getCharacteristics_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__getCharacteristics_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->getCharacteristics(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_getCharacteristics(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripTyp__getCharacteristics_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__getCharacteristics_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__getCharacteristics_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::TripTyp::end_getCharacteristics(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__getCharacteristics_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripTyp::setCharacteristics(
		const ::std::string& characteristics, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__setCharacteristics_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			__del->setCharacteristics(characteristics, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_setCharacteristics(
		const ::std::string& characteristics, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__setCharacteristics_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__setCharacteristics_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(characteristics);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripTyp::end_setCharacteristics(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripTyp__setCharacteristics_name);
}

bool IceProxy::cardroid::data::zerocice::TripTyp::hasCharacteristics(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__hasCharacteristics_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__hasCharacteristics_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->hasCharacteristics(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_hasCharacteristics(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripTyp__hasCharacteristics_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__hasCharacteristics_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__hasCharacteristics_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::TripTyp::end_hasCharacteristics(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__hasCharacteristics_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripTyp::setTripType(::Ice::Int type,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__setTripType_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			__del->setTripType(type, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_setTripType(
		::Ice::Int type, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__setTripType_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__setTripType_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(type);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripTyp::end_setTripType(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__TripTyp__setTripType_name);
}

::Ice::Int IceProxy::cardroid::data::zerocice::TripTyp::getTripType(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__getTripType_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__getTripType_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->getTripType(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_getTripType(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripTyp__getTripType_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__getTripType_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripTyp__getTripType_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::TripTyp::end_getTripType(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__getTripType_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::std::string IceProxy::cardroid::data::zerocice::TripTyp::toString(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripTyp__toString_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripTyp__toString_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripTyp*>(__delBase.get());
			return __del->toString(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripTyp::begin_toString(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__data__zerocice__TripTyp__toString_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripTyp__toString_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__data__zerocice__TripTyp__toString_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::TripTyp::end_toString(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripTyp__toString_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

const ::std::string&
IceProxy::cardroid::data::zerocice::TripTyp::ice_staticId() {
	return ::cardroid::data::zerocice::TripTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::TripTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::TripTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::TripTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::TripTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::TripTyp::__newInstance() const {
	return new TripTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::WaypointTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::data::zerocice::WaypointTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::WaypointTyp;
		v->__copyFrom(proxy);
	}
}

::Ice::Int IceProxy::cardroid::data::zerocice::WaypointTyp::getNOrder(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__WaypointTyp__getNOrder_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__WaypointTyp__getNOrder_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::WaypointTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::WaypointTyp*>(__delBase.get());
			return __del->getNOrder(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::WaypointTyp::begin_getNOrder(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__WaypointTyp__getNOrder_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__WaypointTyp__getNOrder_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__WaypointTyp__getNOrder_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::WaypointTyp::end_getNOrder(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__WaypointTyp__getNOrder_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::WaypointTyp::setNOrder(
		::Ice::Int nOrder, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__WaypointTyp__setNOrder_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::WaypointTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::WaypointTyp*>(__delBase.get());
			__del->setNOrder(nOrder, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::WaypointTyp::begin_setNOrder(
		::Ice::Int nOrder, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__WaypointTyp__setNOrder_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__WaypointTyp__setNOrder_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(nOrder);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::WaypointTyp::end_setNOrder(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__WaypointTyp__setNOrder_name);
}

::cardroid::data::zerocice::PlaceTypPtr IceProxy::cardroid::data::zerocice::WaypointTyp::getWaypointPlace(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__WaypointTyp__getWaypointPlace_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__WaypointTyp__getWaypointPlace_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::WaypointTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::WaypointTyp*>(__delBase.get());
			return __del->getWaypointPlace(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::WaypointTyp::begin_getWaypointPlace(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__WaypointTyp__getWaypointPlace_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__WaypointTyp__getWaypointPlace_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__WaypointTyp__getWaypointPlace_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::PlaceTypPtr IceProxy::cardroid::data::zerocice::WaypointTyp::end_getWaypointPlace(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__WaypointTyp__getWaypointPlace_name);
	::cardroid::data::zerocice::PlaceTypPtr __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::WaypointTyp::setWaypointPlace(
		const ::cardroid::data::zerocice::PlaceTypPtr& waypointPlace,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__WaypointTyp__setWaypointPlace_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::WaypointTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::WaypointTyp*>(__delBase.get());
			__del->setWaypointPlace(waypointPlace, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::WaypointTyp::begin_setWaypointPlace(
		const ::cardroid::data::zerocice::PlaceTypPtr& waypointPlace,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__WaypointTyp__setWaypointPlace_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__WaypointTyp__setWaypointPlace_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(waypointPlace);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::WaypointTyp::end_setWaypointPlace(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__WaypointTyp__setWaypointPlace_name);
}

::std::string IceProxy::cardroid::data::zerocice::WaypointTyp::toString(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__WaypointTyp__toString_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__WaypointTyp__toString_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::WaypointTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::WaypointTyp*>(__delBase.get());
			return __del->toString(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::WaypointTyp::begin_toString(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__WaypointTyp__toString_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__WaypointTyp__toString_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__WaypointTyp__toString_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::WaypointTyp::end_toString(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__WaypointTyp__toString_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

const ::std::string&
IceProxy::cardroid::data::zerocice::WaypointTyp::ice_staticId() {
	return ::cardroid::data::zerocice::WaypointTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::WaypointTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::WaypointTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::WaypointTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::WaypointTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::WaypointTyp::__newInstance() const {
	return new WaypointTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::PassengerTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::data::zerocice::PassengerTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::PassengerTyp;
		v->__copyFrom(proxy);
	}
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::data::zerocice::PassengerTyp::getPassengerUser(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PassengerTyp__getPassengerUser_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__PassengerTyp__getPassengerUser_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PassengerTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PassengerTyp*>(__delBase.get());
			return __del->getPassengerUser(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PassengerTyp::begin_getPassengerUser(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__PassengerTyp__getPassengerUser_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__PassengerTyp__getPassengerUser_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PassengerTyp__getPassengerUser_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::data::zerocice::PassengerTyp::end_getPassengerUser(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__PassengerTyp__getPassengerUser_name);
	::cardroid::data::zerocice::UserTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::PassengerTyp::setPassengerUser(
		const ::cardroid::data::zerocice::UserTypPrx& passengerUser,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PassengerTyp__setPassengerUser_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PassengerTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PassengerTyp*>(__delBase.get());
			__del->setPassengerUser(passengerUser, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PassengerTyp::begin_setPassengerUser(
		const ::cardroid::data::zerocice::UserTypPrx& passengerUser,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__PassengerTyp__setPassengerUser_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PassengerTyp__setPassengerUser_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(passengerUser);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::PassengerTyp::end_setPassengerUser(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__PassengerTyp__setPassengerUser_name);
}

::Ice::Int IceProxy::cardroid::data::zerocice::PassengerTyp::getNSeats(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PassengerTyp__getNSeats_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__PassengerTyp__getNSeats_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PassengerTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PassengerTyp*>(__delBase.get());
			return __del->getNSeats(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PassengerTyp::begin_getNSeats(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__PassengerTyp__getNSeats_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PassengerTyp__getNSeats_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PassengerTyp__getNSeats_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::PassengerTyp::end_getNSeats(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__PassengerTyp__getNSeats_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::PassengerTyp::setNSeats(
		::Ice::Int nSeats, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PassengerTyp__setNSeats_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PassengerTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PassengerTyp*>(__delBase.get());
			__del->setNSeats(nSeats, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PassengerTyp::begin_setNSeats(
		::Ice::Int nSeats, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PassengerTyp__setNSeats_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PassengerTyp__setNSeats_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(nSeats);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::PassengerTyp::end_setNSeats(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__PassengerTyp__setNSeats_name);
}

::std::string IceProxy::cardroid::data::zerocice::PassengerTyp::toString(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__PassengerTyp__toString_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__PassengerTyp__toString_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::PassengerTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::PassengerTyp*>(__delBase.get());
			return __del->toString(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::PassengerTyp::begin_toString(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__PassengerTyp__toString_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__PassengerTyp__toString_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__PassengerTyp__toString_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::PassengerTyp::end_toString(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__PassengerTyp__toString_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

const ::std::string&
IceProxy::cardroid::data::zerocice::PassengerTyp::ice_staticId() {
	return ::cardroid::data::zerocice::PassengerTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::PassengerTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::PassengerTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::PassengerTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::PassengerTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::PassengerTyp::__newInstance() const {
	return new PassengerTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::TripOfferTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::data::zerocice::TripOfferTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::TripOfferTyp;
		v->__copyFrom(proxy);
	}
}

::cardroid::data::zerocice::DateTimeTypPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::getTripDateTime(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__getTripDateTime_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__getTripDateTime_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->getTripDateTime(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_getTripDateTime(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__getTripDateTime_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__getTripDateTime_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__getTripDateTime_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::DateTimeTypPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::end_getTripDateTime(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__getTripDateTime_name);
	::cardroid::data::zerocice::DateTimeTypPtr __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::setTripDateTime(
		const ::cardroid::data::zerocice::DateTimeTypPtr& dt,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__setTripDateTime_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			__del->setTripDateTime(dt, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_setTripDateTime(
		const ::cardroid::data::zerocice::DateTimeTypPtr& dt,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__setTripDateTime_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__setTripDateTime_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(dt);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::end_setTripDateTime(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripOfferTyp__setTripDateTime_name);
}

::cardroid::data::zerocice::DateTimeTypPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::getTripReturnDateTime(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__getTripReturnDateTime_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__getTripReturnDateTime_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->getTripReturnDateTime(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_getTripReturnDateTime(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__getTripReturnDateTime_name);
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__data__zerocice__TripOfferTyp__getTripReturnDateTime_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__getTripReturnDateTime_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::DateTimeTypPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::end_getTripReturnDateTime(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__getTripReturnDateTime_name);
	::cardroid::data::zerocice::DateTimeTypPtr __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::setTripReturnDateTime(
		const ::cardroid::data::zerocice::DateTimeTypPtr& rdt,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__setTripReturnDateTime_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			__del->setTripReturnDateTime(rdt, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_setTripReturnDateTime(
		const ::cardroid::data::zerocice::DateTimeTypPtr& rdt,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__data__zerocice__TripOfferTyp__setTripReturnDateTime_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__setTripReturnDateTime_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(rdt);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::end_setTripReturnDateTime(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripOfferTyp__setTripReturnDateTime_name);
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::data::zerocice::TripOfferTyp::getTripDriver(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__getTripDriver_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__getTripDriver_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->getTripDriver(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_getTripDriver(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__getTripDriver_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripOfferTyp__getTripDriver_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__getTripDriver_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::data::zerocice::TripOfferTyp::end_getTripDriver(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__getTripDriver_name);
	::cardroid::data::zerocice::UserTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::setTripDriver(
		const ::cardroid::data::zerocice::UserTypPrx& driver,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__setTripDriver_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			__del->setTripDriver(driver, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_setTripDriver(
		const ::cardroid::data::zerocice::UserTypPrx& driver,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripOfferTyp__setTripDriver_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__setTripDriver_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(driver);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::end_setTripDriver(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripOfferTyp__setTripDriver_name);
}

::cardroid::data::zerocice::WaypointCollection IceProxy::cardroid::data::zerocice::TripOfferTyp::getTripWaypoints(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__getTripWaypoints_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__getTripWaypoints_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->getTripWaypoints(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_getTripWaypoints(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__getTripWaypoints_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__getTripWaypoints_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__getTripWaypoints_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::WaypointCollection IceProxy::cardroid::data::zerocice::TripOfferTyp::end_getTripWaypoints(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__getTripWaypoints_name);
	::cardroid::data::zerocice::WaypointCollection __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::setTripWaypoints(
		const ::cardroid::data::zerocice::WaypointCollection& waypoints,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__setTripWaypoints_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			__del->setTripWaypoints(waypoints, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_setTripWaypoints(
		const ::cardroid::data::zerocice::WaypointCollection& waypoints,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__setTripWaypoints_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__setTripWaypoints_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(waypoints);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::end_setTripWaypoints(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripOfferTyp__setTripWaypoints_name);
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::data::zerocice::TripOfferTyp::getTripCar(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__getTripCar_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__getTripCar_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->getTripCar(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_getTripCar(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__getTripCar_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripOfferTyp__getTripCar_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__getTripCar_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::data::zerocice::TripOfferTyp::end_getTripCar(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__getTripCar_name);
	::cardroid::data::zerocice::CarTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::setTripCar(
		const ::cardroid::data::zerocice::CarTypPrx& tripCar,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__setTripCar_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			__del->setTripCar(tripCar, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_setTripCar(
		const ::cardroid::data::zerocice::CarTypPrx& tripCar,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripOfferTyp__setTripCar_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__setTripCar_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripCar);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::end_setTripCar(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__TripOfferTyp__setTripCar_name);
}

::cardroid::data::zerocice::PassengerCollection IceProxy::cardroid::data::zerocice::TripOfferTyp::getTripPassengers(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__getTripPassengers_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__getTripPassengers_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->getTripPassengers(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_getTripPassengers(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__getTripPassengers_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__getTripPassengers_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__getTripPassengers_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::PassengerCollection IceProxy::cardroid::data::zerocice::TripOfferTyp::end_getTripPassengers(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__getTripPassengers_name);
	::cardroid::data::zerocice::PassengerCollection __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::setTripPassengers(
		const ::cardroid::data::zerocice::PassengerCollection& passengers,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__setTripPassengers_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			__del->setTripPassengers(passengers, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_setTripPassengers(
		const ::cardroid::data::zerocice::PassengerCollection& passengers,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__setTripPassengers_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__setTripPassengers_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(passengers);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::end_setTripPassengers(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripOfferTyp__setTripPassengers_name);
}

::Ice::Double IceProxy::cardroid::data::zerocice::TripOfferTyp::getPrice(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__getPrice_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__getPrice_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->getPrice(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_getPrice(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__getPrice_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripOfferTyp__getPrice_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__getPrice_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Double IceProxy::cardroid::data::zerocice::TripOfferTyp::end_getPrice(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__getPrice_name);
	::Ice::Double __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::setPrice(
		::Ice::Double price, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__setPrice_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			__del->setPrice(price, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_setPrice(
		::Ice::Double price, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__TripOfferTyp__setPrice_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__setPrice_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(price);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::end_setPrice(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__TripOfferTyp__setPrice_name);
}

::cardroid::data::zerocice::AllowedV IceProxy::cardroid::data::zerocice::TripOfferTyp::getAllowedFeatures(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__getAllowedFeatures_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__getAllowedFeatures_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->getAllowedFeatures(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_getAllowedFeatures(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__getAllowedFeatures_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__getAllowedFeatures_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__getAllowedFeatures_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::AllowedV IceProxy::cardroid::data::zerocice::TripOfferTyp::end_getAllowedFeatures(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__getAllowedFeatures_name);
	::cardroid::data::zerocice::AllowedV __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::setAllowedFeatures(
		const ::cardroid::data::zerocice::AllowedV& allowed,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__setAllowedFeatures_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			__del->setAllowedFeatures(allowed, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_setAllowedFeatures(
		const ::cardroid::data::zerocice::AllowedV& allowed,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__setAllowedFeatures_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__setAllowedFeatures_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(allowed);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::end_setAllowedFeatures(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripOfferTyp__setAllowedFeatures_name);
}

bool IceProxy::cardroid::data::zerocice::TripOfferTyp::addTripWaypoint(
		const ::cardroid::data::zerocice::PlaceTypPtr& waypoint,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__addTripWaypoint_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__addTripWaypoint_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->addTripWaypoint(waypoint, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_addTripWaypoint(
		const ::cardroid::data::zerocice::PlaceTypPtr& waypoint,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__addTripWaypoint_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__addTripWaypoint_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__addTripWaypoint_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(waypoint);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::TripOfferTyp::end_addTripWaypoint(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__addTripWaypoint_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

bool IceProxy::cardroid::data::zerocice::TripOfferTyp::removeTripWaypoint(
		::Ice::Int pos, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__removeTripWaypoint_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__removeTripWaypoint_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->removeTripWaypoint(pos, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_removeTripWaypoint(
		::Ice::Int pos, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__removeTripWaypoint_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__removeTripWaypoint_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__removeTripWaypoint_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(pos);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::TripOfferTyp::end_removeTripWaypoint(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__removeTripWaypoint_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::Ice::Int IceProxy::cardroid::data::zerocice::TripOfferTyp::getNTripWaypoints(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__getNTripWaypoints_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__getNTripWaypoints_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->getNTripWaypoints(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_getNTripWaypoints(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__getNTripWaypoints_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__getNTripWaypoints_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__getNTripWaypoints_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::TripOfferTyp::end_getNTripWaypoints(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__getNTripWaypoints_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::clearTripWaypoints(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__clearTripWaypoints_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			__del->clearTripWaypoints(__ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_clearTripWaypoints(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__clearTripWaypoints_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__clearTripWaypoints_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::end_clearTripWaypoints(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripOfferTyp__clearTripWaypoints_name);
}

bool IceProxy::cardroid::data::zerocice::TripOfferTyp::addTripPassenger(
		const ::cardroid::data::zerocice::UserTypPrx& passenger,
		::Ice::Int seats, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__addTripPassenger_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__addTripPassenger_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->addTripPassenger(passenger, seats, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_addTripPassenger(
		const ::cardroid::data::zerocice::UserTypPrx& passenger,
		::Ice::Int seats, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__addTripPassenger_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__addTripPassenger_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__addTripPassenger_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(passenger);
		__os->write(seats);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::TripOfferTyp::end_addTripPassenger(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__addTripPassenger_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

bool IceProxy::cardroid::data::zerocice::TripOfferTyp::removeTripPassenger(
		const ::cardroid::data::zerocice::UserTypPrx& passenger,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__removeTripPassenger_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__removeTripPassenger_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->removeTripPassenger(passenger, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_removeTripPassenger(
		const ::cardroid::data::zerocice::UserTypPrx& passenger,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__removeTripPassenger_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__removeTripPassenger_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__removeTripPassenger_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(passenger);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::data::zerocice::TripOfferTyp::end_removeTripPassenger(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__removeTripPassenger_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::Ice::Int IceProxy::cardroid::data::zerocice::TripOfferTyp::getNTripPassengers(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__getNTripPassengers_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripOfferTyp__getNTripPassengers_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			return __del->getNTripPassengers(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_getNTripPassengers(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripOfferTyp__getNTripPassengers_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__getNTripPassengers_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__getNTripPassengers_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Int IceProxy::cardroid::data::zerocice::TripOfferTyp::end_getNTripPassengers(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripOfferTyp__getNTripPassengers_name);
	::Ice::Int __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::clearTripPassengers(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripOfferTyp__clearTripPassengers_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripOfferTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripOfferTyp*>(__delBase.get());
			__del->clearTripPassengers(__ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripOfferTyp::begin_clearTripPassengers(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripOfferTyp__clearTripPassengers_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripOfferTyp__clearTripPassengers_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripOfferTyp::end_clearTripPassengers(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripOfferTyp__clearTripPassengers_name);
}

const ::std::string&
IceProxy::cardroid::data::zerocice::TripOfferTyp::ice_staticId() {
	return ::cardroid::data::zerocice::TripOfferTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::TripOfferTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::TripOfferTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::TripOfferTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::TripOfferTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::TripOfferTyp::__newInstance() const {
	return new TripOfferTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::TripRequestTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::data::zerocice::TripRequestTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::TripRequestTyp;
		v->__copyFrom(proxy);
	}
}

::cardroid::data::zerocice::DateTimePrefsTypPtr IceProxy::cardroid::data::zerocice::TripRequestTyp::getTripDateTimePrefs(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripRequestTyp__getTripDateTimePrefs_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripRequestTyp__getTripDateTimePrefs_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripRequestTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripRequestTyp*>(__delBase.get());
			return __del->getTripDateTimePrefs(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripRequestTyp::begin_getTripDateTimePrefs(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripRequestTyp__getTripDateTimePrefs_name);
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__data__zerocice__TripRequestTyp__getTripDateTimePrefs_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripRequestTyp__getTripDateTimePrefs_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::DateTimePrefsTypPtr IceProxy::cardroid::data::zerocice::TripRequestTyp::end_getTripDateTimePrefs(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripRequestTyp__getTripDateTimePrefs_name);
	::cardroid::data::zerocice::DateTimePrefsTypPtr __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripRequestTyp::setTripDateTimePrefs(
		const ::cardroid::data::zerocice::DateTimePrefsTypPtr& dtp,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripRequestTyp__setTripDateTimePrefs_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripRequestTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripRequestTyp*>(__delBase.get());
			__del->setTripDateTimePrefs(dtp, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripRequestTyp::begin_setTripDateTimePrefs(
		const ::cardroid::data::zerocice::DateTimePrefsTypPtr& dtp,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__data__zerocice__TripRequestTyp__setTripDateTimePrefs_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripRequestTyp__setTripDateTimePrefs_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(dtp);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripRequestTyp::end_setTripDateTimePrefs(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripRequestTyp__setTripDateTimePrefs_name);
}

::cardroid::data::zerocice::DateTimePrefsTypPtr IceProxy::cardroid::data::zerocice::TripRequestTyp::getTripReturnDateTimePrefs(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripRequestTyp__getTripReturnDateTimePrefs_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripRequestTyp__getTripReturnDateTimePrefs_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripRequestTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripRequestTyp*>(__delBase.get());
			return __del->getTripReturnDateTimePrefs(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripRequestTyp::begin_getTripReturnDateTimePrefs(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripRequestTyp__getTripReturnDateTimePrefs_name);
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__data__zerocice__TripRequestTyp__getTripReturnDateTimePrefs_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripRequestTyp__getTripReturnDateTimePrefs_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::DateTimePrefsTypPtr IceProxy::cardroid::data::zerocice::TripRequestTyp::end_getTripReturnDateTimePrefs(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripRequestTyp__getTripReturnDateTimePrefs_name);
	::cardroid::data::zerocice::DateTimePrefsTypPtr __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripRequestTyp::setTripReturnDateTimePrefs(
		const ::cardroid::data::zerocice::DateTimePrefsTypPtr& rdtp,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripRequestTyp__setTripReturnDateTimePrefs_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripRequestTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripRequestTyp*>(__delBase.get());
			__del->setTripReturnDateTimePrefs(rdtp, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripRequestTyp::begin_setTripReturnDateTimePrefs(
		const ::cardroid::data::zerocice::DateTimePrefsTypPtr& rdtp,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__data__zerocice__TripRequestTyp__setTripReturnDateTimePrefs_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripRequestTyp__setTripReturnDateTimePrefs_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(rdtp);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripRequestTyp::end_setTripReturnDateTimePrefs(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripRequestTyp__setTripReturnDateTimePrefs_name);
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::data::zerocice::TripRequestTyp::getTripRequester(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripRequestTyp__getTripRequester_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__TripRequestTyp__getTripRequester_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripRequestTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripRequestTyp*>(__delBase.get());
			return __del->getTripRequester(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripRequestTyp::begin_getTripRequester(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__TripRequestTyp__getTripRequester_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripRequestTyp__getTripRequester_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripRequestTyp__getTripRequester_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::data::zerocice::TripRequestTyp::end_getTripRequester(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__TripRequestTyp__getTripRequester_name);
	::cardroid::data::zerocice::UserTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::TripRequestTyp::setTripRequester(
		const ::cardroid::data::zerocice::UserTypPrx& requester,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__TripRequestTyp__setTripRequester_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::TripRequestTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::TripRequestTyp*>(__delBase.get());
			__del->setTripRequester(requester, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::TripRequestTyp::begin_setTripRequester(
		const ::cardroid::data::zerocice::UserTypPrx& requester,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__TripRequestTyp__setTripRequester_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__TripRequestTyp__setTripRequester_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(requester);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::TripRequestTyp::end_setTripRequester(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__TripRequestTyp__setTripRequester_name);
}

const ::std::string&
IceProxy::cardroid::data::zerocice::TripRequestTyp::ice_staticId() {
	return ::cardroid::data::zerocice::TripRequestTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::TripRequestTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::TripRequestTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::TripRequestTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::TripRequestTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::TripRequestTyp::__newInstance() const {
	return new TripRequestTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::UserActivityTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::data::zerocice::UserActivityTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::UserActivityTyp;
		v->__copyFrom(proxy);
	}
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::data::zerocice::UserActivityTyp::getActivityUser(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserActivityTyp__getActivityUser_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserActivityTyp__getActivityUser_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserActivityTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserActivityTyp*>(__delBase.get());
			return __del->getActivityUser(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserActivityTyp::begin_getActivityUser(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__UserActivityTyp__getActivityUser_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__UserActivityTyp__getActivityUser_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserActivityTyp__getActivityUser_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::data::zerocice::UserActivityTyp::end_getActivityUser(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserActivityTyp__getActivityUser_name);
	::cardroid::data::zerocice::UserTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserActivityTyp::setActivityUser(
		const ::cardroid::data::zerocice::UserTypPrx& activityUser,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserActivityTyp__setActivityUser_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserActivityTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserActivityTyp*>(__delBase.get());
			__del->setActivityUser(activityUser, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserActivityTyp::begin_setActivityUser(
		const ::cardroid::data::zerocice::UserTypPrx& activityUser,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__UserActivityTyp__setActivityUser_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserActivityTyp__setActivityUser_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(activityUser);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserActivityTyp::end_setActivityUser(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__UserActivityTyp__setActivityUser_name);
}

::cardroid::data::zerocice::TripOfferTypPrx IceProxy::cardroid::data::zerocice::UserActivityTyp::getActivityTrip(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserActivityTyp__getActivityTrip_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserActivityTyp__getActivityTrip_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserActivityTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserActivityTyp*>(__delBase.get());
			return __del->getActivityTrip(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserActivityTyp::begin_getActivityTrip(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__UserActivityTyp__getActivityTrip_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__UserActivityTyp__getActivityTrip_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserActivityTyp__getActivityTrip_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::TripOfferTypPrx IceProxy::cardroid::data::zerocice::UserActivityTyp::end_getActivityTrip(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserActivityTyp__getActivityTrip_name);
	::cardroid::data::zerocice::TripOfferTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserActivityTyp::setActivityTrip(
		const ::cardroid::data::zerocice::TripOfferTypPrx& activityTrip,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserActivityTyp__setActivityTrip_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserActivityTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserActivityTyp*>(__delBase.get());
			__del->setActivityTrip(activityTrip, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserActivityTyp::begin_setActivityTrip(
		const ::cardroid::data::zerocice::TripOfferTypPrx& activityTrip,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__UserActivityTyp__setActivityTrip_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserActivityTyp__setActivityTrip_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(activityTrip);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserActivityTyp::end_setActivityTrip(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__UserActivityTyp__setActivityTrip_name);
}

::cardroid::data::zerocice::ActivityType IceProxy::cardroid::data::zerocice::UserActivityTyp::getUserActivityType(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserActivityTyp__getUserActivityType_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserActivityTyp__getUserActivityType_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserActivityTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserActivityTyp*>(__delBase.get());
			return __del->getUserActivityType(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserActivityTyp::begin_getUserActivityType(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__UserActivityTyp__getUserActivityType_name);
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__data__zerocice__UserActivityTyp__getUserActivityType_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserActivityTyp__getUserActivityType_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::ActivityType IceProxy::cardroid::data::zerocice::UserActivityTyp::end_getUserActivityType(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserActivityTyp__getUserActivityType_name);
	::cardroid::data::zerocice::ActivityType __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserActivityTyp::setUserActivityType(
		::cardroid::data::zerocice::ActivityType userActivityType,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserActivityTyp__setUserActivityType_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserActivityTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserActivityTyp*>(__delBase.get());
			__del->setUserActivityType(userActivityType, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserActivityTyp::begin_setUserActivityType(
		::cardroid::data::zerocice::ActivityType userActivityType,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__data__zerocice__UserActivityTyp__setUserActivityType_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserActivityTyp__setUserActivityType_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(userActivityType);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserActivityTyp::end_setUserActivityType(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__UserActivityTyp__setUserActivityType_name);
}

::Ice::Long IceProxy::cardroid::data::zerocice::UserActivityTyp::getTimeStampInMillis(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserActivityTyp__getTimeStampInMillis_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserActivityTyp__getTimeStampInMillis_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserActivityTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserActivityTyp*>(__delBase.get());
			return __del->getTimeStampInMillis(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserActivityTyp::begin_getTimeStampInMillis(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__UserActivityTyp__getTimeStampInMillis_name);
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__data__zerocice__UserActivityTyp__getTimeStampInMillis_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserActivityTyp__getTimeStampInMillis_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Long IceProxy::cardroid::data::zerocice::UserActivityTyp::end_getTimeStampInMillis(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserActivityTyp__getTimeStampInMillis_name);
	::Ice::Long __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::UserActivityTyp::setTimeStampInMillis(
		::Ice::Long timeStampMillis, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserActivityTyp__setTimeStampInMillis_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserActivityTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserActivityTyp*>(__delBase.get());
			__del->setTimeStampInMillis(timeStampMillis, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserActivityTyp::begin_setTimeStampInMillis(
		::Ice::Long timeStampMillis, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__data__zerocice__UserActivityTyp__setTimeStampInMillis_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserActivityTyp__setTimeStampInMillis_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(timeStampMillis);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::UserActivityTyp::end_setTimeStampInMillis(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__UserActivityTyp__setTimeStampInMillis_name);
}

::std::string IceProxy::cardroid::data::zerocice::UserActivityTyp::toString(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__UserActivityTyp__toString_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__UserActivityTyp__toString_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::UserActivityTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::UserActivityTyp*>(__delBase.get());
			return __del->toString(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::UserActivityTyp::begin_toString(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__UserActivityTyp__toString_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__UserActivityTyp__toString_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__UserActivityTyp__toString_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::UserActivityTyp::end_toString(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__UserActivityTyp__toString_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

const ::std::string&
IceProxy::cardroid::data::zerocice::UserActivityTyp::ice_staticId() {
	return ::cardroid::data::zerocice::UserActivityTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::UserActivityTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::UserActivityTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::UserActivityTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::UserActivityTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::UserActivityTyp::__newInstance() const {
	return new UserActivityTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::data::zerocice::upCast(
		::IceProxy::cardroid::data::zerocice::MessageTyp* p) {
	return p;
}

void ::IceProxy::cardroid::data::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::data::zerocice::MessageTyp>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::data::zerocice::MessageTyp;
		v->__copyFrom(proxy);
	}
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::data::zerocice::MessageTyp::getUser1(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__MessageTyp__getUser1_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__MessageTyp__getUser1_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::MessageTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::MessageTyp*>(__delBase.get());
			return __del->getUser1(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::MessageTyp::begin_getUser1(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__MessageTyp__getUser1_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__MessageTyp__getUser1_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__MessageTyp__getUser1_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::data::zerocice::MessageTyp::end_getUser1(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__MessageTyp__getUser1_name);
	::cardroid::data::zerocice::UserTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::MessageTyp::setUser1(
		const ::cardroid::data::zerocice::UserTypPrx& user1,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__MessageTyp__setUser1_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::MessageTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::MessageTyp*>(__delBase.get());
			__del->setUser1(user1, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::MessageTyp::begin_setUser1(
		const ::cardroid::data::zerocice::UserTypPrx& user1,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__MessageTyp__setUser1_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__MessageTyp__setUser1_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(user1);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::MessageTyp::end_setUser1(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__MessageTyp__setUser1_name);
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::data::zerocice::MessageTyp::getUser2(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__MessageTyp__getUser2_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__MessageTyp__getUser2_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::MessageTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::MessageTyp*>(__delBase.get());
			return __del->getUser2(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::MessageTyp::begin_getUser2(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__MessageTyp__getUser2_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__MessageTyp__getUser2_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__MessageTyp__getUser2_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::data::zerocice::MessageTyp::end_getUser2(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__MessageTyp__getUser2_name);
	::cardroid::data::zerocice::UserTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::MessageTyp::setUser2(
		const ::cardroid::data::zerocice::UserTypPrx& user2,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__MessageTyp__setUser2_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::MessageTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::MessageTyp*>(__delBase.get());
			__del->setUser2(user2, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::MessageTyp::begin_setUser2(
		const ::cardroid::data::zerocice::UserTypPrx& user2,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__MessageTyp__setUser2_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__MessageTyp__setUser2_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(user2);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::MessageTyp::end_setUser2(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__data__zerocice__MessageTyp__setUser2_name);
}

::std::string IceProxy::cardroid::data::zerocice::MessageTyp::getMessageText(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__MessageTyp__getMessageText_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__MessageTyp__getMessageText_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::MessageTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::MessageTyp*>(__delBase.get());
			return __del->getMessageText(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::MessageTyp::begin_getMessageText(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__MessageTyp__getMessageText_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__MessageTyp__getMessageText_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__MessageTyp__getMessageText_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::MessageTyp::end_getMessageText(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__MessageTyp__getMessageText_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::MessageTyp::setMessageText(
		const ::std::string& msg, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__MessageTyp__setMessageText_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::MessageTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::MessageTyp*>(__delBase.get());
			__del->setMessageText(msg, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::MessageTyp::begin_setMessageText(
		const ::std::string& msg, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__MessageTyp__setMessageText_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__MessageTyp__setMessageText_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(msg);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::MessageTyp::end_setMessageText(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__MessageTyp__setMessageText_name);
}

::Ice::Long IceProxy::cardroid::data::zerocice::MessageTyp::getTimeStampInMillis(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__MessageTyp__getTimeStampInMillis_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__MessageTyp__getTimeStampInMillis_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::MessageTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::MessageTyp*>(__delBase.get());
			return __del->getTimeStampInMillis(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::MessageTyp::begin_getTimeStampInMillis(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__MessageTyp__getTimeStampInMillis_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__MessageTyp__getTimeStampInMillis_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__MessageTyp__getTimeStampInMillis_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Long IceProxy::cardroid::data::zerocice::MessageTyp::end_getTimeStampInMillis(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__MessageTyp__getTimeStampInMillis_name);
	::Ice::Long __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::data::zerocice::MessageTyp::setTimeStampInMillis(
		::Ice::Long timeStampMillis, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__MessageTyp__setTimeStampInMillis_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::MessageTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::MessageTyp*>(__delBase.get());
			__del->setTimeStampInMillis(timeStampMillis, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::MessageTyp::begin_setTimeStampInMillis(
		::Ice::Long timeStampMillis, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__data__zerocice__MessageTyp__setTimeStampInMillis_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__MessageTyp__setTimeStampInMillis_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(timeStampMillis);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::data::zerocice::MessageTyp::end_setTimeStampInMillis(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__data__zerocice__MessageTyp__setTimeStampInMillis_name);
}

::std::string IceProxy::cardroid::data::zerocice::MessageTyp::toString(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__data__zerocice__MessageTyp__toString_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__data__zerocice__MessageTyp__toString_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::data::zerocice::MessageTyp* __del =
					dynamic_cast< ::IceDelegate::cardroid::data::zerocice::MessageTyp*>(__delBase.get());
			return __del->toString(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::data::zerocice::MessageTyp::begin_toString(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__data__zerocice__MessageTyp__toString_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__data__zerocice__MessageTyp__toString_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__data__zerocice__MessageTyp__toString_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::std::string IceProxy::cardroid::data::zerocice::MessageTyp::end_toString(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__data__zerocice__MessageTyp__toString_name);
	::std::string __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

const ::std::string&
IceProxy::cardroid::data::zerocice::MessageTyp::ice_staticId() {
	return ::cardroid::data::zerocice::MessageTyp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::data::zerocice::MessageTyp::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::data::zerocice::MessageTyp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::data::zerocice::MessageTyp::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::data::zerocice::MessageTyp);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::data::zerocice::MessageTyp::__newInstance() const {
	return new MessageTyp;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::upCast(
		::IceProxy::cardroid::QueryResult* p) {
	return p;
}

void ::IceProxy::cardroid::__read(::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle< ::IceProxy::cardroid::QueryResult>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::QueryResult;
		v->__copyFrom(proxy);
	}
}

::cardroid::ResultSeq IceProxy::cardroid::QueryResult::next(::Ice::Int n,
		bool& destroyed, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__QueryResult__next_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(__cardroid__QueryResult__next_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::QueryResult* __del =
					dynamic_cast< ::IceDelegate::cardroid::QueryResult*>(__delBase.get());
			return __del->next(n, destroyed, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::QueryResult::begin_next(::Ice::Int n,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__QueryResult__next_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__QueryResult__next_name, __del, __cookie);
	try {
		__result->__prepare(__cardroid__QueryResult__next_name, ::Ice::Normal,
				__ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(n);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::ResultSeq IceProxy::cardroid::QueryResult::end_next(bool& destroyed,
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__QueryResult__next_name);
	::cardroid::ResultSeq __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(destroyed);
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::QueryResult::destroy(const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__QueryResult__destroy_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::QueryResult* __del =
					dynamic_cast< ::IceDelegate::cardroid::QueryResult*>(__delBase.get());
			__del->destroy(__ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::QueryResult::begin_destroy(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__QueryResult__destroy_name, __del, __cookie);
	try {
		__result->__prepare(__cardroid__QueryResult__destroy_name,
				::Ice::Normal, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::QueryResult::end_destroy(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__QueryResult__destroy_name);
}

const ::std::string&
IceProxy::cardroid::QueryResult::ice_staticId() {
	return ::cardroid::QueryResult::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::QueryResult::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::QueryResult);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::QueryResult::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::QueryResult);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::QueryResult::__newInstance() const {
	return new QueryResult;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::zerocice::upCast(
		::IceProxy::cardroid::zerocice::CardroidManager* p) {
	return p;
}

void ::IceProxy::cardroid::zerocice::__read(::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::zerocice::CardroidManager>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::zerocice::CardroidManager;
		v->__copyFrom(proxy);
	}
}

void IceProxy::cardroid::zerocice::CardroidManager::getUserPlaces(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__getUserPlaces_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__getUserPlaces_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			__del->getUserPlaces(usr, n, first, nrows, result, __ctx,
					__observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_getUserPlaces(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__getUserPlaces_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__getUserPlaces_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__getUserPlaces_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr);
		__os->write(n);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::zerocice::CardroidManager::end_getUserPlaces(
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result,
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__getUserPlaces_name);
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__result->__endReadParams();
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::zerocice::CardroidManager::searchTrips(
		const ::cardroid::data::zerocice::TripRequestTypPtr& tRequest,
		::Ice::Int n, ::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__searchTrips_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__searchTrips_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			__del->searchTrips(tRequest, n, first, nrows, result, __ctx,
					__observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_searchTrips(
		const ::cardroid::data::zerocice::TripRequestTypPtr& tRequest,
		::Ice::Int n, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__searchTrips_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__searchTrips_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__searchTrips_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tRequest);
		__os->write(n);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::zerocice::CardroidManager::end_searchTrips(
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result,
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__searchTrips_name);
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__result->__endReadParams();
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::TripTypPrx IceProxy::cardroid::zerocice::CardroidManager::getTripFromId(
		::Ice::Int tripId, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__getTripFromId_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__getTripFromId_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->getTripFromId(tripId, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_getTripFromId(
		::Ice::Int tripId, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__getTripFromId_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__getTripFromId_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__getTripFromId_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripId);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::TripTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_getTripFromId(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__getTripFromId_name);
	::cardroid::data::zerocice::TripTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::TripOfferTypPrx IceProxy::cardroid::zerocice::CardroidManager::getTripOfferFromId(
		::Ice::Int tripId, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__getTripOfferFromId_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__getTripOfferFromId_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->getTripOfferFromId(tripId, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_getTripOfferFromId(
		::Ice::Int tripId, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__getTripOfferFromId_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__zerocice__CardroidManager__getTripOfferFromId_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__getTripOfferFromId_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripId);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::TripOfferTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_getTripOfferFromId(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__getTripOfferFromId_name);
	::cardroid::data::zerocice::TripOfferTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::TripRequestTypPrx IceProxy::cardroid::zerocice::CardroidManager::getTripRequestFromId(
		::Ice::Int tripId, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__getTripRequestFromId_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__getTripRequestFromId_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->getTripRequestFromId(tripId, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_getTripRequestFromId(
		::Ice::Int tripId, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__getTripRequestFromId_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__zerocice__CardroidManager__getTripRequestFromId_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__getTripRequestFromId_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripId);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::TripRequestTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_getTripRequestFromId(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__getTripRequestFromId_name);
	::cardroid::data::zerocice::TripRequestTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::zerocice::CardroidManager::joinTrip(
		const ::cardroid::data::zerocice::TripOfferTypPrx& trip,
		const ::cardroid::data::zerocice::UserTypPrx& passenger,
		::Ice::Int nSeats, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__joinTrip_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			__del->joinTrip(trip, passenger, nSeats, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_joinTrip(
		const ::cardroid::data::zerocice::TripOfferTypPrx& trip,
		const ::cardroid::data::zerocice::UserTypPrx& passenger,
		::Ice::Int nSeats, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__joinTrip_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__joinTrip_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(trip);
		__os->write(passenger);
		__os->write(nSeats);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::zerocice::CardroidManager::end_joinTrip(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__zerocice__CardroidManager__joinTrip_name);
}

::cardroid::data::zerocice::TripOfferTypPrx IceProxy::cardroid::zerocice::CardroidManager::organizeTrip(
		const ::cardroid::data::zerocice::TripRequestTypPrx& tripRequest,
		const ::cardroid::data::zerocice::TripOfferTypPtr& tripOffer,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__organizeTrip_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__organizeTrip_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->organizeTrip(tripRequest, tripOffer, __ctx,
					__observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_organizeTrip(
		const ::cardroid::data::zerocice::TripRequestTypPrx& tripRequest,
		const ::cardroid::data::zerocice::TripOfferTypPtr& tripOffer,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__organizeTrip_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__organizeTrip_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__organizeTrip_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripRequest);
		__os->write(tripOffer);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::TripOfferTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_organizeTrip(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__organizeTrip_name);
	::cardroid::data::zerocice::TripOfferTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::zerocice::CardroidManager::getUserTrips(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__getUserTrips_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__getUserTrips_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			__del->getUserTrips(usr, n, first, nrows, result, __ctx,
					__observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_getUserTrips(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__getUserTrips_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__getUserTrips_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__getUserTrips_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr);
		__os->write(n);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::zerocice::CardroidManager::end_getUserTrips(
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result,
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__getUserTrips_name);
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__result->__endReadParams();
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::zerocice::CardroidManager::getPassengerTrips(
		const ::cardroid::data::zerocice::UserTypPrx& passenger, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__getPassengerTrips_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__getPassengerTrips_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			__del->getPassengerTrips(passenger, n, first, nrows, result, __ctx,
					__observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_getPassengerTrips(
		const ::cardroid::data::zerocice::UserTypPrx& passenger, ::Ice::Int n,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__getPassengerTrips_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__getPassengerTrips_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__getPassengerTrips_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(passenger);
		__os->write(n);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::zerocice::CardroidManager::end_getPassengerTrips(
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result,
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__getPassengerTrips_name);
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__result->__endReadParams();
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

bool IceProxy::cardroid::zerocice::CardroidManager::userTripRegistered(
		const ::cardroid::data::zerocice::UserTypPrx& usr,
		const ::cardroid::data::zerocice::TripTypPrx& trip,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__userTripRegistered_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__userTripRegistered_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->userTripRegistered(usr, trip, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_userTripRegistered(
		const ::cardroid::data::zerocice::UserTypPrx& usr,
		const ::cardroid::data::zerocice::TripTypPrx& trip,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__userTripRegistered_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__zerocice__CardroidManager__userTripRegistered_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__userTripRegistered_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr);
		__os->write(trip);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::zerocice::CardroidManager::end_userTripRegistered(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__userTripRegistered_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::Ice::Double IceProxy::cardroid::zerocice::CardroidManager::calculatePriceEstimation(
		::cardroid::data::zerocice::Fuel f, ::Ice::Int distance,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__calculatePriceEstimation_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__calculatePriceEstimation_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->calculatePriceEstimation(f, distance, __ctx,
					__observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_calculatePriceEstimation(
		::cardroid::data::zerocice::Fuel f, ::Ice::Int distance,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__calculatePriceEstimation_name);
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__zerocice__CardroidManager__calculatePriceEstimation_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__calculatePriceEstimation_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(f);
		__os->write(distance);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Double IceProxy::cardroid::zerocice::CardroidManager::end_calculatePriceEstimation(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__calculatePriceEstimation_name);
	::Ice::Double __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::TripOfferTypPrx IceProxy::cardroid::zerocice::CardroidManager::newTripOffer(
		const ::cardroid::data::zerocice::TripOfferTypPtr& tOffer,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__newTripOffer_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__newTripOffer_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->newTripOffer(tOffer, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_newTripOffer(
		const ::cardroid::data::zerocice::TripOfferTypPtr& tOffer,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__newTripOffer_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__newTripOffer_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__newTripOffer_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tOffer);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::TripOfferTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_newTripOffer(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__newTripOffer_name);
	::cardroid::data::zerocice::TripOfferTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::TripRequestTypPrx IceProxy::cardroid::zerocice::CardroidManager::newTripRequest(
		const ::cardroid::data::zerocice::TripRequestTypPtr& tRequest,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__newTripRequest_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__newTripRequest_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->newTripRequest(tRequest, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_newTripRequest(
		const ::cardroid::data::zerocice::TripRequestTypPtr& tRequest,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__newTripRequest_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__newTripRequest_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__newTripRequest_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tRequest);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::TripRequestTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_newTripRequest(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__newTripRequest_name);
	::cardroid::data::zerocice::TripRequestTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::zerocice::CardroidManager::getMessageTalksSpeakers(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__getMessageTalksSpeakers_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__getMessageTalksSpeakers_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			__del->getMessageTalksSpeakers(usr, n, first, nrows, result, __ctx,
					__observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_getMessageTalksSpeakers(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__getMessageTalksSpeakers_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__zerocice__CardroidManager__getMessageTalksSpeakers_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__getMessageTalksSpeakers_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr);
		__os->write(n);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::zerocice::CardroidManager::end_getMessageTalksSpeakers(
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result,
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__getMessageTalksSpeakers_name);
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__result->__endReadParams();
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::zerocice::CardroidManager::getMessageTalks(
		const ::cardroid::data::zerocice::UserTypPrx& usr1,
		const ::cardroid::data::zerocice::UserTypPrx& usr2, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__getMessageTalks_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__getMessageTalks_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			__del->getMessageTalks(usr1, usr2, n, first, nrows, result, __ctx,
					__observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_getMessageTalks(
		const ::cardroid::data::zerocice::UserTypPrx& usr1,
		const ::cardroid::data::zerocice::UserTypPrx& usr2, ::Ice::Int n,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__getMessageTalks_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__getMessageTalks_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__getMessageTalks_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr1);
		__os->write(usr2);
		__os->write(n);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::zerocice::CardroidManager::end_getMessageTalks(
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result,
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__getMessageTalks_name);
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__result->__endReadParams();
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::MessageTypPrx IceProxy::cardroid::zerocice::CardroidManager::newMessage(
		const ::cardroid::data::zerocice::UserTypPrx& usr1,
		const ::cardroid::data::zerocice::UserTypPrx& usr2,
		const ::std::string& message, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__newMessage_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__newMessage_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->newMessage(usr1, usr2, message, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_newMessage(
		const ::cardroid::data::zerocice::UserTypPrx& usr1,
		const ::cardroid::data::zerocice::UserTypPrx& usr2,
		const ::std::string& message, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__newMessage_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__newMessage_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__newMessage_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr1);
		__os->write(usr2);
		__os->write(message);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::MessageTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_newMessage(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__newMessage_name);
	::cardroid::data::zerocice::MessageTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::zerocice::CardroidManager::getUserActivity(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__getUserActivity_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__getUserActivity_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			__del->getUserActivity(usr, n, first, nrows, result, __ctx,
					__observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_getUserActivity(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__getUserActivity_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__getUserActivity_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__getUserActivity_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr);
		__os->write(n);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::zerocice::CardroidManager::end_getUserActivity(
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result,
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__getUserActivity_name);
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__result->__endReadParams();
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::zerocice::CardroidManager::getUserFromEmail(
		const ::std::string& email, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__getUserFromEmail_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__getUserFromEmail_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->getUserFromEmail(email, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_getUserFromEmail(
		const ::std::string& email, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__getUserFromEmail_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__getUserFromEmail_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__getUserFromEmail_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(email);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_getUserFromEmail(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__getUserFromEmail_name);
	::cardroid::data::zerocice::UserTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::zerocice::CardroidManager::getCarFromPlate(
		const ::std::string& plate,
		const ::cardroid::data::zerocice::UserTypPrx& owner,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__getCarFromPlate_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__getCarFromPlate_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->getCarFromPlate(plate, owner, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_getCarFromPlate(
		const ::std::string& plate,
		const ::cardroid::data::zerocice::UserTypPrx& owner,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__getCarFromPlate_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__getCarFromPlate_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__getCarFromPlate_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(plate);
		__os->write(owner);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_getCarFromPlate(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__getCarFromPlate_name);
	::cardroid::data::zerocice::CarTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::zerocice::CardroidManager::getCarFromPlateEmail(
		const ::std::string& plate, const ::std::string& ownerEmail,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__getCarFromPlateEmail_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__getCarFromPlateEmail_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->getCarFromPlateEmail(plate, ownerEmail, __ctx,
					__observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_getCarFromPlateEmail(
		const ::std::string& plate, const ::std::string& ownerEmail,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__getCarFromPlateEmail_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__zerocice__CardroidManager__getCarFromPlateEmail_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__getCarFromPlateEmail_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(plate);
		__os->write(ownerEmail);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_getCarFromPlateEmail(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__getCarFromPlateEmail_name);
	::cardroid::data::zerocice::CarTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::zerocice::CardroidManager::updateUserData(
		const ::cardroid::data::zerocice::UserTypPtr& usr,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__updateUserData_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__updateUserData_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->updateUserData(usr, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_updateUserData(
		const ::cardroid::data::zerocice::UserTypPtr& usr,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__updateUserData_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__updateUserData_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__updateUserData_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::UserTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_updateUserData(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__updateUserData_name);
	::cardroid::data::zerocice::UserTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::zerocice::CardroidManager::updateCarData(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::cardroid::data::zerocice::UserTypPtr& usr,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__updateCarData_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__updateCarData_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->updateCarData(car, usr, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_updateCarData(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::cardroid::data::zerocice::UserTypPtr& usr,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__updateCarData_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__updateCarData_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__updateCarData_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(car);
		__os->write(usr);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_updateCarData(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__updateCarData_name);
	::cardroid::data::zerocice::CarTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::zerocice::CardroidManager::updateCarDataEmail(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::std::string& usrEmail, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__updateCarDataEmail_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__updateCarDataEmail_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->updateCarDataEmail(car, usrEmail, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_updateCarDataEmail(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::std::string& usrEmail, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__updateCarDataEmail_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__zerocice__CardroidManager__updateCarDataEmail_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__updateCarDataEmail_name,
				::Ice::Idempotent, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(car);
		__os->write(usrEmail);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_updateCarDataEmail(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__updateCarDataEmail_name);
	::cardroid::data::zerocice::CarTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::zerocice::CardroidManager::addCar(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::cardroid::data::zerocice::UserTypPrx& usr,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__addCar_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__addCar_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->addCar(car, usr, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_addCar(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::cardroid::data::zerocice::UserTypPrx& usr,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(__cardroid__zerocice__CardroidManager__addCar_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__addCar_name, __del,
			__cookie);
	try {
		__result->__prepare(__cardroid__zerocice__CardroidManager__addCar_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(car);
		__os->write(usr);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_addCar(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__addCar_name);
	::cardroid::data::zerocice::CarTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::zerocice::CardroidManager::addCarEmail(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::std::string& usrEmail, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__addCarEmail_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__zerocice__CardroidManager__addCarEmail_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			return __del->addCarEmail(car, usrEmail, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_addCarEmail(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::std::string& usrEmail, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__zerocice__CardroidManager__addCarEmail_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__addCarEmail_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__addCarEmail_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(car);
		__os->write(usrEmail);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceProxy::cardroid::zerocice::CardroidManager::end_addCarEmail(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__zerocice__CardroidManager__addCarEmail_name);
	::cardroid::data::zerocice::CarTypPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::zerocice::CardroidManager::removeCar(
		const ::cardroid::data::zerocice::CarTypPrx& car,
		const ::cardroid::data::zerocice::UserTypPrx& usr,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__removeCar_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			__del->removeCar(car, usr, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_removeCar(
		const ::cardroid::data::zerocice::CarTypPrx& car,
		const ::cardroid::data::zerocice::UserTypPrx& usr,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__zerocice__CardroidManager__removeCar_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__removeCar_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(car);
		__os->write(usr);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::zerocice::CardroidManager::end_removeCar(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__zerocice__CardroidManager__removeCar_name);
}

void IceProxy::cardroid::zerocice::CardroidManager::removeCarPlateEmail(
		const ::std::string& plate, const ::std::string& ownerEmail,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__zerocice__CardroidManager__removeCarPlateEmail_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::zerocice::CardroidManager* __del =
					dynamic_cast< ::IceDelegate::cardroid::zerocice::CardroidManager*>(__delBase.get());
			__del->removeCarPlateEmail(plate, ownerEmail, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::zerocice::CardroidManager::begin_removeCarPlateEmail(
		const ::std::string& plate, const ::std::string& ownerEmail,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__zerocice__CardroidManager__removeCarPlateEmail_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__zerocice__CardroidManager__removeCarPlateEmail_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(plate);
		__os->write(ownerEmail);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::zerocice::CardroidManager::end_removeCarPlateEmail(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__zerocice__CardroidManager__removeCarPlateEmail_name);
}

const ::std::string&
IceProxy::cardroid::zerocice::CardroidManager::ice_staticId() {
	return ::cardroid::zerocice::CardroidManager::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::zerocice::CardroidManager::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::zerocice::CardroidManager);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::zerocice::CardroidManager::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::zerocice::CardroidManager);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::zerocice::CardroidManager::__newInstance() const {
	return new CardroidManager;
}

::std::string IceDelegateM::cardroid::data::zerocice::PlaceTyp::getName(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PlaceTyp__getName_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::PlaceTyp::setName(
		const ::std::string& name, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PlaceTyp__setName_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(name);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::LatLngTyp IceDelegateM::cardroid::data::zerocice::PlaceTyp::getCoords(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PlaceTyp__getCoords_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::LatLngTyp __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::PlaceTyp::setCoords(
		const ::cardroid::data::zerocice::LatLngTyp& coords,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PlaceTyp__setCoords_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(coords);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::PlaceTyp::getDescription(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PlaceTyp__getDescription_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::PlaceTyp::setDescription(
		const ::std::string& description, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PlaceTyp__setDescription_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(description);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

bool IceDelegateM::cardroid::data::zerocice::PlaceTyp::hasDescription(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PlaceTyp__hasDescription_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::Blob IceDelegateM::cardroid::data::zerocice::PlaceTyp::getSnapshotBytes(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PlaceTyp__getSnapshotBytes_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::Blob __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::PlaceTyp::setSnapshotBytes(
		const ::cardroid::data::zerocice::Blob& snapshotBytes,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PlaceTyp__setSnapshotBytes_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(snapshotBytes);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

bool IceDelegateM::cardroid::data::zerocice::PlaceTyp::hasSnapshot(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PlaceTyp__hasSnapshot_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::PlaceTyp::toString(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PlaceTyp__toString_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::CarTyp::getBrand(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__getBrand_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::CarTyp::setBrand(
		const ::std::string& brand, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__setBrand_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(brand);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::CarTyp::getModel(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__getModel_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::CarTyp::setModel(
		const ::std::string& model, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__setModel_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(model);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::Fuel IceDelegateM::cardroid::data::zerocice::CarTyp::getCarFuel(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__getCarFuel_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::Fuel __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::CarTyp::setCarFuel(
		::cardroid::data::zerocice::Fuel carFuel,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__setCarFuel_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(carFuel);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::Ice::Double IceDelegateM::cardroid::data::zerocice::CarTyp::getConsumptionPerKm(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__getConsumptionPerKm_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Double __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::CarTyp::setConsumptionPerKm(
		::Ice::Double consumptionPerKm, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__setConsumptionPerKm_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(consumptionPerKm);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::CarTyp::getNSeats(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__getNSeats_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::CarTyp::setNSeats(
		::Ice::Int nSeats, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__setNSeats_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(nSeats);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::CarTyp::getColor(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__getColor_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::CarTyp::setColor(
		const ::std::string& color, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__setColor_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(color);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::CarTyp::getPlate(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__getPlate_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::CarTyp::setPlate(
		const ::std::string& plate, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__setPlate_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(plate);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::CarTyp::toString(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__CarTyp__toString_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::UserTyp::getName(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__getName_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::setName(
		const ::std::string& name, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__setName_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(name);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::UserTyp::getSurname(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__getSurname_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::setSurname(
		const ::std::string& surname, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__setSurname_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(surname);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::Blob IceDelegateM::cardroid::data::zerocice::UserTyp::getAvatarBytes(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__getAvatarBytes_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::Blob __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::setAvatarBytes(
		const ::cardroid::data::zerocice::Blob& avatarBytes,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__setAvatarBytes_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(avatarBytes);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

bool IceDelegateM::cardroid::data::zerocice::UserTyp::hasAvatar(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__hasAvatar_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::PlaceTypPtr IceDelegateM::cardroid::data::zerocice::UserTyp::getUserHome(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__getUserHome_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::PlaceTypPtr __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::setUserHome(
		const ::cardroid::data::zerocice::PlaceTypPtr& home,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__setUserHome_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(home);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::UserTyp::getTelephone(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__getTelephone_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::setTelephone(
		::Ice::Int telephone, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__setTelephone_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(telephone);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::UserTyp::getEmail(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__getEmail_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::setEmail(
		const ::std::string& email, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__setEmail_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(email);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::UserTyp::getReputation(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__getReputation_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::setReputation(
		::Ice::Int reputation, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__setReputation_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(reputation);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

bool IceDelegateM::cardroid::data::zerocice::UserTyp::hasReputation(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__hasReputation_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::CarCollection IceDelegateM::cardroid::data::zerocice::UserTyp::getUserCars(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__getUserCars_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::CarCollection __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::setUserCars(
		const ::cardroid::data::zerocice::CarCollection& cars,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__setUserCars_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(cars);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::UserTyp::toString(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__toString_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::increaseReputation1(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__increaseReputation1_name,
			::Ice::Normal, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::increaseReputation(
		::Ice::Int increase, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__increaseReputation_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(increase);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::decreaseReputation1(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__decreaseReputation1_name,
			::Ice::Normal, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::decreaseReputation(
		::Ice::Int decrease, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__decreaseReputation_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(decrease);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

bool IceDelegateM::cardroid::data::zerocice::UserTyp::addCar(
		const ::cardroid::data::zerocice::CarTypPtr& c,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__addCar_name, ::Ice::Normal,
			__context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(c);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

bool IceDelegateM::cardroid::data::zerocice::UserTyp::removeCar(
		const ::cardroid::data::zerocice::CarTypPtr& c,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__removeCar_name, ::Ice::Normal,
			__context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(c);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::UserTyp::getNCars(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__getNCars_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserTyp::clearCars(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserTyp__clearCars_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::Ice::Long IceDelegateM::cardroid::data::zerocice::DateTyp::getTimeInMillis(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__DateTyp__getTimeInMillis_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Long __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::DateTyp::setTimeInMillis(
		::Ice::Long datetime, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__DateTyp__setTimeInMillis_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(datetime);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::DateTyp::toString(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__DateTyp__toString_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::DateTimePrefsTyp::getToleranceDays(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__DateTimePrefsTyp__getToleranceDays_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::DateTimePrefsTyp::setToleranceDays(
		::Ice::Int toleranceDays, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__DateTimePrefsTyp__setToleranceDays_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(toleranceDays);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::TimePreferences IceDelegateM::cardroid::data::zerocice::DateTimePrefsTyp::getTimePrefs(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__DateTimePrefsTyp__getTimePrefs_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::TimePreferences __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::DateTimePrefsTyp::setTimePrefs(
		::cardroid::data::zerocice::TimePreferences timePrefs,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__DateTimePrefsTyp__setTimePrefs_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(timePrefs);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::TripTyp::getTripId(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__getTripId_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripTyp::setTripId(
		::Ice::Int tripId, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__setTripId_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripId);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::PlaceTypPtr IceDelegateM::cardroid::data::zerocice::TripTyp::getPlace1(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__getPlace1_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::PlaceTypPtr __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripTyp::setPlace1(
		const ::cardroid::data::zerocice::PlaceTypPtr& fromPlace,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__setPlace1_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(fromPlace);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::PlaceTypPtr IceDelegateM::cardroid::data::zerocice::TripTyp::getPlace2(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__getPlace2_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::PlaceTypPtr __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripTyp::setPlace2(
		const ::cardroid::data::zerocice::PlaceTypPtr& toPlace,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__setPlace2_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(toPlace);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::DateTypPtr IceDelegateM::cardroid::data::zerocice::TripTyp::getTripDate(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__getTripDate_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::DateTypPtr __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripTyp::setTripDate(
		const ::cardroid::data::zerocice::DateTypPtr& tripDate,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__setTripDate_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripDate);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::TripTyp::getNSeats(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__getNSeats_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripTyp::setNSeats(
		::Ice::Int nSeats, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__setNSeats_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(nSeats);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::DateTypPtr IceDelegateM::cardroid::data::zerocice::TripTyp::getTripReturnDate(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__getTripReturnDate_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::DateTypPtr __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripTyp::setTripReturnDate(
		const ::cardroid::data::zerocice::DateTypPtr& tripReturnDate,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__setTripReturnDate_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripReturnDate);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

bool IceDelegateM::cardroid::data::zerocice::TripTyp::hasTripReturnDate(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__hasTripReturnDate_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::WeekdaysV IceDelegateM::cardroid::data::zerocice::TripTyp::getTripWeekDays(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__getTripWeekDays_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::WeekdaysV __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::Periodicity IceDelegateM::cardroid::data::zerocice::TripTyp::getTripPeriodicity(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__getTripPeriodicity_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::Periodicity __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripTyp::setTripWeekDaysPeriodicity(
		const ::cardroid::data::zerocice::WeekdaysV& tripWeekDays,
		::cardroid::data::zerocice::Periodicity tripPeriodicity,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__setTripWeekDaysPeriodicity_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripWeekDays);
		__os->write(tripPeriodicity);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

bool IceDelegateM::cardroid::data::zerocice::TripTyp::hasWeekDaysPeriodicity(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__hasWeekDaysPeriodicity_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::TripTyp::getDistance(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__getDistance_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripTyp::setDistance(
		::Ice::Int distance, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__setDistance_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(distance);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

bool IceDelegateM::cardroid::data::zerocice::TripTyp::hasDistance(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__hasDistance_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::TripTyp::getCharacteristics(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__getCharacteristics_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripTyp::setCharacteristics(
		const ::std::string& characteristics, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__setCharacteristics_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(characteristics);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

bool IceDelegateM::cardroid::data::zerocice::TripTyp::hasCharacteristics(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__hasCharacteristics_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripTyp::setTripType(
		::Ice::Int type, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__setTripType_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(type);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::TripTyp::getTripType(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__getTripType_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::TripTyp::toString(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripTyp__toString_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::WaypointTyp::getNOrder(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__WaypointTyp__getNOrder_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::WaypointTyp::setNOrder(
		::Ice::Int nOrder, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__WaypointTyp__setNOrder_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(nOrder);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::PlaceTypPtr IceDelegateM::cardroid::data::zerocice::WaypointTyp::getWaypointPlace(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__WaypointTyp__getWaypointPlace_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::PlaceTypPtr __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::WaypointTyp::setWaypointPlace(
		const ::cardroid::data::zerocice::PlaceTypPtr& waypointPlace,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__WaypointTyp__setWaypointPlace_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(waypointPlace);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::WaypointTyp::toString(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__WaypointTyp__toString_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateM::cardroid::data::zerocice::PassengerTyp::getPassengerUser(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PassengerTyp__getPassengerUser_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::UserTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::PassengerTyp::setPassengerUser(
		const ::cardroid::data::zerocice::UserTypPrx& passengerUser,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PassengerTyp__setPassengerUser_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(passengerUser);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::PassengerTyp::getNSeats(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PassengerTyp__getNSeats_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::PassengerTyp::setNSeats(
		::Ice::Int nSeats, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PassengerTyp__setNSeats_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(nSeats);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::PassengerTyp::toString(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__PassengerTyp__toString_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::DateTimeTypPtr IceDelegateM::cardroid::data::zerocice::TripOfferTyp::getTripDateTime(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__getTripDateTime_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::DateTimeTypPtr __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripOfferTyp::setTripDateTime(
		const ::cardroid::data::zerocice::DateTimeTypPtr& dt,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__setTripDateTime_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(dt);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::DateTimeTypPtr IceDelegateM::cardroid::data::zerocice::TripOfferTyp::getTripReturnDateTime(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__getTripReturnDateTime_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::DateTimeTypPtr __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripOfferTyp::setTripReturnDateTime(
		const ::cardroid::data::zerocice::DateTimeTypPtr& rdt,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__setTripReturnDateTime_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(rdt);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateM::cardroid::data::zerocice::TripOfferTyp::getTripDriver(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__getTripDriver_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::UserTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripOfferTyp::setTripDriver(
		const ::cardroid::data::zerocice::UserTypPrx& driver,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__setTripDriver_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(driver);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::WaypointCollection IceDelegateM::cardroid::data::zerocice::TripOfferTyp::getTripWaypoints(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__getTripWaypoints_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::WaypointCollection __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripOfferTyp::setTripWaypoints(
		const ::cardroid::data::zerocice::WaypointCollection& waypoints,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__setTripWaypoints_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(waypoints);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::CarTypPrx IceDelegateM::cardroid::data::zerocice::TripOfferTyp::getTripCar(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__getTripCar_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::CarTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripOfferTyp::setTripCar(
		const ::cardroid::data::zerocice::CarTypPrx& tripCar,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__setTripCar_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripCar);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::PassengerCollection IceDelegateM::cardroid::data::zerocice::TripOfferTyp::getTripPassengers(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__getTripPassengers_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::PassengerCollection __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripOfferTyp::setTripPassengers(
		const ::cardroid::data::zerocice::PassengerCollection& passengers,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__setTripPassengers_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(passengers);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::Ice::Double IceDelegateM::cardroid::data::zerocice::TripOfferTyp::getPrice(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__getPrice_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Double __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripOfferTyp::setPrice(
		::Ice::Double price, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__setPrice_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(price);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::AllowedV IceDelegateM::cardroid::data::zerocice::TripOfferTyp::getAllowedFeatures(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__getAllowedFeatures_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::AllowedV __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripOfferTyp::setAllowedFeatures(
		const ::cardroid::data::zerocice::AllowedV& allowed,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__setAllowedFeatures_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(allowed);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

bool IceDelegateM::cardroid::data::zerocice::TripOfferTyp::addTripWaypoint(
		const ::cardroid::data::zerocice::PlaceTypPtr& waypoint,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__addTripWaypoint_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(waypoint);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

bool IceDelegateM::cardroid::data::zerocice::TripOfferTyp::removeTripWaypoint(
		::Ice::Int pos, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__removeTripWaypoint_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(pos);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::TripOfferTyp::getNTripWaypoints(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__getNTripWaypoints_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripOfferTyp::clearTripWaypoints(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__clearTripWaypoints_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

bool IceDelegateM::cardroid::data::zerocice::TripOfferTyp::addTripPassenger(
		const ::cardroid::data::zerocice::UserTypPrx& passenger,
		::Ice::Int seats, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__addTripPassenger_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(passenger);
		__os->write(seats);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

bool IceDelegateM::cardroid::data::zerocice::TripOfferTyp::removeTripPassenger(
		const ::cardroid::data::zerocice::UserTypPrx& passenger,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__removeTripPassenger_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(passenger);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::Ice::Int IceDelegateM::cardroid::data::zerocice::TripOfferTyp::getNTripPassengers(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__getNTripPassengers_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Int __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripOfferTyp::clearTripPassengers(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripOfferTyp__clearTripPassengers_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::DateTimePrefsTypPtr IceDelegateM::cardroid::data::zerocice::TripRequestTyp::getTripDateTimePrefs(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripRequestTyp__getTripDateTimePrefs_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::DateTimePrefsTypPtr __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripRequestTyp::setTripDateTimePrefs(
		const ::cardroid::data::zerocice::DateTimePrefsTypPtr& dtp,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripRequestTyp__setTripDateTimePrefs_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(dtp);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::DateTimePrefsTypPtr IceDelegateM::cardroid::data::zerocice::TripRequestTyp::getTripReturnDateTimePrefs(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripRequestTyp__getTripReturnDateTimePrefs_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::DateTimePrefsTypPtr __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__is->readPendingObjects();
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripRequestTyp::setTripReturnDateTimePrefs(
		const ::cardroid::data::zerocice::DateTimePrefsTypPtr& rdtp,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripRequestTyp__setTripReturnDateTimePrefs_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(rdtp);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateM::cardroid::data::zerocice::TripRequestTyp::getTripRequester(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripRequestTyp__getTripRequester_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::UserTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::TripRequestTyp::setTripRequester(
		const ::cardroid::data::zerocice::UserTypPrx& requester,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__TripRequestTyp__setTripRequester_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(requester);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateM::cardroid::data::zerocice::UserActivityTyp::getActivityUser(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserActivityTyp__getActivityUser_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::UserTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserActivityTyp::setActivityUser(
		const ::cardroid::data::zerocice::UserTypPrx& activityUser,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserActivityTyp__setActivityUser_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(activityUser);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::TripOfferTypPrx IceDelegateM::cardroid::data::zerocice::UserActivityTyp::getActivityTrip(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserActivityTyp__getActivityTrip_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::TripOfferTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserActivityTyp::setActivityTrip(
		const ::cardroid::data::zerocice::TripOfferTypPrx& activityTrip,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserActivityTyp__setActivityTrip_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(activityTrip);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::ActivityType IceDelegateM::cardroid::data::zerocice::UserActivityTyp::getUserActivityType(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserActivityTyp__getUserActivityType_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::ActivityType __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserActivityTyp::setUserActivityType(
		::cardroid::data::zerocice::ActivityType userActivityType,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserActivityTyp__setUserActivityType_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(userActivityType);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::Ice::Long IceDelegateM::cardroid::data::zerocice::UserActivityTyp::getTimeStampInMillis(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserActivityTyp__getTimeStampInMillis_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Long __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::UserActivityTyp::setTimeStampInMillis(
		::Ice::Long timeStampMillis, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserActivityTyp__setTimeStampInMillis_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(timeStampMillis);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::UserActivityTyp::toString(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__UserActivityTyp__toString_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateM::cardroid::data::zerocice::MessageTyp::getUser1(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__MessageTyp__getUser1_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::UserTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::MessageTyp::setUser1(
		const ::cardroid::data::zerocice::UserTypPrx& user1,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__MessageTyp__setUser1_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(user1);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateM::cardroid::data::zerocice::MessageTyp::getUser2(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__MessageTyp__getUser2_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::UserTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::MessageTyp::setUser2(
		const ::cardroid::data::zerocice::UserTypPrx& user2,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__MessageTyp__setUser2_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(user2);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::MessageTyp::getMessageText(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__MessageTyp__getMessageText_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::MessageTyp::setMessageText(
		const ::std::string& msg, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__MessageTyp__setMessageText_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(msg);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::Ice::Long IceDelegateM::cardroid::data::zerocice::MessageTyp::getTimeStampInMillis(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__MessageTyp__getTimeStampInMillis_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Long __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::data::zerocice::MessageTyp::setTimeStampInMillis(
		::Ice::Long timeStampMillis, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__MessageTyp__setTimeStampInMillis_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(timeStampMillis);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateM::cardroid::data::zerocice::MessageTyp::toString(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__data__zerocice__MessageTyp__toString_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::std::string __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::ResultSeq IceDelegateM::cardroid::QueryResult::next(::Ice::Int n,
		bool& destroyed, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__QueryResult__next_name, ::Ice::Normal, __context,
			__observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(n);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::ResultSeq __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(destroyed);
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::QueryResult::destroy(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__QueryResult__destroy_name, ::Ice::Normal, __context,
			__observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

void IceDelegateM::cardroid::zerocice::CardroidManager::getUserPlaces(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__getUserPlaces_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr);
		__os->write(n);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__og.endReadParams();
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::zerocice::CardroidManager::searchTrips(
		const ::cardroid::data::zerocice::TripRequestTypPtr& tRequest,
		::Ice::Int n, ::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__searchTrips_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tRequest);
		__os->write(n);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__og.endReadParams();
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::TripTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::getTripFromId(
		::Ice::Int tripId, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__getTripFromId_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripId);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::TripTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::TripOfferTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::getTripOfferFromId(
		::Ice::Int tripId, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__getTripOfferFromId_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripId);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::TripOfferTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::TripRequestTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::getTripRequestFromId(
		::Ice::Int tripId, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__getTripRequestFromId_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripId);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::TripRequestTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::zerocice::CardroidManager::joinTrip(
		const ::cardroid::data::zerocice::TripOfferTypPrx& trip,
		const ::cardroid::data::zerocice::UserTypPrx& passenger,
		::Ice::Int nSeats, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__joinTrip_name, ::Ice::Normal,
			__context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(trip);
		__os->write(passenger);
		__os->write(nSeats);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::data::zerocice::TripOfferTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::organizeTrip(
		const ::cardroid::data::zerocice::TripRequestTypPrx& tripRequest,
		const ::cardroid::data::zerocice::TripOfferTypPtr& tripOffer,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__organizeTrip_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tripRequest);
		__os->write(tripOffer);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::TripOfferTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::zerocice::CardroidManager::getUserTrips(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__getUserTrips_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr);
		__os->write(n);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__og.endReadParams();
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::zerocice::CardroidManager::getPassengerTrips(
		const ::cardroid::data::zerocice::UserTypPrx& passenger, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__getPassengerTrips_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(passenger);
		__os->write(n);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__og.endReadParams();
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

bool IceDelegateM::cardroid::zerocice::CardroidManager::userTripRegistered(
		const ::cardroid::data::zerocice::UserTypPrx& usr,
		const ::cardroid::data::zerocice::TripTypPrx& trip,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__userTripRegistered_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr);
		__os->write(trip);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::Ice::Double IceDelegateM::cardroid::zerocice::CardroidManager::calculatePriceEstimation(
		::cardroid::data::zerocice::Fuel f, ::Ice::Int distance,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__calculatePriceEstimation_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(f);
		__os->write(distance);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::Ice::Double __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::TripOfferTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::newTripOffer(
		const ::cardroid::data::zerocice::TripOfferTypPtr& tOffer,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__newTripOffer_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tOffer);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::TripOfferTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::TripRequestTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::newTripRequest(
		const ::cardroid::data::zerocice::TripRequestTypPtr& tRequest,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__newTripRequest_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(tRequest);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::TripRequestTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::zerocice::CardroidManager::getMessageTalksSpeakers(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__getMessageTalksSpeakers_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr);
		__os->write(n);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__og.endReadParams();
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::zerocice::CardroidManager::getMessageTalks(
		const ::cardroid::data::zerocice::UserTypPrx& usr1,
		const ::cardroid::data::zerocice::UserTypPrx& usr2, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__getMessageTalks_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr1);
		__os->write(usr2);
		__os->write(n);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__og.endReadParams();
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::MessageTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::newMessage(
		const ::cardroid::data::zerocice::UserTypPrx& usr1,
		const ::cardroid::data::zerocice::UserTypPrx& usr2,
		const ::std::string& message, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__newMessage_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr1);
		__os->write(usr2);
		__os->write(message);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::MessageTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::zerocice::CardroidManager::getUserActivity(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__getUserActivity_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr);
		__os->write(n);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(first);
		__is->read(nrows);
		__is->read(result);
		__og.endReadParams();
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::getUserFromEmail(
		const ::std::string& email, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__getUserFromEmail_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(email);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::UserTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::CarTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::getCarFromPlate(
		const ::std::string& plate,
		const ::cardroid::data::zerocice::UserTypPrx& owner,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__getCarFromPlate_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(plate);
		__os->write(owner);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::CarTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::CarTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::getCarFromPlateEmail(
		const ::std::string& plate, const ::std::string& ownerEmail,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__getCarFromPlateEmail_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(plate);
		__os->write(ownerEmail);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::CarTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::updateUserData(
		const ::cardroid::data::zerocice::UserTypPtr& usr,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__updateUserData_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(usr);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::UserTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::CarTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::updateCarData(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::cardroid::data::zerocice::UserTypPtr& usr,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__updateCarData_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(car);
		__os->write(usr);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::CarTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::CarTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::updateCarDataEmail(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::std::string& usrEmail, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__updateCarDataEmail_name,
			::Ice::Idempotent, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(car);
		__os->write(usrEmail);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::CarTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::CarTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::addCar(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::cardroid::data::zerocice::UserTypPrx& usr,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__addCar_name, ::Ice::Normal,
			__context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(car);
		__os->write(usr);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::CarTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::cardroid::data::zerocice::CarTypPrx IceDelegateM::cardroid::zerocice::CardroidManager::addCarEmail(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::std::string& usrEmail, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__addCarEmail_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(car);
		__os->write(usrEmail);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	::cardroid::data::zerocice::CarTypPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::zerocice::CardroidManager::removeCar(
		const ::cardroid::data::zerocice::CarTypPrx& car,
		const ::cardroid::data::zerocice::UserTypPrx& usr,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__removeCar_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(car);
		__os->write(usr);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

void IceDelegateM::cardroid::zerocice::CardroidManager::removeCarPlateEmail(
		const ::std::string& plate, const ::std::string& ownerEmail,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__zerocice__CardroidManager__removeCarPlateEmail_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(plate);
		__os->write(ownerEmail);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::PlaceTyp::getName(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PlaceTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PlaceTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getName(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__PlaceTyp__getName_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::PlaceTyp::setName(
		const ::std::string& name, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::std::string& __p_name, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_name(__p_name) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PlaceTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PlaceTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setName(_m_name, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::std::string& _m_name;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__PlaceTyp__setName_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(name, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::LatLngTyp IceDelegateD::cardroid::data::zerocice::PlaceTyp::getCoords(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::LatLngTyp& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PlaceTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PlaceTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getCoords(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::LatLngTyp& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PlaceTyp__getCoords_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::LatLngTyp __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::PlaceTyp::setCoords(
		const ::cardroid::data::zerocice::LatLngTyp& coords,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::LatLngTyp& __p_coords,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_coords(__p_coords) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PlaceTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PlaceTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setCoords(_m_coords, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::LatLngTyp& _m_coords;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PlaceTyp__setCoords_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(coords, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::PlaceTyp::getDescription(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PlaceTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PlaceTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getDescription(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PlaceTyp__getDescription_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::PlaceTyp::setDescription(
		const ::std::string& description, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::std::string& __p_description,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_description(
						__p_description) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PlaceTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PlaceTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setDescription(_m_description, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::std::string& _m_description;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PlaceTyp__setDescription_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(description, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

bool IceDelegateD::cardroid::data::zerocice::PlaceTyp::hasDescription(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PlaceTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PlaceTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->hasDescription(_current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PlaceTyp__hasDescription_name,
			::Ice::Idempotent, __context);
	bool __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::Blob IceDelegateD::cardroid::data::zerocice::PlaceTyp::getSnapshotBytes(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::Blob& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PlaceTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PlaceTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getSnapshotBytes(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::Blob& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PlaceTyp__getSnapshotBytes_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::Blob __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::PlaceTyp::setSnapshotBytes(
		const ::cardroid::data::zerocice::Blob& snapshotBytes,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::Blob& __p_snapshotBytes,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_snapshotBytes(
						__p_snapshotBytes) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PlaceTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PlaceTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setSnapshotBytes(_m_snapshotBytes, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::Blob& _m_snapshotBytes;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PlaceTyp__setSnapshotBytes_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(snapshotBytes, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

bool IceDelegateD::cardroid::data::zerocice::PlaceTyp::hasSnapshot(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PlaceTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PlaceTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->hasSnapshot(_current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PlaceTyp__hasSnapshot_name,
			::Ice::Idempotent, __context);
	bool __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::std::string IceDelegateD::cardroid::data::zerocice::PlaceTyp::toString(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PlaceTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PlaceTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->toString(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PlaceTyp__toString_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::std::string IceDelegateD::cardroid::data::zerocice::CarTyp::getBrand(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getBrand(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__CarTyp__getBrand_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::CarTyp::setBrand(
		const ::std::string& brand, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::std::string& __p_brand,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_brand(__p_brand) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setBrand(_m_brand, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::std::string& _m_brand;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__CarTyp__setBrand_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(brand, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::CarTyp::getModel(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getModel(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__CarTyp__getModel_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::CarTyp::setModel(
		const ::std::string& model, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::std::string& __p_model,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_model(__p_model) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setModel(_m_model, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::std::string& _m_model;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__CarTyp__setModel_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(model, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::Fuel IceDelegateD::cardroid::data::zerocice::CarTyp::getCarFuel(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::Fuel& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getCarFuel(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::Fuel& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__CarTyp__getCarFuel_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::Fuel __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::CarTyp::setCarFuel(
		::cardroid::data::zerocice::Fuel carFuel,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::Fuel __p_carFuel,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_carFuel(__p_carFuel) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setCarFuel(_m_carFuel, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::Fuel _m_carFuel;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__CarTyp__setCarFuel_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(carFuel, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Double IceDelegateD::cardroid::data::zerocice::CarTyp::getConsumptionPerKm(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Double& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getConsumptionPerKm(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Double& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__CarTyp__getConsumptionPerKm_name,
			::Ice::Idempotent, __context);
	::Ice::Double __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::CarTyp::setConsumptionPerKm(
		::Ice::Double consumptionPerKm, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Double __p_consumptionPerKm,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_consumptionPerKm(
						__p_consumptionPerKm) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setConsumptionPerKm(_m_consumptionPerKm, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Double _m_consumptionPerKm;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__CarTyp__setConsumptionPerKm_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(consumptionPerKm, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::CarTyp::getNSeats(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getNSeats(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__CarTyp__getNSeats_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::CarTyp::setNSeats(
		::Ice::Int nSeats, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int __p_nSeats, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_nSeats(__p_nSeats) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setNSeats(_m_nSeats, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int _m_nSeats;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__CarTyp__setNSeats_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(nSeats, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::CarTyp::getColor(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getColor(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__CarTyp__getColor_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::CarTyp::setColor(
		const ::std::string& color, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::std::string& __p_color,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_color(__p_color) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setColor(_m_color, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::std::string& _m_color;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__CarTyp__setColor_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(color, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::CarTyp::getPlate(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getPlate(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__CarTyp__getPlate_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::CarTyp::setPlate(
		const ::std::string& plate, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::std::string& __p_plate,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_plate(__p_plate) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setPlate(_m_plate, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::std::string& _m_plate;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__CarTyp__setPlate_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(plate, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::CarTyp::toString(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::CarTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::CarTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->toString(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__CarTyp__toString_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::std::string IceDelegateD::cardroid::data::zerocice::UserTyp::getName(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getName(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__UserTyp__getName_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::setName(
		const ::std::string& name, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::std::string& __p_name, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_name(__p_name) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setName(_m_name, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::std::string& _m_name;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__UserTyp__setName_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(name, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::UserTyp::getSurname(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getSurname(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__getSurname_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::setSurname(
		const ::std::string& surname, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::std::string& __p_surname,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_surname(__p_surname) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setSurname(_m_surname, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::std::string& _m_surname;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__setSurname_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(surname, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::Blob IceDelegateD::cardroid::data::zerocice::UserTyp::getAvatarBytes(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::Blob& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getAvatarBytes(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::Blob& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__getAvatarBytes_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::Blob __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::setAvatarBytes(
		const ::cardroid::data::zerocice::Blob& avatarBytes,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::Blob& __p_avatarBytes,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_avatarBytes(
						__p_avatarBytes) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setAvatarBytes(_m_avatarBytes, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::Blob& _m_avatarBytes;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__setAvatarBytes_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(avatarBytes, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

bool IceDelegateD::cardroid::data::zerocice::UserTyp::hasAvatar(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->hasAvatar(_current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__hasAvatar_name,
			::Ice::Idempotent, __context);
	bool __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::PlaceTypPtr IceDelegateD::cardroid::data::zerocice::UserTyp::getUserHome(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::PlaceTypPtr& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getUserHome(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::PlaceTypPtr& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__getUserHome_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::PlaceTypPtr __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::setUserHome(
		const ::cardroid::data::zerocice::PlaceTypPtr& home,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::PlaceTypPtr& __p_home,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_home(__p_home) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setUserHome(_m_home, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::PlaceTypPtr& _m_home;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__setUserHome_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(home, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::UserTyp::getTelephone(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTelephone(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__getTelephone_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::setTelephone(
		::Ice::Int telephone, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int __p_telephone, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_telephone(__p_telephone) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTelephone(_m_telephone, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int _m_telephone;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__setTelephone_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(telephone, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::UserTyp::getEmail(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getEmail(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__UserTyp__getEmail_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::setEmail(
		const ::std::string& email, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::std::string& __p_email,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_email(__p_email) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setEmail(_m_email, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::std::string& _m_email;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__UserTyp__setEmail_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(email, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::UserTyp::getReputation(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getReputation(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__getReputation_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::setReputation(
		::Ice::Int reputation, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int __p_reputation, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_reputation(__p_reputation) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setReputation(_m_reputation, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int _m_reputation;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__setReputation_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(reputation, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

bool IceDelegateD::cardroid::data::zerocice::UserTyp::hasReputation(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->hasReputation(_current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__hasReputation_name,
			::Ice::Idempotent, __context);
	bool __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::CarCollection IceDelegateD::cardroid::data::zerocice::UserTyp::getUserCars(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::CarCollection& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getUserCars(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::CarCollection& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__getUserCars_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::CarCollection __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::setUserCars(
		const ::cardroid::data::zerocice::CarCollection& cars,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::CarCollection& __p_cars,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_cars(__p_cars) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setUserCars(_m_cars, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::CarCollection& _m_cars;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__setUserCars_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(cars, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::UserTyp::toString(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->toString(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__UserTyp__toString_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::increaseReputation1(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::Ice::Current& __current) :
				::IceInternal::Direct(__current) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->increaseReputation1(_current);
			return ::Ice::DispatchOK;
		}

	private:

	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__increaseReputation1_name,
			::Ice::Normal, __context);
	try {
		_DirectI __direct(__current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::increaseReputation(
		::Ice::Int increase, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int __p_increase, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_increase(__p_increase) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->increaseReputation(_m_increase, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int _m_increase;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__increaseReputation_name,
			::Ice::Normal, __context);
	try {
		_DirectI __direct(increase, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::decreaseReputation1(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::Ice::Current& __current) :
				::IceInternal::Direct(__current) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->decreaseReputation1(_current);
			return ::Ice::DispatchOK;
		}

	private:

	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__decreaseReputation1_name,
			::Ice::Normal, __context);
	try {
		_DirectI __direct(__current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::decreaseReputation(
		::Ice::Int decrease, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int __p_decrease, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_decrease(__p_decrease) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->decreaseReputation(_m_decrease, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int _m_decrease;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__decreaseReputation_name,
			::Ice::Normal, __context);
	try {
		_DirectI __direct(decrease, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

bool IceDelegateD::cardroid::data::zerocice::UserTyp::addCar(
		const ::cardroid::data::zerocice::CarTypPtr& c,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result,
				const ::cardroid::data::zerocice::CarTypPtr& __p_c,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_c(__p_c) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->addCar(_m_c, _current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
		const ::cardroid::data::zerocice::CarTypPtr& _m_c;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__UserTyp__addCar_name,
			::Ice::Normal, __context);
	bool __result;
	try {
		_DirectI __direct(__result, c, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

bool IceDelegateD::cardroid::data::zerocice::UserTyp::removeCar(
		const ::cardroid::data::zerocice::CarTypPtr& c,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result,
				const ::cardroid::data::zerocice::CarTypPtr& __p_c,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_c(__p_c) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->removeCar(_m_c, _current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
		const ::cardroid::data::zerocice::CarTypPtr& _m_c;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__removeCar_name, ::Ice::Normal,
			__context);
	bool __result;
	try {
		_DirectI __direct(__result, c, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::UserTyp::getNCars(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getNCars(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__UserTyp__getNCars_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserTyp::clearCars(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::Ice::Current& __current) :
				::IceInternal::Direct(__current) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->clearCars(_current);
			return ::Ice::DispatchOK;
		}

	private:

	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserTyp__clearCars_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(__current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Long IceDelegateD::cardroid::data::zerocice::DateTyp::getTimeInMillis(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Long& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::DateTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::DateTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTimeInMillis(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Long& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__DateTyp__getTimeInMillis_name,
			::Ice::Idempotent, __context);
	::Ice::Long __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::DateTyp::setTimeInMillis(
		::Ice::Long datetime, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Long __p_datetime, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_datetime(__p_datetime) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::DateTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::DateTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTimeInMillis(_m_datetime, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Long _m_datetime;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__DateTyp__setTimeInMillis_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(datetime, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::DateTyp::toString(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::DateTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::DateTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->toString(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__DateTyp__toString_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::DateTimePrefsTyp::getToleranceDays(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::DateTimePrefsTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::DateTimePrefsTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getToleranceDays(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__DateTimePrefsTyp__getToleranceDays_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::DateTimePrefsTyp::setToleranceDays(
		::Ice::Int toleranceDays, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int __p_toleranceDays, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_toleranceDays(
						__p_toleranceDays) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::DateTimePrefsTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::DateTimePrefsTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setToleranceDays(_m_toleranceDays, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int _m_toleranceDays;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__DateTimePrefsTyp__setToleranceDays_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(toleranceDays, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::TimePreferences IceDelegateD::cardroid::data::zerocice::DateTimePrefsTyp::getTimePrefs(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::TimePreferences& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::DateTimePrefsTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::DateTimePrefsTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTimePrefs(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::TimePreferences& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__DateTimePrefsTyp__getTimePrefs_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::TimePreferences __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::DateTimePrefsTyp::setTimePrefs(
		::cardroid::data::zerocice::TimePreferences timePrefs,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::TimePreferences __p_timePrefs,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_timePrefs(__p_timePrefs) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::DateTimePrefsTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::DateTimePrefsTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTimePrefs(_m_timePrefs, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::TimePreferences _m_timePrefs;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__DateTimePrefsTyp__setTimePrefs_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(timePrefs, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::TripTyp::getTripId(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripId(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__getTripId_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripTyp::setTripId(
		::Ice::Int tripId, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int __p_tripId, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_tripId(__p_tripId) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripId(_m_tripId, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int _m_tripId;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__setTripId_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(tripId, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::PlaceTypPtr IceDelegateD::cardroid::data::zerocice::TripTyp::getPlace1(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::PlaceTypPtr& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getPlace1(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::PlaceTypPtr& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__getPlace1_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::PlaceTypPtr __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripTyp::setPlace1(
		const ::cardroid::data::zerocice::PlaceTypPtr& fromPlace,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::PlaceTypPtr& __p_fromPlace,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_fromPlace(__p_fromPlace) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setPlace1(_m_fromPlace, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::PlaceTypPtr& _m_fromPlace;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__setPlace1_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(fromPlace, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::PlaceTypPtr IceDelegateD::cardroid::data::zerocice::TripTyp::getPlace2(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::PlaceTypPtr& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getPlace2(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::PlaceTypPtr& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__getPlace2_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::PlaceTypPtr __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripTyp::setPlace2(
		const ::cardroid::data::zerocice::PlaceTypPtr& toPlace,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::PlaceTypPtr& __p_toPlace,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_toPlace(__p_toPlace) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setPlace2(_m_toPlace, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::PlaceTypPtr& _m_toPlace;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__setPlace2_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(toPlace, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::DateTypPtr IceDelegateD::cardroid::data::zerocice::TripTyp::getTripDate(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::DateTypPtr& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripDate(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::DateTypPtr& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__getTripDate_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::DateTypPtr __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripTyp::setTripDate(
		const ::cardroid::data::zerocice::DateTypPtr& tripDate,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::DateTypPtr& __p_tripDate,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_tripDate(__p_tripDate) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripDate(_m_tripDate, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::DateTypPtr& _m_tripDate;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__setTripDate_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(tripDate, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::TripTyp::getNSeats(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getNSeats(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__getNSeats_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripTyp::setNSeats(
		::Ice::Int nSeats, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int __p_nSeats, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_nSeats(__p_nSeats) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setNSeats(_m_nSeats, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int _m_nSeats;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__setNSeats_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(nSeats, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::DateTypPtr IceDelegateD::cardroid::data::zerocice::TripTyp::getTripReturnDate(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::DateTypPtr& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripReturnDate(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::DateTypPtr& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__getTripReturnDate_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::DateTypPtr __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripTyp::setTripReturnDate(
		const ::cardroid::data::zerocice::DateTypPtr& tripReturnDate,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(
				const ::cardroid::data::zerocice::DateTypPtr& __p_tripReturnDate,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_tripReturnDate(
						__p_tripReturnDate) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripReturnDate(_m_tripReturnDate, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::DateTypPtr& _m_tripReturnDate;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__setTripReturnDate_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(tripReturnDate, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

bool IceDelegateD::cardroid::data::zerocice::TripTyp::hasTripReturnDate(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->hasTripReturnDate(_current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__hasTripReturnDate_name,
			::Ice::Idempotent, __context);
	bool __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::WeekdaysV IceDelegateD::cardroid::data::zerocice::TripTyp::getTripWeekDays(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::WeekdaysV& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripWeekDays(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::WeekdaysV& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__getTripWeekDays_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::WeekdaysV __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::Periodicity IceDelegateD::cardroid::data::zerocice::TripTyp::getTripPeriodicity(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::Periodicity& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripPeriodicity(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::Periodicity& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__getTripPeriodicity_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::Periodicity __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripTyp::setTripWeekDaysPeriodicity(
		const ::cardroid::data::zerocice::WeekdaysV& tripWeekDays,
		::cardroid::data::zerocice::Periodicity tripPeriodicity,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::WeekdaysV& __p_tripWeekDays,
				::cardroid::data::zerocice::Periodicity __p_tripPeriodicity,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_tripWeekDays(
						__p_tripWeekDays), _m_tripPeriodicity(
						__p_tripPeriodicity) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripWeekDaysPeriodicity(_m_tripWeekDays,
					_m_tripPeriodicity, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::WeekdaysV& _m_tripWeekDays;
		::cardroid::data::zerocice::Periodicity _m_tripPeriodicity;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__setTripWeekDaysPeriodicity_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(tripWeekDays, tripPeriodicity, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

bool IceDelegateD::cardroid::data::zerocice::TripTyp::hasWeekDaysPeriodicity(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->hasWeekDaysPeriodicity(_current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__hasWeekDaysPeriodicity_name,
			::Ice::Idempotent, __context);
	bool __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::TripTyp::getDistance(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getDistance(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__getDistance_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripTyp::setDistance(
		::Ice::Int distance, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int __p_distance, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_distance(__p_distance) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setDistance(_m_distance, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int _m_distance;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__setDistance_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(distance, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

bool IceDelegateD::cardroid::data::zerocice::TripTyp::hasDistance(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->hasDistance(_current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__hasDistance_name,
			::Ice::Idempotent, __context);
	bool __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::std::string IceDelegateD::cardroid::data::zerocice::TripTyp::getCharacteristics(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getCharacteristics(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__getCharacteristics_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripTyp::setCharacteristics(
		const ::std::string& characteristics, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::std::string& __p_characteristics,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_characteristics(
						__p_characteristics) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setCharacteristics(_m_characteristics, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::std::string& _m_characteristics;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__setCharacteristics_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(characteristics, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

bool IceDelegateD::cardroid::data::zerocice::TripTyp::hasCharacteristics(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->hasCharacteristics(_current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__hasCharacteristics_name,
			::Ice::Idempotent, __context);
	bool __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripTyp::setTripType(
		::Ice::Int type, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int __p_type, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_type(__p_type) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripType(_m_type, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int _m_type;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__setTripType_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(type, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::TripTyp::getTripType(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripType(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripTyp__getTripType_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::std::string IceDelegateD::cardroid::data::zerocice::TripTyp::toString(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->toString(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__data__zerocice__TripTyp__toString_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::WaypointTyp::getNOrder(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::WaypointTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::WaypointTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getNOrder(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__WaypointTyp__getNOrder_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::WaypointTyp::setNOrder(
		::Ice::Int nOrder, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int __p_nOrder, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_nOrder(__p_nOrder) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::WaypointTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::WaypointTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setNOrder(_m_nOrder, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int _m_nOrder;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__WaypointTyp__setNOrder_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(nOrder, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::PlaceTypPtr IceDelegateD::cardroid::data::zerocice::WaypointTyp::getWaypointPlace(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::PlaceTypPtr& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::WaypointTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::WaypointTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getWaypointPlace(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::PlaceTypPtr& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__WaypointTyp__getWaypointPlace_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::PlaceTypPtr __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::WaypointTyp::setWaypointPlace(
		const ::cardroid::data::zerocice::PlaceTypPtr& waypointPlace,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(
				const ::cardroid::data::zerocice::PlaceTypPtr& __p_waypointPlace,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_waypointPlace(
						__p_waypointPlace) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::WaypointTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::WaypointTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setWaypointPlace(_m_waypointPlace, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::PlaceTypPtr& _m_waypointPlace;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__WaypointTyp__setWaypointPlace_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(waypointPlace, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::WaypointTyp::toString(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::WaypointTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::WaypointTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->toString(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__WaypointTyp__toString_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::UserTypPrx IceDelegateD::cardroid::data::zerocice::PassengerTyp::getPassengerUser(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::UserTypPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PassengerTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PassengerTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getPassengerUser(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::UserTypPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PassengerTyp__getPassengerUser_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::UserTypPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::PassengerTyp::setPassengerUser(
		const ::cardroid::data::zerocice::UserTypPrx& passengerUser,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(
				const ::cardroid::data::zerocice::UserTypPrx& __p_passengerUser,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_passengerUser(
						__p_passengerUser) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PassengerTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PassengerTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setPassengerUser(_m_passengerUser, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserTypPrx& _m_passengerUser;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PassengerTyp__setPassengerUser_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(passengerUser, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::PassengerTyp::getNSeats(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PassengerTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PassengerTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getNSeats(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PassengerTyp__getNSeats_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::PassengerTyp::setNSeats(
		::Ice::Int nSeats, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int __p_nSeats, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_nSeats(__p_nSeats) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PassengerTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PassengerTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setNSeats(_m_nSeats, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int _m_nSeats;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PassengerTyp__setNSeats_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(nSeats, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::PassengerTyp::toString(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::PassengerTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::PassengerTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->toString(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__PassengerTyp__toString_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::DateTimeTypPtr IceDelegateD::cardroid::data::zerocice::TripOfferTyp::getTripDateTime(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::DateTimeTypPtr& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripDateTime(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::DateTimeTypPtr& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__getTripDateTime_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::DateTimeTypPtr __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripOfferTyp::setTripDateTime(
		const ::cardroid::data::zerocice::DateTimeTypPtr& dt,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::DateTimeTypPtr& __p_dt,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_dt(__p_dt) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripDateTime(_m_dt, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::DateTimeTypPtr& _m_dt;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__setTripDateTime_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(dt, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::DateTimeTypPtr IceDelegateD::cardroid::data::zerocice::TripOfferTyp::getTripReturnDateTime(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::DateTimeTypPtr& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripReturnDateTime(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::DateTimeTypPtr& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__getTripReturnDateTime_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::DateTimeTypPtr __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripOfferTyp::setTripReturnDateTime(
		const ::cardroid::data::zerocice::DateTimeTypPtr& rdt,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::DateTimeTypPtr& __p_rdt,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_rdt(__p_rdt) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripReturnDateTime(_m_rdt, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::DateTimeTypPtr& _m_rdt;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__setTripReturnDateTime_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(rdt, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateD::cardroid::data::zerocice::TripOfferTyp::getTripDriver(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::UserTypPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripDriver(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::UserTypPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__getTripDriver_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::UserTypPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripOfferTyp::setTripDriver(
		const ::cardroid::data::zerocice::UserTypPrx& driver,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::UserTypPrx& __p_driver,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_driver(__p_driver) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripDriver(_m_driver, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserTypPrx& _m_driver;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__setTripDriver_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(driver, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::WaypointCollection IceDelegateD::cardroid::data::zerocice::TripOfferTyp::getTripWaypoints(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::WaypointCollection& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripWaypoints(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::WaypointCollection& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__getTripWaypoints_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::WaypointCollection __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripOfferTyp::setTripWaypoints(
		const ::cardroid::data::zerocice::WaypointCollection& waypoints,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(
				const ::cardroid::data::zerocice::WaypointCollection& __p_waypoints,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_waypoints(__p_waypoints) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripWaypoints(_m_waypoints, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::WaypointCollection& _m_waypoints;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__setTripWaypoints_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(waypoints, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::CarTypPrx IceDelegateD::cardroid::data::zerocice::TripOfferTyp::getTripCar(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::CarTypPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripCar(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::CarTypPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__getTripCar_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::CarTypPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripOfferTyp::setTripCar(
		const ::cardroid::data::zerocice::CarTypPrx& tripCar,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::CarTypPrx& __p_tripCar,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_tripCar(__p_tripCar) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripCar(_m_tripCar, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::CarTypPrx& _m_tripCar;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__setTripCar_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(tripCar, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::PassengerCollection IceDelegateD::cardroid::data::zerocice::TripOfferTyp::getTripPassengers(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::PassengerCollection& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripPassengers(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::PassengerCollection& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__getTripPassengers_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::PassengerCollection __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripOfferTyp::setTripPassengers(
		const ::cardroid::data::zerocice::PassengerCollection& passengers,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(
				const ::cardroid::data::zerocice::PassengerCollection& __p_passengers,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_passengers(__p_passengers) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripPassengers(_m_passengers, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::PassengerCollection& _m_passengers;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__setTripPassengers_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(passengers, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Double IceDelegateD::cardroid::data::zerocice::TripOfferTyp::getPrice(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Double& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getPrice(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Double& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__getPrice_name,
			::Ice::Idempotent, __context);
	::Ice::Double __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripOfferTyp::setPrice(
		::Ice::Double price, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Double __p_price, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_price(__p_price) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setPrice(_m_price, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Double _m_price;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__setPrice_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(price, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::AllowedV IceDelegateD::cardroid::data::zerocice::TripOfferTyp::getAllowedFeatures(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::AllowedV& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getAllowedFeatures(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::AllowedV& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__getAllowedFeatures_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::AllowedV __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripOfferTyp::setAllowedFeatures(
		const ::cardroid::data::zerocice::AllowedV& allowed,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::AllowedV& __p_allowed,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_allowed(__p_allowed) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setAllowedFeatures(_m_allowed, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::AllowedV& _m_allowed;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__setAllowedFeatures_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(allowed, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

bool IceDelegateD::cardroid::data::zerocice::TripOfferTyp::addTripWaypoint(
		const ::cardroid::data::zerocice::PlaceTypPtr& waypoint,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result,
				const ::cardroid::data::zerocice::PlaceTypPtr& __p_waypoint,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_waypoint(
						__p_waypoint) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->addTripWaypoint(_m_waypoint, _current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
		const ::cardroid::data::zerocice::PlaceTypPtr& _m_waypoint;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__addTripWaypoint_name,
			::Ice::Normal, __context);
	bool __result;
	try {
		_DirectI __direct(__result, waypoint, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

bool IceDelegateD::cardroid::data::zerocice::TripOfferTyp::removeTripWaypoint(
		::Ice::Int pos, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result, ::Ice::Int __p_pos,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_pos(
						__p_pos) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->removeTripWaypoint(_m_pos, _current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
		::Ice::Int _m_pos;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__removeTripWaypoint_name,
			::Ice::Normal, __context);
	bool __result;
	try {
		_DirectI __direct(__result, pos, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::TripOfferTyp::getNTripWaypoints(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getNTripWaypoints(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__getNTripWaypoints_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripOfferTyp::clearTripWaypoints(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::Ice::Current& __current) :
				::IceInternal::Direct(__current) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->clearTripWaypoints(_current);
			return ::Ice::DispatchOK;
		}

	private:

	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__clearTripWaypoints_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(__current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

bool IceDelegateD::cardroid::data::zerocice::TripOfferTyp::addTripPassenger(
		const ::cardroid::data::zerocice::UserTypPrx& passenger,
		::Ice::Int seats, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result,
				const ::cardroid::data::zerocice::UserTypPrx& __p_passenger,
				::Ice::Int __p_seats, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_passenger(
						__p_passenger), _m_seats(__p_seats) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->addTripPassenger(_m_passenger, _m_seats,
					_current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
		const ::cardroid::data::zerocice::UserTypPrx& _m_passenger;
		::Ice::Int _m_seats;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__addTripPassenger_name,
			::Ice::Normal, __context);
	bool __result;
	try {
		_DirectI __direct(__result, passenger, seats, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

bool IceDelegateD::cardroid::data::zerocice::TripOfferTyp::removeTripPassenger(
		const ::cardroid::data::zerocice::UserTypPrx& passenger,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result,
				const ::cardroid::data::zerocice::UserTypPrx& __p_passenger,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_passenger(
						__p_passenger) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->removeTripPassenger(_m_passenger, _current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
		const ::cardroid::data::zerocice::UserTypPrx& _m_passenger;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__removeTripPassenger_name,
			::Ice::Normal, __context);
	bool __result;
	try {
		_DirectI __direct(__result, passenger, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::Ice::Int IceDelegateD::cardroid::data::zerocice::TripOfferTyp::getNTripPassengers(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Int& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getNTripPassengers(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Int& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__getNTripPassengers_name,
			::Ice::Idempotent, __context);
	::Ice::Int __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripOfferTyp::clearTripPassengers(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::Ice::Current& __current) :
				::IceInternal::Direct(__current) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripOfferTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripOfferTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->clearTripPassengers(_current);
			return ::Ice::DispatchOK;
		}

	private:

	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripOfferTyp__clearTripPassengers_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(__current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::DateTimePrefsTypPtr IceDelegateD::cardroid::data::zerocice::TripRequestTyp::getTripDateTimePrefs(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::DateTimePrefsTypPtr& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripRequestTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripRequestTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripDateTimePrefs(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::DateTimePrefsTypPtr& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripRequestTyp__getTripDateTimePrefs_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::DateTimePrefsTypPtr __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripRequestTyp::setTripDateTimePrefs(
		const ::cardroid::data::zerocice::DateTimePrefsTypPtr& dtp,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::DateTimePrefsTypPtr& __p_dtp,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_dtp(__p_dtp) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripRequestTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripRequestTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripDateTimePrefs(_m_dtp, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::DateTimePrefsTypPtr& _m_dtp;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripRequestTyp__setTripDateTimePrefs_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(dtp, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::DateTimePrefsTypPtr IceDelegateD::cardroid::data::zerocice::TripRequestTyp::getTripReturnDateTimePrefs(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::DateTimePrefsTypPtr& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripRequestTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripRequestTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripReturnDateTimePrefs(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::DateTimePrefsTypPtr& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripRequestTyp__getTripReturnDateTimePrefs_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::DateTimePrefsTypPtr __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripRequestTyp::setTripReturnDateTimePrefs(
		const ::cardroid::data::zerocice::DateTimePrefsTypPtr& rdtp,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(
				const ::cardroid::data::zerocice::DateTimePrefsTypPtr& __p_rdtp,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_rdtp(__p_rdtp) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripRequestTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripRequestTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripReturnDateTimePrefs(_m_rdtp, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::DateTimePrefsTypPtr& _m_rdtp;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripRequestTyp__setTripReturnDateTimePrefs_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(rdtp, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateD::cardroid::data::zerocice::TripRequestTyp::getTripRequester(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::UserTypPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripRequestTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripRequestTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripRequester(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::UserTypPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripRequestTyp__getTripRequester_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::UserTypPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::TripRequestTyp::setTripRequester(
		const ::cardroid::data::zerocice::UserTypPrx& requester,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::UserTypPrx& __p_requester,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_requester(__p_requester) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::TripRequestTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::TripRequestTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTripRequester(_m_requester, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserTypPrx& _m_requester;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__TripRequestTyp__setTripRequester_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(requester, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateD::cardroid::data::zerocice::UserActivityTyp::getActivityUser(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::UserTypPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserActivityTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserActivityTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getActivityUser(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::UserTypPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserActivityTyp__getActivityUser_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::UserTypPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserActivityTyp::setActivityUser(
		const ::cardroid::data::zerocice::UserTypPrx& activityUser,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::UserTypPrx& __p_activityUser,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_activityUser(
						__p_activityUser) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserActivityTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserActivityTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setActivityUser(_m_activityUser, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserTypPrx& _m_activityUser;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserActivityTyp__setActivityUser_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(activityUser, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::TripOfferTypPrx IceDelegateD::cardroid::data::zerocice::UserActivityTyp::getActivityTrip(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::TripOfferTypPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserActivityTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserActivityTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getActivityTrip(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::TripOfferTypPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserActivityTyp__getActivityTrip_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::TripOfferTypPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserActivityTyp::setActivityTrip(
		const ::cardroid::data::zerocice::TripOfferTypPrx& activityTrip,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(
				const ::cardroid::data::zerocice::TripOfferTypPrx& __p_activityTrip,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_activityTrip(
						__p_activityTrip) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserActivityTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserActivityTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setActivityTrip(_m_activityTrip, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::TripOfferTypPrx& _m_activityTrip;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserActivityTyp__setActivityTrip_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(activityTrip, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::ActivityType IceDelegateD::cardroid::data::zerocice::UserActivityTyp::getUserActivityType(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::ActivityType& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserActivityTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserActivityTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getUserActivityType(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::ActivityType& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserActivityTyp__getUserActivityType_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::ActivityType __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserActivityTyp::setUserActivityType(
		::cardroid::data::zerocice::ActivityType userActivityType,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::ActivityType __p_userActivityType,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_userActivityType(
						__p_userActivityType) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserActivityTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserActivityTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setUserActivityType(_m_userActivityType, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::ActivityType _m_userActivityType;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserActivityTyp__setUserActivityType_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(userActivityType, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Long IceDelegateD::cardroid::data::zerocice::UserActivityTyp::getTimeStampInMillis(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Long& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserActivityTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserActivityTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTimeStampInMillis(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Long& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserActivityTyp__getTimeStampInMillis_name,
			::Ice::Idempotent, __context);
	::Ice::Long __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::UserActivityTyp::setTimeStampInMillis(
		::Ice::Long timeStampMillis, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Long __p_timeStampMillis,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_timeStampMillis(
						__p_timeStampMillis) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserActivityTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserActivityTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTimeStampInMillis(_m_timeStampMillis, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Long _m_timeStampMillis;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserActivityTyp__setTimeStampInMillis_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(timeStampMillis, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::UserActivityTyp::toString(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::UserActivityTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::UserActivityTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->toString(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__UserActivityTyp__toString_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::UserTypPrx IceDelegateD::cardroid::data::zerocice::MessageTyp::getUser1(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::UserTypPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::MessageTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::MessageTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getUser1(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::UserTypPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__MessageTyp__getUser1_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::UserTypPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::MessageTyp::setUser1(
		const ::cardroid::data::zerocice::UserTypPrx& user1,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::UserTypPrx& __p_user1,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_user1(__p_user1) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::MessageTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::MessageTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setUser1(_m_user1, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserTypPrx& _m_user1;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__MessageTyp__setUser1_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(user1, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateD::cardroid::data::zerocice::MessageTyp::getUser2(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::UserTypPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::MessageTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::MessageTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getUser2(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::UserTypPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__MessageTyp__getUser2_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::UserTypPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::MessageTyp::setUser2(
		const ::cardroid::data::zerocice::UserTypPrx& user2,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::UserTypPrx& __p_user2,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_user2(__p_user2) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::MessageTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::MessageTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setUser2(_m_user2, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserTypPrx& _m_user2;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__MessageTyp__setUser2_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(user2, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::MessageTyp::getMessageText(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::MessageTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::MessageTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getMessageText(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__MessageTyp__getMessageText_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::MessageTyp::setMessageText(
		const ::std::string& msg, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::std::string& __p_msg, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_msg(__p_msg) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::MessageTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::MessageTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setMessageText(_m_msg, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::std::string& _m_msg;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__MessageTyp__setMessageText_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(msg, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Long IceDelegateD::cardroid::data::zerocice::MessageTyp::getTimeStampInMillis(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Long& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::MessageTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::MessageTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTimeStampInMillis(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Long& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__MessageTyp__getTimeStampInMillis_name,
			::Ice::Idempotent, __context);
	::Ice::Long __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::data::zerocice::MessageTyp::setTimeStampInMillis(
		::Ice::Long timeStampMillis, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Long __p_timeStampMillis,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_timeStampMillis(
						__p_timeStampMillis) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::MessageTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::MessageTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->setTimeStampInMillis(_m_timeStampMillis, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Long _m_timeStampMillis;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__MessageTyp__setTimeStampInMillis_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(timeStampMillis, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::std::string IceDelegateD::cardroid::data::zerocice::MessageTyp::toString(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::std::string& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::data::zerocice::MessageTyp* servant =
					dynamic_cast< ::cardroid::data::zerocice::MessageTyp*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->toString(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::std::string& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__data__zerocice__MessageTyp__toString_name,
			::Ice::Idempotent, __context);
	::std::string __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::ResultSeq IceDelegateD::cardroid::QueryResult::next(::Ice::Int n,
		bool& destroyed, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::ResultSeq& __result, ::Ice::Int __p_n,
				bool& __p_destroyed, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_n(
						__p_n), _m_destroyed(__p_destroyed) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::QueryResult* servant =
					dynamic_cast< ::cardroid::QueryResult*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->next(_m_n, _m_destroyed, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::ResultSeq& _result;
		::Ice::Int _m_n;
		bool& _m_destroyed;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__QueryResult__next_name, ::Ice::Normal,
			__context);
	::cardroid::ResultSeq __result;
	try {
		_DirectI __direct(__result, n, destroyed, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::QueryResult::destroy(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::Ice::Current& __current) :
				::IceInternal::Direct(__current) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::QueryResult* servant =
					dynamic_cast< ::cardroid::QueryResult*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->destroy(_current);
			return ::Ice::DispatchOK;
		}

	private:

	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__QueryResult__destroy_name,
			::Ice::Normal, __context);
	try {
		_DirectI __direct(__current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

void IceDelegateD::cardroid::zerocice::CardroidManager::getUserPlaces(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::UserTypPrx& __p_usr,
				::Ice::Int __p_n, ::cardroid::ResultSeq& __p_first,
				::Ice::Int& __p_nrows, ::cardroid::QueryResultPrx& __p_result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_usr(__p_usr), _m_n(__p_n), _m_first(
						__p_first), _m_nrows(__p_nrows), _m_result(__p_result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->getUserPlaces(_m_usr, _m_n, _m_first, _m_nrows, _m_result,
					_current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserTypPrx& _m_usr;
		::Ice::Int _m_n;
		::cardroid::ResultSeq& _m_first;
		::Ice::Int& _m_nrows;
		::cardroid::QueryResultPrx& _m_result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__getUserPlaces_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(usr, n, first, nrows, result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

void IceDelegateD::cardroid::zerocice::CardroidManager::searchTrips(
		const ::cardroid::data::zerocice::TripRequestTypPtr& tRequest,
		::Ice::Int n, ::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(
				const ::cardroid::data::zerocice::TripRequestTypPtr& __p_tRequest,
				::Ice::Int __p_n, ::cardroid::ResultSeq& __p_first,
				::Ice::Int& __p_nrows, ::cardroid::QueryResultPrx& __p_result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_tRequest(__p_tRequest), _m_n(
						__p_n), _m_first(__p_first), _m_nrows(__p_nrows), _m_result(
						__p_result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->searchTrips(_m_tRequest, _m_n, _m_first, _m_nrows,
					_m_result, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::TripRequestTypPtr& _m_tRequest;
		::Ice::Int _m_n;
		::cardroid::ResultSeq& _m_first;
		::Ice::Int& _m_nrows;
		::cardroid::QueryResultPrx& _m_result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__searchTrips_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(tRequest, n, first, nrows, result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::TripTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::getTripFromId(
		::Ice::Int tripId, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::TripTypPrx& __result,
				::Ice::Int __p_tripId, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_tripId(
						__p_tripId) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripFromId(_m_tripId, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::TripTypPrx& _result;
		::Ice::Int _m_tripId;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__getTripFromId_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::TripTypPrx __result;
	try {
		_DirectI __direct(__result, tripId, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::TripOfferTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::getTripOfferFromId(
		::Ice::Int tripId, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::TripOfferTypPrx& __result,
				::Ice::Int __p_tripId, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_tripId(
						__p_tripId) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripOfferFromId(_m_tripId, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::TripOfferTypPrx& _result;
		::Ice::Int _m_tripId;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__getTripOfferFromId_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::TripOfferTypPrx __result;
	try {
		_DirectI __direct(__result, tripId, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::TripRequestTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::getTripRequestFromId(
		::Ice::Int tripId, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::TripRequestTypPrx& __result,
				::Ice::Int __p_tripId, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_tripId(
						__p_tripId) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTripRequestFromId(_m_tripId, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::TripRequestTypPrx& _result;
		::Ice::Int _m_tripId;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__getTripRequestFromId_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::TripRequestTypPrx __result;
	try {
		_DirectI __direct(__result, tripId, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::zerocice::CardroidManager::joinTrip(
		const ::cardroid::data::zerocice::TripOfferTypPrx& trip,
		const ::cardroid::data::zerocice::UserTypPrx& passenger,
		::Ice::Int nSeats, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::TripOfferTypPrx& __p_trip,
				const ::cardroid::data::zerocice::UserTypPrx& __p_passenger,
				::Ice::Int __p_nSeats, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_trip(__p_trip), _m_passenger(
						__p_passenger), _m_nSeats(__p_nSeats) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->joinTrip(_m_trip, _m_passenger, _m_nSeats, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::TripOfferTypPrx& _m_trip;
		const ::cardroid::data::zerocice::UserTypPrx& _m_passenger;
		::Ice::Int _m_nSeats;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__joinTrip_name, ::Ice::Normal,
			__context);
	try {
		_DirectI __direct(trip, passenger, nSeats, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::TripOfferTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::organizeTrip(
		const ::cardroid::data::zerocice::TripRequestTypPrx& tripRequest,
		const ::cardroid::data::zerocice::TripOfferTypPtr& tripOffer,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::TripOfferTypPrx& __result,
				const ::cardroid::data::zerocice::TripRequestTypPrx& __p_tripRequest,
				const ::cardroid::data::zerocice::TripOfferTypPtr& __p_tripOffer,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_tripRequest(
						__p_tripRequest), _m_tripOffer(__p_tripOffer) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->organizeTrip(_m_tripRequest, _m_tripOffer,
					_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::TripOfferTypPrx& _result;
		const ::cardroid::data::zerocice::TripRequestTypPrx& _m_tripRequest;
		const ::cardroid::data::zerocice::TripOfferTypPtr& _m_tripOffer;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__organizeTrip_name,
			::Ice::Normal, __context);
	::cardroid::data::zerocice::TripOfferTypPrx __result;
	try {
		_DirectI __direct(__result, tripRequest, tripOffer, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::zerocice::CardroidManager::getUserTrips(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::UserTypPrx& __p_usr,
				::Ice::Int __p_n, ::cardroid::ResultSeq& __p_first,
				::Ice::Int& __p_nrows, ::cardroid::QueryResultPrx& __p_result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_usr(__p_usr), _m_n(__p_n), _m_first(
						__p_first), _m_nrows(__p_nrows), _m_result(__p_result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->getUserTrips(_m_usr, _m_n, _m_first, _m_nrows, _m_result,
					_current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserTypPrx& _m_usr;
		::Ice::Int _m_n;
		::cardroid::ResultSeq& _m_first;
		::Ice::Int& _m_nrows;
		::cardroid::QueryResultPrx& _m_result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__getUserTrips_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(usr, n, first, nrows, result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

void IceDelegateD::cardroid::zerocice::CardroidManager::getPassengerTrips(
		const ::cardroid::data::zerocice::UserTypPrx& passenger, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::UserTypPrx& __p_passenger,
				::Ice::Int __p_n, ::cardroid::ResultSeq& __p_first,
				::Ice::Int& __p_nrows, ::cardroid::QueryResultPrx& __p_result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_passenger(__p_passenger), _m_n(
						__p_n), _m_first(__p_first), _m_nrows(__p_nrows), _m_result(
						__p_result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->getPassengerTrips(_m_passenger, _m_n, _m_first, _m_nrows,
					_m_result, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserTypPrx& _m_passenger;
		::Ice::Int _m_n;
		::cardroid::ResultSeq& _m_first;
		::Ice::Int& _m_nrows;
		::cardroid::QueryResultPrx& _m_result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__getPassengerTrips_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(passenger, n, first, nrows, result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

bool IceDelegateD::cardroid::zerocice::CardroidManager::userTripRegistered(
		const ::cardroid::data::zerocice::UserTypPrx& usr,
		const ::cardroid::data::zerocice::TripTypPrx& trip,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result,
				const ::cardroid::data::zerocice::UserTypPrx& __p_usr,
				const ::cardroid::data::zerocice::TripTypPrx& __p_trip,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_usr(
						__p_usr), _m_trip(__p_trip) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->userTripRegistered(_m_usr, _m_trip, _current);
			return ::Ice::DispatchOK;
		}

	private:

		bool& _result;
		const ::cardroid::data::zerocice::UserTypPrx& _m_usr;
		const ::cardroid::data::zerocice::TripTypPrx& _m_trip;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__userTripRegistered_name,
			::Ice::Idempotent, __context);
	bool __result;
	try {
		_DirectI __direct(__result, usr, trip, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::Ice::Double IceDelegateD::cardroid::zerocice::CardroidManager::calculatePriceEstimation(
		::cardroid::data::zerocice::Fuel f, ::Ice::Int distance,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Double& __result,
				::cardroid::data::zerocice::Fuel __p_f, ::Ice::Int __p_distance,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_f(
						__p_f), _m_distance(__p_distance) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->calculatePriceEstimation(_m_f, _m_distance,
					_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Double& _result;
		::cardroid::data::zerocice::Fuel _m_f;
		::Ice::Int _m_distance;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__calculatePriceEstimation_name,
			::Ice::Idempotent, __context);
	::Ice::Double __result;
	try {
		_DirectI __direct(__result, f, distance, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::TripOfferTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::newTripOffer(
		const ::cardroid::data::zerocice::TripOfferTypPtr& tOffer,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::TripOfferTypPrx& __result,
				const ::cardroid::data::zerocice::TripOfferTypPtr& __p_tOffer,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_tOffer(
						__p_tOffer) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->newTripOffer(_m_tOffer, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::TripOfferTypPrx& _result;
		const ::cardroid::data::zerocice::TripOfferTypPtr& _m_tOffer;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__newTripOffer_name,
			::Ice::Normal, __context);
	::cardroid::data::zerocice::TripOfferTypPrx __result;
	try {
		_DirectI __direct(__result, tOffer, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::TripRequestTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::newTripRequest(
		const ::cardroid::data::zerocice::TripRequestTypPtr& tRequest,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::TripRequestTypPrx& __result,
				const ::cardroid::data::zerocice::TripRequestTypPtr& __p_tRequest,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_tRequest(
						__p_tRequest) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->newTripRequest(_m_tRequest, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::TripRequestTypPrx& _result;
		const ::cardroid::data::zerocice::TripRequestTypPtr& _m_tRequest;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__newTripRequest_name,
			::Ice::Normal, __context);
	::cardroid::data::zerocice::TripRequestTypPrx __result;
	try {
		_DirectI __direct(__result, tRequest, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::zerocice::CardroidManager::getMessageTalksSpeakers(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::UserTypPrx& __p_usr,
				::Ice::Int __p_n, ::cardroid::ResultSeq& __p_first,
				::Ice::Int& __p_nrows, ::cardroid::QueryResultPrx& __p_result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_usr(__p_usr), _m_n(__p_n), _m_first(
						__p_first), _m_nrows(__p_nrows), _m_result(__p_result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->getMessageTalksSpeakers(_m_usr, _m_n, _m_first, _m_nrows,
					_m_result, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserTypPrx& _m_usr;
		::Ice::Int _m_n;
		::cardroid::ResultSeq& _m_first;
		::Ice::Int& _m_nrows;
		::cardroid::QueryResultPrx& _m_result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__getMessageTalksSpeakers_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(usr, n, first, nrows, result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

void IceDelegateD::cardroid::zerocice::CardroidManager::getMessageTalks(
		const ::cardroid::data::zerocice::UserTypPrx& usr1,
		const ::cardroid::data::zerocice::UserTypPrx& usr2, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::UserTypPrx& __p_usr1,
				const ::cardroid::data::zerocice::UserTypPrx& __p_usr2,
				::Ice::Int __p_n, ::cardroid::ResultSeq& __p_first,
				::Ice::Int& __p_nrows, ::cardroid::QueryResultPrx& __p_result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_usr1(__p_usr1), _m_usr2(
						__p_usr2), _m_n(__p_n), _m_first(__p_first), _m_nrows(
						__p_nrows), _m_result(__p_result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->getMessageTalks(_m_usr1, _m_usr2, _m_n, _m_first, _m_nrows,
					_m_result, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserTypPrx& _m_usr1;
		const ::cardroid::data::zerocice::UserTypPrx& _m_usr2;
		::Ice::Int _m_n;
		::cardroid::ResultSeq& _m_first;
		::Ice::Int& _m_nrows;
		::cardroid::QueryResultPrx& _m_result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__getMessageTalks_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(usr1, usr2, n, first, nrows, result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::MessageTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::newMessage(
		const ::cardroid::data::zerocice::UserTypPrx& usr1,
		const ::cardroid::data::zerocice::UserTypPrx& usr2,
		const ::std::string& message, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::MessageTypPrx& __result,
				const ::cardroid::data::zerocice::UserTypPrx& __p_usr1,
				const ::cardroid::data::zerocice::UserTypPrx& __p_usr2,
				const ::std::string& __p_message,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_usr1(
						__p_usr1), _m_usr2(__p_usr2), _m_message(__p_message) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->newMessage(_m_usr1, _m_usr2, _m_message,
					_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::MessageTypPrx& _result;
		const ::cardroid::data::zerocice::UserTypPrx& _m_usr1;
		const ::cardroid::data::zerocice::UserTypPrx& _m_usr2;
		const ::std::string& _m_message;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__newMessage_name,
			::Ice::Normal, __context);
	::cardroid::data::zerocice::MessageTypPrx __result;
	try {
		_DirectI __direct(__result, usr1, usr2, message, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::zerocice::CardroidManager::getUserActivity(
		const ::cardroid::data::zerocice::UserTypPrx& usr, ::Ice::Int n,
		::cardroid::ResultSeq& first, ::Ice::Int& nrows,
		::cardroid::QueryResultPrx& result, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::UserTypPrx& __p_usr,
				::Ice::Int __p_n, ::cardroid::ResultSeq& __p_first,
				::Ice::Int& __p_nrows, ::cardroid::QueryResultPrx& __p_result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_usr(__p_usr), _m_n(__p_n), _m_first(
						__p_first), _m_nrows(__p_nrows), _m_result(__p_result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->getUserActivity(_m_usr, _m_n, _m_first, _m_nrows,
					_m_result, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserTypPrx& _m_usr;
		::Ice::Int _m_n;
		::cardroid::ResultSeq& _m_first;
		::Ice::Int& _m_nrows;
		::cardroid::QueryResultPrx& _m_result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__getUserActivity_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(usr, n, first, nrows, result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::data::zerocice::UserTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::getUserFromEmail(
		const ::std::string& email, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::UserTypPrx& __result,
				const ::std::string& __p_email, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_email(
						__p_email) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getUserFromEmail(_m_email, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::UserTypPrx& _result;
		const ::std::string& _m_email;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__getUserFromEmail_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::UserTypPrx __result;
	try {
		_DirectI __direct(__result, email, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::getCarFromPlate(
		const ::std::string& plate,
		const ::cardroid::data::zerocice::UserTypPrx& owner,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::CarTypPrx& __result,
				const ::std::string& __p_plate,
				const ::cardroid::data::zerocice::UserTypPrx& __p_owner,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_plate(
						__p_plate), _m_owner(__p_owner) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getCarFromPlate(_m_plate, _m_owner, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::CarTypPrx& _result;
		const ::std::string& _m_plate;
		const ::cardroid::data::zerocice::UserTypPrx& _m_owner;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__getCarFromPlate_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::CarTypPrx __result;
	try {
		_DirectI __direct(__result, plate, owner, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::getCarFromPlateEmail(
		const ::std::string& plate, const ::std::string& ownerEmail,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::CarTypPrx& __result,
				const ::std::string& __p_plate,
				const ::std::string& __p_ownerEmail,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_plate(
						__p_plate), _m_ownerEmail(__p_ownerEmail) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getCarFromPlateEmail(_m_plate, _m_ownerEmail,
					_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::CarTypPrx& _result;
		const ::std::string& _m_plate;
		const ::std::string& _m_ownerEmail;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__getCarFromPlateEmail_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::CarTypPrx __result;
	try {
		_DirectI __direct(__result, plate, ownerEmail, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::UserTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::updateUserData(
		const ::cardroid::data::zerocice::UserTypPtr& usr,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::UserTypPrx& __result,
				const ::cardroid::data::zerocice::UserTypPtr& __p_usr,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_usr(
						__p_usr) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->updateUserData(_m_usr, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::UserTypPrx& _result;
		const ::cardroid::data::zerocice::UserTypPtr& _m_usr;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__updateUserData_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::UserTypPrx __result;
	try {
		_DirectI __direct(__result, usr, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::updateCarData(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::cardroid::data::zerocice::UserTypPtr& usr,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::CarTypPrx& __result,
				const ::cardroid::data::zerocice::CarTypPtr& __p_car,
				const ::cardroid::data::zerocice::UserTypPtr& __p_usr,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_car(
						__p_car), _m_usr(__p_usr) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->updateCarData(_m_car, _m_usr, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::CarTypPrx& _result;
		const ::cardroid::data::zerocice::CarTypPtr& _m_car;
		const ::cardroid::data::zerocice::UserTypPtr& _m_usr;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__updateCarData_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::CarTypPrx __result;
	try {
		_DirectI __direct(__result, car, usr, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::updateCarDataEmail(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::std::string& usrEmail, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::CarTypPrx& __result,
				const ::cardroid::data::zerocice::CarTypPtr& __p_car,
				const ::std::string& __p_usrEmail,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_car(
						__p_car), _m_usrEmail(__p_usrEmail) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->updateCarDataEmail(_m_car, _m_usrEmail,
					_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::CarTypPrx& _result;
		const ::cardroid::data::zerocice::CarTypPtr& _m_car;
		const ::std::string& _m_usrEmail;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__updateCarDataEmail_name,
			::Ice::Idempotent, __context);
	::cardroid::data::zerocice::CarTypPrx __result;
	try {
		_DirectI __direct(__result, car, usrEmail, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::addCar(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::cardroid::data::zerocice::UserTypPrx& usr,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::CarTypPrx& __result,
				const ::cardroid::data::zerocice::CarTypPtr& __p_car,
				const ::cardroid::data::zerocice::UserTypPrx& __p_usr,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_car(
						__p_car), _m_usr(__p_usr) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->addCar(_m_car, _m_usr, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::CarTypPrx& _result;
		const ::cardroid::data::zerocice::CarTypPtr& _m_car;
		const ::cardroid::data::zerocice::UserTypPrx& _m_usr;
	};

	::Ice::Current __current;
	__initCurrent(__current, __cardroid__zerocice__CardroidManager__addCar_name,
			::Ice::Normal, __context);
	::cardroid::data::zerocice::CarTypPrx __result;
	try {
		_DirectI __direct(__result, car, usr, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::cardroid::data::zerocice::CarTypPrx IceDelegateD::cardroid::zerocice::CardroidManager::addCarEmail(
		const ::cardroid::data::zerocice::CarTypPtr& car,
		const ::std::string& usrEmail, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::data::zerocice::CarTypPrx& __result,
				const ::cardroid::data::zerocice::CarTypPtr& __p_car,
				const ::std::string& __p_usrEmail,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_car(
						__p_car), _m_usrEmail(__p_usrEmail) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->addCarEmail(_m_car, _m_usrEmail, _current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::data::zerocice::CarTypPrx& _result;
		const ::cardroid::data::zerocice::CarTypPtr& _m_car;
		const ::std::string& _m_usrEmail;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__addCarEmail_name,
			::Ice::Normal, __context);
	::cardroid::data::zerocice::CarTypPrx __result;
	try {
		_DirectI __direct(__result, car, usrEmail, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::zerocice::CardroidManager::removeCar(
		const ::cardroid::data::zerocice::CarTypPrx& car,
		const ::cardroid::data::zerocice::UserTypPrx& usr,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::CarTypPrx& __p_car,
				const ::cardroid::data::zerocice::UserTypPrx& __p_usr,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_car(__p_car), _m_usr(
						__p_usr) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->removeCar(_m_car, _m_usr, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::CarTypPrx& _m_car;
		const ::cardroid::data::zerocice::UserTypPrx& _m_usr;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__removeCar_name,
			::Ice::Normal, __context);
	try {
		_DirectI __direct(car, usr, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

void IceDelegateD::cardroid::zerocice::CardroidManager::removeCarPlateEmail(
		const ::std::string& plate, const ::std::string& ownerEmail,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::std::string& __p_plate,
				const ::std::string& __p_ownerEmail,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_plate(__p_plate), _m_ownerEmail(
						__p_ownerEmail) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::zerocice::CardroidManager* servant =
					dynamic_cast< ::cardroid::zerocice::CardroidManager*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->removeCarPlateEmail(_m_plate, _m_ownerEmail, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::std::string& _m_plate;
		const ::std::string& _m_ownerEmail;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__zerocice__CardroidManager__removeCarPlateEmail_name,
			::Ice::Normal, __context);
	try {
		_DirectI __direct(plate, ownerEmail, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::PlaceTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::PlaceTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__PlaceTyp_ids[2] = {
		"::Ice::Object", "::cardroid::data::zerocice::PlaceTyp" };

}

bool cardroid::data::zerocice::PlaceTyp::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__data__zerocice__PlaceTyp_ids,
			__cardroid__data__zerocice__PlaceTyp_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::PlaceTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__PlaceTyp_ids[0],
			&__cardroid__data__zerocice__PlaceTyp_ids[2]);
}

const ::std::string&
cardroid::data::zerocice::PlaceTyp::ice_id(const ::Ice::Current&) const {
	return __cardroid__data__zerocice__PlaceTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::PlaceTyp::ice_staticId() {
	return __cardroid__data__zerocice__PlaceTyp_ids[1];
}

::Ice::DispatchStatus cardroid::data::zerocice::PlaceTyp::___getName(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = getName(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PlaceTyp::___setName(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string name;
	__is->read(name);
	__inS.endReadParams();
	setName(name, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PlaceTyp::___getCoords(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::LatLngTyp __ret = getCoords(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PlaceTyp::___setCoords(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::LatLngTyp coords;
	__is->read(coords);
	__inS.endReadParams();
	setCoords(coords, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PlaceTyp::___getDescription(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = getDescription(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PlaceTyp::___setDescription(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string description;
	__is->read(description);
	__inS.endReadParams();
	setDescription(description, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PlaceTyp::___hasDescription(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	bool __ret = hasDescription(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PlaceTyp::___getSnapshotBytes(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::Blob __ret = getSnapshotBytes(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PlaceTyp::___setSnapshotBytes(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::Blob snapshotBytes;
	__is->read(snapshotBytes);
	__inS.endReadParams();
	setSnapshotBytes(snapshotBytes, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PlaceTyp::___hasSnapshot(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	bool __ret = hasSnapshot(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PlaceTyp::___toString(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = toString(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__data__zerocice__PlaceTyp_all[] = { "getCoords",
		"getDescription", "getName", "getSnapshotBytes", "hasDescription",
		"hasSnapshot", "ice_id", "ice_ids", "ice_isA", "ice_ping", "setCoords",
		"setDescription", "setName", "setSnapshotBytes", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::PlaceTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__PlaceTyp_all,
					__cardroid__data__zerocice__PlaceTyp_all + 15,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__PlaceTyp_all) {
	case 0: {
		return ___getCoords(in, current);
	}
	case 1: {
		return ___getDescription(in, current);
	}
	case 2: {
		return ___getName(in, current);
	}
	case 3: {
		return ___getSnapshotBytes(in, current);
	}
	case 4: {
		return ___hasDescription(in, current);
	}
	case 5: {
		return ___hasSnapshot(in, current);
	}
	case 6: {
		return ___ice_id(in, current);
	}
	case 7: {
		return ___ice_ids(in, current);
	}
	case 8: {
		return ___ice_isA(in, current);
	}
	case 9: {
		return ___ice_ping(in, current);
	}
	case 10: {
		return ___setCoords(in, current);
	}
	case 11: {
		return ___setDescription(in, current);
	}
	case 12: {
		return ___setName(in, current);
	}
	case 13: {
		return ___setSnapshotBytes(in, current);
	}
	case 14: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::PlaceTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->write(name);
	__os->write(coords);
	__os->write(3, placeDescription);
	__os->write(4, placeSnapshotBytes);
	__os->endWriteSlice();
}

void cardroid::data::zerocice::PlaceTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(name);
	__is->read(coords);
	__is->read(3, placeDescription);
	__is->read(4, placeSnapshotBytes);
	__is->endReadSlice();
}

void cardroid::data::zerocice::__patch(PlaceTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::PlaceTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::PlaceTyp::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::CarTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::CarTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__CarTyp_ids[2] = {
		"::Ice::Object", "::cardroid::data::zerocice::CarTyp" };

}

bool cardroid::data::zerocice::CarTyp::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__data__zerocice__CarTyp_ids,
			__cardroid__data__zerocice__CarTyp_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::CarTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__CarTyp_ids[0],
			&__cardroid__data__zerocice__CarTyp_ids[2]);
}

const ::std::string&
cardroid::data::zerocice::CarTyp::ice_id(const ::Ice::Current&) const {
	return __cardroid__data__zerocice__CarTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::CarTyp::ice_staticId() {
	return __cardroid__data__zerocice__CarTyp_ids[1];
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___getBrand(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = getBrand(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___setBrand(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string brand;
	__is->read(brand);
	__inS.endReadParams();
	setBrand(brand, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___getModel(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = getModel(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___setModel(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string model;
	__is->read(model);
	__inS.endReadParams();
	setModel(model, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___getCarFuel(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::Fuel __ret = getCarFuel(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___setCarFuel(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::Fuel carFuel;
	__is->read(carFuel);
	__inS.endReadParams();
	setCarFuel(carFuel, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___getConsumptionPerKm(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Double __ret = getConsumptionPerKm(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___setConsumptionPerKm(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Double consumptionPerKm;
	__is->read(consumptionPerKm);
	__inS.endReadParams();
	setConsumptionPerKm(consumptionPerKm, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___getNSeats(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getNSeats(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___setNSeats(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int nSeats;
	__is->read(nSeats);
	__inS.endReadParams();
	setNSeats(nSeats, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___getColor(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = getColor(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___setColor(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string color;
	__is->read(color);
	__inS.endReadParams();
	setColor(color, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___getPlate(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = getPlate(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___setPlate(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string plate;
	__is->read(plate);
	__inS.endReadParams();
	setPlate(plate, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::___toString(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = toString(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__data__zerocice__CarTyp_all[] = { "getBrand",
		"getCarFuel", "getColor", "getConsumptionPerKm", "getModel",
		"getNSeats", "getPlate", "ice_id", "ice_ids", "ice_isA", "ice_ping",
		"setBrand", "setCarFuel", "setColor", "setConsumptionPerKm", "setModel",
		"setNSeats", "setPlate", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::CarTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__CarTyp_all,
					__cardroid__data__zerocice__CarTyp_all + 19,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__CarTyp_all) {
	case 0: {
		return ___getBrand(in, current);
	}
	case 1: {
		return ___getCarFuel(in, current);
	}
	case 2: {
		return ___getColor(in, current);
	}
	case 3: {
		return ___getConsumptionPerKm(in, current);
	}
	case 4: {
		return ___getModel(in, current);
	}
	case 5: {
		return ___getNSeats(in, current);
	}
	case 6: {
		return ___getPlate(in, current);
	}
	case 7: {
		return ___ice_id(in, current);
	}
	case 8: {
		return ___ice_ids(in, current);
	}
	case 9: {
		return ___ice_isA(in, current);
	}
	case 10: {
		return ___ice_ping(in, current);
	}
	case 11: {
		return ___setBrand(in, current);
	}
	case 12: {
		return ___setCarFuel(in, current);
	}
	case 13: {
		return ___setColor(in, current);
	}
	case 14: {
		return ___setConsumptionPerKm(in, current);
	}
	case 15: {
		return ___setModel(in, current);
	}
	case 16: {
		return ___setNSeats(in, current);
	}
	case 17: {
		return ___setPlate(in, current);
	}
	case 18: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::CarTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->write(brand);
	__os->write(model);
	__os->write(carFuel);
	__os->write(consumptionPerKm);
	__os->write(nSeats);
	__os->write(color);
	__os->write(plate);
	__os->endWriteSlice();
}

void cardroid::data::zerocice::CarTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(brand);
	__is->read(model);
	__is->read(carFuel);
	__is->read(consumptionPerKm);
	__is->read(nSeats);
	__is->read(color);
	__is->read(plate);
	__is->endReadSlice();
}

void cardroid::data::zerocice::__patch(CarTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::CarTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::CarTyp::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::UserTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::UserTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__UserTyp_ids[2] = {
		"::Ice::Object", "::cardroid::data::zerocice::UserTyp" };

}

bool cardroid::data::zerocice::UserTyp::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__data__zerocice__UserTyp_ids,
			__cardroid__data__zerocice__UserTyp_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::UserTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__UserTyp_ids[0],
			&__cardroid__data__zerocice__UserTyp_ids[2]);
}

const ::std::string&
cardroid::data::zerocice::UserTyp::ice_id(const ::Ice::Current&) const {
	return __cardroid__data__zerocice__UserTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::UserTyp::ice_staticId() {
	return __cardroid__data__zerocice__UserTyp_ids[1];
}

void cardroid::data::zerocice::UserTyp::__addObject(
		::IceInternal::GCCountMap& _c) {
	::IceInternal::GCCountMap::iterator pos = _c.find(this);
	if (pos == _c.end()) {
		_c[this] = 1;
	} else {
		++pos->second;
	}
}

bool cardroid::data::zerocice::UserTyp::__usesGC() {
	return true;
}

void cardroid::data::zerocice::UserTyp::__gcReachable(
		::IceInternal::GCCountMap& _c) const {
	if (home) {
		::cardroid::data::zerocice::upCast(home.get())->__addObject(_c);
	}
}

void cardroid::data::zerocice::UserTyp::__gcClear() {
	if (home) {
		if (::cardroid::data::zerocice::upCast(home.get())->__usesGC()) {
			::cardroid::data::zerocice::upCast(home.get())->__decRefUnsafe();
			home.__clearHandleUnsafe();
		} else {
			home = 0;
		}
	}
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___getName(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = getName(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___setName(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string name;
	__is->read(name);
	__inS.endReadParams();
	setName(name, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___getSurname(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = getSurname(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___setSurname(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string surname;
	__is->read(surname);
	__inS.endReadParams();
	setSurname(surname, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___getAvatarBytes(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::Blob __ret = getAvatarBytes(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___setAvatarBytes(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::Blob avatarBytes;
	__is->read(avatarBytes);
	__inS.endReadParams();
	setAvatarBytes(avatarBytes, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___hasAvatar(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	bool __ret = hasAvatar(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___getUserHome(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::PlaceTypPtr __ret = getUserHome(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__os->writePendingObjects();
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___setUserHome(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::PlaceTypPtr home;
	__is->read(home);
	__is->readPendingObjects();
	__inS.endReadParams();
	setUserHome(home, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___getTelephone(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getTelephone(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___setTelephone(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int telephone;
	__is->read(telephone);
	__inS.endReadParams();
	setTelephone(telephone, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___getEmail(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = getEmail(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___setEmail(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string email;
	__is->read(email);
	__inS.endReadParams();
	setEmail(email, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___getReputation(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getReputation(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___setReputation(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int reputation;
	__is->read(reputation);
	__inS.endReadParams();
	setReputation(reputation, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___hasReputation(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	bool __ret = hasReputation(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___getUserCars(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::CarCollection __ret = getUserCars(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___setUserCars(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::CarCollection cars;
	__is->read(cars);
	__inS.endReadParams();
	setUserCars(cars, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___toString(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = toString(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___increaseReputation1(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	__inS.readEmptyParams();
	increaseReputation1(__current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___increaseReputation(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int increase;
	__is->read(increase);
	__inS.endReadParams();
	increaseReputation(increase, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___decreaseReputation1(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	__inS.readEmptyParams();
	decreaseReputation1(__current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___decreaseReputation(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int decrease;
	__is->read(decrease);
	__inS.endReadParams();
	decreaseReputation(decrease, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___addCar(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::CarTypPtr c;
	__is->read(c);
	__is->readPendingObjects();
	__inS.endReadParams();
	bool __ret = addCar(c, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___removeCar(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::CarTypPtr c;
	__is->read(c);
	__is->readPendingObjects();
	__inS.endReadParams();
	bool __ret = removeCar(c, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___getNCars(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getNCars(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::___clearCars(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	clearCars(__current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__data__zerocice__UserTyp_all[] = { "addCar",
		"clearCars", "decreaseReputation", "decreaseReputation1",
		"getAvatarBytes", "getEmail", "getNCars", "getName", "getReputation",
		"getSurname", "getTelephone", "getUserCars", "getUserHome", "hasAvatar",
		"hasReputation", "ice_id", "ice_ids", "ice_isA", "ice_ping",
		"increaseReputation", "increaseReputation1", "removeCar",
		"setAvatarBytes", "setEmail", "setName", "setReputation", "setSurname",
		"setTelephone", "setUserCars", "setUserHome", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::UserTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__UserTyp_all,
					__cardroid__data__zerocice__UserTyp_all + 31,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__UserTyp_all) {
	case 0: {
		return ___addCar(in, current);
	}
	case 1: {
		return ___clearCars(in, current);
	}
	case 2: {
		return ___decreaseReputation(in, current);
	}
	case 3: {
		return ___decreaseReputation1(in, current);
	}
	case 4: {
		return ___getAvatarBytes(in, current);
	}
	case 5: {
		return ___getEmail(in, current);
	}
	case 6: {
		return ___getNCars(in, current);
	}
	case 7: {
		return ___getName(in, current);
	}
	case 8: {
		return ___getReputation(in, current);
	}
	case 9: {
		return ___getSurname(in, current);
	}
	case 10: {
		return ___getTelephone(in, current);
	}
	case 11: {
		return ___getUserCars(in, current);
	}
	case 12: {
		return ___getUserHome(in, current);
	}
	case 13: {
		return ___hasAvatar(in, current);
	}
	case 14: {
		return ___hasReputation(in, current);
	}
	case 15: {
		return ___ice_id(in, current);
	}
	case 16: {
		return ___ice_ids(in, current);
	}
	case 17: {
		return ___ice_isA(in, current);
	}
	case 18: {
		return ___ice_ping(in, current);
	}
	case 19: {
		return ___increaseReputation(in, current);
	}
	case 20: {
		return ___increaseReputation1(in, current);
	}
	case 21: {
		return ___removeCar(in, current);
	}
	case 22: {
		return ___setAvatarBytes(in, current);
	}
	case 23: {
		return ___setEmail(in, current);
	}
	case 24: {
		return ___setName(in, current);
	}
	case 25: {
		return ___setReputation(in, current);
	}
	case 26: {
		return ___setSurname(in, current);
	}
	case 27: {
		return ___setTelephone(in, current);
	}
	case 28: {
		return ___setUserCars(in, current);
	}
	case 29: {
		return ___setUserHome(in, current);
	}
	case 30: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::UserTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->write(name);
	__os->write(surname);
	__os->write(home);
	__os->write(telephone);
	__os->write(email);
	__os->write(cars);
	__os->write(3, userAvatarBytes);
	__os->write(7, userReputation);
	__os->endWriteSlice();
}

void cardroid::data::zerocice::UserTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(name);
	__is->read(surname);
	__is->read(home);
	__is->read(telephone);
	__is->read(email);
	__is->read(cars);
	__is->read(3, userAvatarBytes);
	__is->read(7, userReputation);
	__is->endReadSlice();
}

void cardroid::data::zerocice::__patch(UserTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::UserTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::UserTyp::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::DateTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::DateTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__DateTyp_ids[2] = {
		"::Ice::Object", "::cardroid::data::zerocice::DateTyp" };

}

bool cardroid::data::zerocice::DateTyp::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__data__zerocice__DateTyp_ids,
			__cardroid__data__zerocice__DateTyp_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::DateTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__DateTyp_ids[0],
			&__cardroid__data__zerocice__DateTyp_ids[2]);
}

const ::std::string&
cardroid::data::zerocice::DateTyp::ice_id(const ::Ice::Current&) const {
	return __cardroid__data__zerocice__DateTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::DateTyp::ice_staticId() {
	return __cardroid__data__zerocice__DateTyp_ids[1];
}

::Ice::DispatchStatus cardroid::data::zerocice::DateTyp::___getTimeInMillis(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Long __ret = getTimeInMillis(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::DateTyp::___setTimeInMillis(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Long datetime;
	__is->read(datetime);
	__inS.endReadParams();
	setTimeInMillis(datetime, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::DateTyp::___toString(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = toString(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__data__zerocice__DateTyp_all[] = {
		"getTimeInMillis", "ice_id", "ice_ids", "ice_isA", "ice_ping",
		"setTimeInMillis", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::DateTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__DateTyp_all,
					__cardroid__data__zerocice__DateTyp_all + 7,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__DateTyp_all) {
	case 0: {
		return ___getTimeInMillis(in, current);
	}
	case 1: {
		return ___ice_id(in, current);
	}
	case 2: {
		return ___ice_ids(in, current);
	}
	case 3: {
		return ___ice_isA(in, current);
	}
	case 4: {
		return ___ice_ping(in, current);
	}
	case 5: {
		return ___setTimeInMillis(in, current);
	}
	case 6: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::DateTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->write(datetime);
	__os->endWriteSlice();
}

void cardroid::data::zerocice::DateTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(datetime);
	__is->endReadSlice();
}

void cardroid::data::zerocice::__patch(DateTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::DateTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::DateTyp::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::DateTimeTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::DateTimeTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__DateTimeTyp_ids[3] = {
		"::Ice::Object", "::cardroid::data::zerocice::DateTimeTyp",
		"::cardroid::data::zerocice::DateTyp" };

}

bool cardroid::data::zerocice::DateTimeTyp::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__data__zerocice__DateTimeTyp_ids,
			__cardroid__data__zerocice__DateTimeTyp_ids + 3, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::DateTimeTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__DateTimeTyp_ids[0],
			&__cardroid__data__zerocice__DateTimeTyp_ids[3]);
}

const ::std::string&
cardroid::data::zerocice::DateTimeTyp::ice_id(const ::Ice::Current&) const {
	return __cardroid__data__zerocice__DateTimeTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::DateTimeTyp::ice_staticId() {
	return __cardroid__data__zerocice__DateTimeTyp_ids[1];
}

namespace {
const ::std::string __cardroid__data__zerocice__DateTimeTyp_all[] = {
		"getTimeInMillis", "ice_id", "ice_ids", "ice_isA", "ice_ping",
		"setTimeInMillis", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::DateTimeTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__DateTimeTyp_all,
					__cardroid__data__zerocice__DateTimeTyp_all + 7,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__DateTimeTyp_all) {
	case 0: {
		return ___getTimeInMillis(in, current);
	}
	case 1: {
		return ___ice_id(in, current);
	}
	case 2: {
		return ___ice_ids(in, current);
	}
	case 3: {
		return ___ice_isA(in, current);
	}
	case 4: {
		return ___ice_ping(in, current);
	}
	case 5: {
		return ___setTimeInMillis(in, current);
	}
	case 6: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::DateTimeTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, false);
	__os->endWriteSlice();
	::cardroid::data::zerocice::DateTyp::__writeImpl(__os);
}

void cardroid::data::zerocice::DateTimeTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->endReadSlice();
	::cardroid::data::zerocice::DateTyp::__readImpl(__is);
}

void cardroid::data::zerocice::__patch(DateTimeTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::DateTimeTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::DateTimeTyp::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::DateTimePrefsTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::DateTimePrefsTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__DateTimePrefsTyp_ids[3] = {
		"::Ice::Object", "::cardroid::data::zerocice::DateTimePrefsTyp",
		"::cardroid::data::zerocice::DateTyp" };

}

bool cardroid::data::zerocice::DateTimePrefsTyp::ice_isA(
		const ::std::string& _s, const ::Ice::Current&) const {
	return ::std::binary_search(
			__cardroid__data__zerocice__DateTimePrefsTyp_ids,
			__cardroid__data__zerocice__DateTimePrefsTyp_ids + 3, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::DateTimePrefsTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__DateTimePrefsTyp_ids[0],
			&__cardroid__data__zerocice__DateTimePrefsTyp_ids[3]);
}

const ::std::string&
cardroid::data::zerocice::DateTimePrefsTyp::ice_id(
		const ::Ice::Current&) const {
	return __cardroid__data__zerocice__DateTimePrefsTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::DateTimePrefsTyp::ice_staticId() {
	return __cardroid__data__zerocice__DateTimePrefsTyp_ids[1];
}

::Ice::DispatchStatus cardroid::data::zerocice::DateTimePrefsTyp::___getToleranceDays(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getToleranceDays(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::DateTimePrefsTyp::___setToleranceDays(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int toleranceDays;
	__is->read(toleranceDays);
	__inS.endReadParams();
	setToleranceDays(toleranceDays, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::DateTimePrefsTyp::___getTimePrefs(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::TimePreferences __ret = getTimePrefs(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::DateTimePrefsTyp::___setTimePrefs(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::TimePreferences timePrefs;
	__is->read(timePrefs);
	__inS.endReadParams();
	setTimePrefs(timePrefs, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__data__zerocice__DateTimePrefsTyp_all[] = {
		"getTimeInMillis", "getTimePrefs", "getToleranceDays", "ice_id",
		"ice_ids", "ice_isA", "ice_ping", "setTimeInMillis", "setTimePrefs",
		"setToleranceDays", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::DateTimePrefsTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__DateTimePrefsTyp_all,
					__cardroid__data__zerocice__DateTimePrefsTyp_all + 11,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__DateTimePrefsTyp_all) {
	case 0: {
		return ___getTimeInMillis(in, current);
	}
	case 1: {
		return ___getTimePrefs(in, current);
	}
	case 2: {
		return ___getToleranceDays(in, current);
	}
	case 3: {
		return ___ice_id(in, current);
	}
	case 4: {
		return ___ice_ids(in, current);
	}
	case 5: {
		return ___ice_isA(in, current);
	}
	case 6: {
		return ___ice_ping(in, current);
	}
	case 7: {
		return ___setTimeInMillis(in, current);
	}
	case 8: {
		return ___setTimePrefs(in, current);
	}
	case 9: {
		return ___setToleranceDays(in, current);
	}
	case 10: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::DateTimePrefsTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, false);
	__os->write(toleranceDays);
	__os->write(timePrefs);
	__os->endWriteSlice();
	::cardroid::data::zerocice::DateTyp::__writeImpl(__os);
}

void cardroid::data::zerocice::DateTimePrefsTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(toleranceDays);
	__is->read(timePrefs);
	__is->endReadSlice();
	::cardroid::data::zerocice::DateTyp::__readImpl(__is);
}

void cardroid::data::zerocice::__patch(DateTimePrefsTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::DateTimePrefsTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::DateTimePrefsTyp::ice_staticId(),
				v);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::TripTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::TripTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__TripTyp_ids[2] = {
		"::Ice::Object", "::cardroid::data::zerocice::TripTyp" };

}

bool cardroid::data::zerocice::TripTyp::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__data__zerocice__TripTyp_ids,
			__cardroid__data__zerocice__TripTyp_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::TripTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__TripTyp_ids[0],
			&__cardroid__data__zerocice__TripTyp_ids[2]);
}

const ::std::string&
cardroid::data::zerocice::TripTyp::ice_id(const ::Ice::Current&) const {
	return __cardroid__data__zerocice__TripTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::TripTyp::ice_staticId() {
	return __cardroid__data__zerocice__TripTyp_ids[1];
}

void cardroid::data::zerocice::TripTyp::__addObject(
		::IceInternal::GCCountMap& _c) {
	::IceInternal::GCCountMap::iterator pos = _c.find(this);
	if (pos == _c.end()) {
		_c[this] = 1;
	} else {
		++pos->second;
	}
}

bool cardroid::data::zerocice::TripTyp::__usesGC() {
	return true;
}

void cardroid::data::zerocice::TripTyp::__gcReachable(
		::IceInternal::GCCountMap& _c) const {
	if (fromPlace) {
		::cardroid::data::zerocice::upCast(fromPlace.get())->__addObject(_c);
	}
	if (toPlace) {
		::cardroid::data::zerocice::upCast(toPlace.get())->__addObject(_c);
	}
	if (tDate) {
		::cardroid::data::zerocice::upCast(tDate.get())->__addObject(_c);
	}
	if (tReturnDate) {
		if ((*tReturnDate)) {
			::cardroid::data::zerocice::upCast((*tReturnDate).get())->__addObject(
					_c);
		}
	}
}

void cardroid::data::zerocice::TripTyp::__gcClear() {
	if (fromPlace) {
		if (::cardroid::data::zerocice::upCast(fromPlace.get())->__usesGC()) {
			::cardroid::data::zerocice::upCast(fromPlace.get())->__decRefUnsafe();
			fromPlace.__clearHandleUnsafe();
		} else {
			fromPlace = 0;
		}
	}
	if (toPlace) {
		if (::cardroid::data::zerocice::upCast(toPlace.get())->__usesGC()) {
			::cardroid::data::zerocice::upCast(toPlace.get())->__decRefUnsafe();
			toPlace.__clearHandleUnsafe();
		} else {
			toPlace = 0;
		}
	}
	if (tDate) {
		if (::cardroid::data::zerocice::upCast(tDate.get())->__usesGC()) {
			::cardroid::data::zerocice::upCast(tDate.get())->__decRefUnsafe();
			tDate.__clearHandleUnsafe();
		} else {
			tDate = 0;
		}
	}
	if (tReturnDate) {
		if ((*tReturnDate)) {
			if (::cardroid::data::zerocice::upCast((*tReturnDate).get())->__usesGC()) {
				::cardroid::data::zerocice::upCast((*tReturnDate).get())->__decRefUnsafe();
				(*tReturnDate).__clearHandleUnsafe();
			} else {
				(*tReturnDate) = 0;
			}
		}
	}
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___getTripId(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getTripId(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___setTripId(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int tripId;
	__is->read(tripId);
	__inS.endReadParams();
	setTripId(tripId, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___getPlace1(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::PlaceTypPtr __ret = getPlace1(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__os->writePendingObjects();
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___setPlace1(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::PlaceTypPtr fromPlace;
	__is->read(fromPlace);
	__is->readPendingObjects();
	__inS.endReadParams();
	setPlace1(fromPlace, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___getPlace2(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::PlaceTypPtr __ret = getPlace2(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__os->writePendingObjects();
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___setPlace2(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::PlaceTypPtr toPlace;
	__is->read(toPlace);
	__is->readPendingObjects();
	__inS.endReadParams();
	setPlace2(toPlace, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___getTripDate(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::DateTypPtr __ret = getTripDate(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__os->writePendingObjects();
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___setTripDate(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::DateTypPtr tripDate;
	__is->read(tripDate);
	__is->readPendingObjects();
	__inS.endReadParams();
	setTripDate(tripDate, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___getNSeats(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getNSeats(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___setNSeats(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int nSeats;
	__is->read(nSeats);
	__inS.endReadParams();
	setNSeats(nSeats, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___getTripReturnDate(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::DateTypPtr __ret = getTripReturnDate(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__os->writePendingObjects();
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___setTripReturnDate(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::DateTypPtr tripReturnDate;
	__is->read(tripReturnDate);
	__is->readPendingObjects();
	__inS.endReadParams();
	setTripReturnDate(tripReturnDate, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___hasTripReturnDate(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	bool __ret = hasTripReturnDate(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___getTripWeekDays(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::WeekdaysV __ret = getTripWeekDays(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___getTripPeriodicity(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::Periodicity __ret = getTripPeriodicity(
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___setTripWeekDaysPeriodicity(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::WeekdaysV tripWeekDays;
	::cardroid::data::zerocice::Periodicity tripPeriodicity;
	__is->read(tripWeekDays);
	__is->read(tripPeriodicity);
	__inS.endReadParams();
	setTripWeekDaysPeriodicity(tripWeekDays, tripPeriodicity, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___hasWeekDaysPeriodicity(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	bool __ret = hasWeekDaysPeriodicity(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___getDistance(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getDistance(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___setDistance(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int distance;
	__is->read(distance);
	__inS.endReadParams();
	setDistance(distance, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___hasDistance(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	bool __ret = hasDistance(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___getCharacteristics(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = getCharacteristics(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___setCharacteristics(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string characteristics;
	__is->read(characteristics);
	__inS.endReadParams();
	setCharacteristics(characteristics, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___hasCharacteristics(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	bool __ret = hasCharacteristics(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___setTripType(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int type;
	__is->read(type);
	__inS.endReadParams();
	setTripType(type, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___getTripType(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getTripType(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::___toString(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = toString(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__data__zerocice__TripTyp_all[] = {
		"getCharacteristics", "getDistance", "getNSeats", "getPlace1",
		"getPlace2", "getTripDate", "getTripId", "getTripPeriodicity",
		"getTripReturnDate", "getTripType", "getTripWeekDays",
		"hasCharacteristics", "hasDistance", "hasTripReturnDate",
		"hasWeekDaysPeriodicity", "ice_id", "ice_ids", "ice_isA", "ice_ping",
		"setCharacteristics", "setDistance", "setNSeats", "setPlace1",
		"setPlace2", "setTripDate", "setTripId", "setTripReturnDate",
		"setTripType", "setTripWeekDaysPeriodicity", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::TripTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__TripTyp_all,
					__cardroid__data__zerocice__TripTyp_all + 30,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__TripTyp_all) {
	case 0: {
		return ___getCharacteristics(in, current);
	}
	case 1: {
		return ___getDistance(in, current);
	}
	case 2: {
		return ___getNSeats(in, current);
	}
	case 3: {
		return ___getPlace1(in, current);
	}
	case 4: {
		return ___getPlace2(in, current);
	}
	case 5: {
		return ___getTripDate(in, current);
	}
	case 6: {
		return ___getTripId(in, current);
	}
	case 7: {
		return ___getTripPeriodicity(in, current);
	}
	case 8: {
		return ___getTripReturnDate(in, current);
	}
	case 9: {
		return ___getTripType(in, current);
	}
	case 10: {
		return ___getTripWeekDays(in, current);
	}
	case 11: {
		return ___hasCharacteristics(in, current);
	}
	case 12: {
		return ___hasDistance(in, current);
	}
	case 13: {
		return ___hasTripReturnDate(in, current);
	}
	case 14: {
		return ___hasWeekDaysPeriodicity(in, current);
	}
	case 15: {
		return ___ice_id(in, current);
	}
	case 16: {
		return ___ice_ids(in, current);
	}
	case 17: {
		return ___ice_isA(in, current);
	}
	case 18: {
		return ___ice_ping(in, current);
	}
	case 19: {
		return ___setCharacteristics(in, current);
	}
	case 20: {
		return ___setDistance(in, current);
	}
	case 21: {
		return ___setNSeats(in, current);
	}
	case 22: {
		return ___setPlace1(in, current);
	}
	case 23: {
		return ___setPlace2(in, current);
	}
	case 24: {
		return ___setTripDate(in, current);
	}
	case 25: {
		return ___setTripId(in, current);
	}
	case 26: {
		return ___setTripReturnDate(in, current);
	}
	case 27: {
		return ___setTripType(in, current);
	}
	case 28: {
		return ___setTripWeekDaysPeriodicity(in, current);
	}
	case 29: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::TripTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->write(tripId);
	__os->write(fromPlace);
	__os->write(toPlace);
	__os->write(tDate);
	__os->write(nSeats);
	__os->write(tripType);
	__os->write(6, tReturnDate);
	__os->write(7, tWeekDays);
	__os->write(8, tPeriodicity);
	__os->write(9, tripDistance);
	__os->write(10, tripCharacteristics);
	__os->endWriteSlice();
}

void cardroid::data::zerocice::TripTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(tripId);
	__is->read(fromPlace);
	__is->read(toPlace);
	__is->read(tDate);
	__is->read(nSeats);
	__is->read(tripType);
	__is->read(6, tReturnDate);
	__is->read(7, tWeekDays);
	__is->read(8, tPeriodicity);
	__is->read(9, tripDistance);
	__is->read(10, tripCharacteristics);
	__is->endReadSlice();
}

void cardroid::data::zerocice::__patch(TripTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::TripTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::TripTyp::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::WaypointTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::WaypointTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__WaypointTyp_ids[2] = {
		"::Ice::Object", "::cardroid::data::zerocice::WaypointTyp" };

}

bool cardroid::data::zerocice::WaypointTyp::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__data__zerocice__WaypointTyp_ids,
			__cardroid__data__zerocice__WaypointTyp_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::WaypointTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__WaypointTyp_ids[0],
			&__cardroid__data__zerocice__WaypointTyp_ids[2]);
}

const ::std::string&
cardroid::data::zerocice::WaypointTyp::ice_id(const ::Ice::Current&) const {
	return __cardroid__data__zerocice__WaypointTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::WaypointTyp::ice_staticId() {
	return __cardroid__data__zerocice__WaypointTyp_ids[1];
}

void cardroid::data::zerocice::WaypointTyp::__addObject(
		::IceInternal::GCCountMap& _c) {
	::IceInternal::GCCountMap::iterator pos = _c.find(this);
	if (pos == _c.end()) {
		_c[this] = 1;
	} else {
		++pos->second;
	}
}

bool cardroid::data::zerocice::WaypointTyp::__usesGC() {
	return true;
}

void cardroid::data::zerocice::WaypointTyp::__gcReachable(
		::IceInternal::GCCountMap& _c) const {
	if (waypointPlace) {
		::cardroid::data::zerocice::upCast(waypointPlace.get())->__addObject(
				_c);
	}
}

void cardroid::data::zerocice::WaypointTyp::__gcClear() {
	if (waypointPlace) {
		if (::cardroid::data::zerocice::upCast(waypointPlace.get())->__usesGC()) {
			::cardroid::data::zerocice::upCast(waypointPlace.get())->__decRefUnsafe();
			waypointPlace.__clearHandleUnsafe();
		} else {
			waypointPlace = 0;
		}
	}
}

::Ice::DispatchStatus cardroid::data::zerocice::WaypointTyp::___getNOrder(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getNOrder(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::WaypointTyp::___setNOrder(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int nOrder;
	__is->read(nOrder);
	__inS.endReadParams();
	setNOrder(nOrder, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::WaypointTyp::___getWaypointPlace(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::PlaceTypPtr __ret = getWaypointPlace(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__os->writePendingObjects();
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::WaypointTyp::___setWaypointPlace(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::PlaceTypPtr waypointPlace;
	__is->read(waypointPlace);
	__is->readPendingObjects();
	__inS.endReadParams();
	setWaypointPlace(waypointPlace, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::WaypointTyp::___toString(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = toString(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__data__zerocice__WaypointTyp_all[] = {
		"getNOrder", "getWaypointPlace", "ice_id", "ice_ids", "ice_isA",
		"ice_ping", "setNOrder", "setWaypointPlace", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::WaypointTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__WaypointTyp_all,
					__cardroid__data__zerocice__WaypointTyp_all + 9,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__WaypointTyp_all) {
	case 0: {
		return ___getNOrder(in, current);
	}
	case 1: {
		return ___getWaypointPlace(in, current);
	}
	case 2: {
		return ___ice_id(in, current);
	}
	case 3: {
		return ___ice_ids(in, current);
	}
	case 4: {
		return ___ice_isA(in, current);
	}
	case 5: {
		return ___ice_ping(in, current);
	}
	case 6: {
		return ___setNOrder(in, current);
	}
	case 7: {
		return ___setWaypointPlace(in, current);
	}
	case 8: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::WaypointTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->write(nOrder);
	__os->write(waypointPlace);
	__os->endWriteSlice();
}

void cardroid::data::zerocice::WaypointTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(nOrder);
	__is->read(waypointPlace);
	__is->endReadSlice();
}

void cardroid::data::zerocice::__patch(WaypointTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::WaypointTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::WaypointTyp::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::PassengerTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::PassengerTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__PassengerTyp_ids[2] = {
		"::Ice::Object", "::cardroid::data::zerocice::PassengerTyp" };

}

bool cardroid::data::zerocice::PassengerTyp::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__data__zerocice__PassengerTyp_ids,
			__cardroid__data__zerocice__PassengerTyp_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::PassengerTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__PassengerTyp_ids[0],
			&__cardroid__data__zerocice__PassengerTyp_ids[2]);
}

const ::std::string&
cardroid::data::zerocice::PassengerTyp::ice_id(const ::Ice::Current&) const {
	return __cardroid__data__zerocice__PassengerTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::PassengerTyp::ice_staticId() {
	return __cardroid__data__zerocice__PassengerTyp_ids[1];
}

::Ice::DispatchStatus cardroid::data::zerocice::PassengerTyp::___getPassengerUser(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::UserTypPrx __ret = getPassengerUser(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PassengerTyp::___setPassengerUser(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx passengerUser;
	__is->read(passengerUser);
	__inS.endReadParams();
	setPassengerUser(passengerUser, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PassengerTyp::___getNSeats(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getNSeats(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PassengerTyp::___setNSeats(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int nSeats;
	__is->read(nSeats);
	__inS.endReadParams();
	setNSeats(nSeats, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::PassengerTyp::___toString(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = toString(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__data__zerocice__PassengerTyp_all[] = {
		"getNSeats", "getPassengerUser", "ice_id", "ice_ids", "ice_isA",
		"ice_ping", "setNSeats", "setPassengerUser", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::PassengerTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__PassengerTyp_all,
					__cardroid__data__zerocice__PassengerTyp_all + 9,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__PassengerTyp_all) {
	case 0: {
		return ___getNSeats(in, current);
	}
	case 1: {
		return ___getPassengerUser(in, current);
	}
	case 2: {
		return ___ice_id(in, current);
	}
	case 3: {
		return ___ice_ids(in, current);
	}
	case 4: {
		return ___ice_isA(in, current);
	}
	case 5: {
		return ___ice_ping(in, current);
	}
	case 6: {
		return ___setNSeats(in, current);
	}
	case 7: {
		return ___setPassengerUser(in, current);
	}
	case 8: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::PassengerTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->write(passengerUser);
	__os->write(nSeats);
	__os->endWriteSlice();
}

void cardroid::data::zerocice::PassengerTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(passengerUser);
	__is->read(nSeats);
	__is->endReadSlice();
}

void cardroid::data::zerocice::__patch(PassengerTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::PassengerTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::PassengerTyp::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::TripOfferTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::TripOfferTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__TripOfferTyp_ids[3] = {
		"::Ice::Object", "::cardroid::data::zerocice::TripOfferTyp",
		"::cardroid::data::zerocice::TripTyp" };

}

bool cardroid::data::zerocice::TripOfferTyp::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__data__zerocice__TripOfferTyp_ids,
			__cardroid__data__zerocice__TripOfferTyp_ids + 3, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::TripOfferTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__TripOfferTyp_ids[0],
			&__cardroid__data__zerocice__TripOfferTyp_ids[3]);
}

const ::std::string&
cardroid::data::zerocice::TripOfferTyp::ice_id(const ::Ice::Current&) const {
	return __cardroid__data__zerocice__TripOfferTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::TripOfferTyp::ice_staticId() {
	return __cardroid__data__zerocice__TripOfferTyp_ids[1];
}

void cardroid::data::zerocice::TripOfferTyp::__gcReachable(
		::IceInternal::GCCountMap& _c) const {
	::cardroid::data::zerocice::TripTyp::__gcReachable(_c);
	{
		for (::cardroid::data::zerocice::WaypointCollection::const_iterator _i0 =
				waypoints.begin(); _i0 != waypoints.end(); ++_i0) {
			if ((*_i0)) {
				::cardroid::data::zerocice::upCast((*_i0).get())->__addObject(
						_c);
			}
		}
	}
	{
		for (::cardroid::data::zerocice::PassengerCollection::const_iterator _i0 =
				passengers.begin(); _i0 != passengers.end(); ++_i0) {
			if ((*_i0)) {
				::cardroid::data::zerocice::upCast((*_i0).get())->__addObject(
						_c);
			}
		}
	}
	if (tDateTime) {
		::cardroid::data::zerocice::upCast(tDateTime.get())->__addObject(_c);
	}
	if (tReturnDateTime) {
		if ((*tReturnDateTime)) {
			::cardroid::data::zerocice::upCast((*tReturnDateTime).get())->__addObject(
					_c);
		}
	}
}

void cardroid::data::zerocice::TripOfferTyp::__gcClear() {
	::cardroid::data::zerocice::TripTyp::__gcClear();
	{
		for (::cardroid::data::zerocice::WaypointCollection::iterator _i0 =
				waypoints.begin(); _i0 != waypoints.end(); ++_i0) {
			if ((*_i0)) {
				if (::cardroid::data::zerocice::upCast((*_i0).get())->__usesGC()) {
					::cardroid::data::zerocice::upCast((*_i0).get())->__decRefUnsafe();
					(*_i0).__clearHandleUnsafe();
				} else {
					(*_i0) = 0;
				}
			}
		}
	}
	{
		for (::cardroid::data::zerocice::PassengerCollection::iterator _i0 =
				passengers.begin(); _i0 != passengers.end(); ++_i0) {
			if ((*_i0)) {
				if (::cardroid::data::zerocice::upCast((*_i0).get())->__usesGC()) {
					::cardroid::data::zerocice::upCast((*_i0).get())->__decRefUnsafe();
					(*_i0).__clearHandleUnsafe();
				} else {
					(*_i0) = 0;
				}
			}
		}
	}
	if (tDateTime) {
		if (::cardroid::data::zerocice::upCast(tDateTime.get())->__usesGC()) {
			::cardroid::data::zerocice::upCast(tDateTime.get())->__decRefUnsafe();
			tDateTime.__clearHandleUnsafe();
		} else {
			tDateTime = 0;
		}
	}
	if (tReturnDateTime) {
		if ((*tReturnDateTime)) {
			if (::cardroid::data::zerocice::upCast((*tReturnDateTime).get())->__usesGC()) {
				::cardroid::data::zerocice::upCast((*tReturnDateTime).get())->__decRefUnsafe();
				(*tReturnDateTime).__clearHandleUnsafe();
			} else {
				(*tReturnDateTime) = 0;
			}
		}
	}
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___getTripDateTime(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::DateTimeTypPtr __ret = getTripDateTime(
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__os->writePendingObjects();
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___setTripDateTime(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::DateTimeTypPtr dt;
	__is->read(dt);
	__is->readPendingObjects();
	__inS.endReadParams();
	setTripDateTime(dt, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___getTripReturnDateTime(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::DateTimeTypPtr __ret = getTripReturnDateTime(
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__os->writePendingObjects();
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___setTripReturnDateTime(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::DateTimeTypPtr rdt;
	__is->read(rdt);
	__is->readPendingObjects();
	__inS.endReadParams();
	setTripReturnDateTime(rdt, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___getTripDriver(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::UserTypPrx __ret = getTripDriver(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___setTripDriver(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx driver;
	__is->read(driver);
	__inS.endReadParams();
	setTripDriver(driver, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___getTripWaypoints(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::WaypointCollection __ret = getTripWaypoints(
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__os->writePendingObjects();
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___setTripWaypoints(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::WaypointCollection waypoints;
	__is->read(waypoints);
	__is->readPendingObjects();
	__inS.endReadParams();
	setTripWaypoints(waypoints, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___getTripCar(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::CarTypPrx __ret = getTripCar(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___setTripCar(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::CarTypPrx tripCar;
	__is->read(tripCar);
	__inS.endReadParams();
	setTripCar(tripCar, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___getTripPassengers(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::PassengerCollection __ret = getTripPassengers(
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__os->writePendingObjects();
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___setTripPassengers(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::PassengerCollection passengers;
	__is->read(passengers);
	__is->readPendingObjects();
	__inS.endReadParams();
	setTripPassengers(passengers, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___getPrice(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Double __ret = getPrice(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___setPrice(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Double price;
	__is->read(price);
	__inS.endReadParams();
	setPrice(price, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___getAllowedFeatures(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::AllowedV __ret = getAllowedFeatures(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___setAllowedFeatures(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::AllowedV allowed;
	__is->read(allowed);
	__inS.endReadParams();
	setAllowedFeatures(allowed, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___addTripWaypoint(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::PlaceTypPtr waypoint;
	__is->read(waypoint);
	__is->readPendingObjects();
	__inS.endReadParams();
	bool __ret = addTripWaypoint(waypoint, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___removeTripWaypoint(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int pos;
	__is->read(pos);
	__inS.endReadParams();
	bool __ret = removeTripWaypoint(pos, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___getNTripWaypoints(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getNTripWaypoints(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___clearTripWaypoints(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	clearTripWaypoints(__current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___addTripPassenger(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx passenger;
	::Ice::Int seats;
	__is->read(passenger);
	__is->read(seats);
	__inS.endReadParams();
	bool __ret = addTripPassenger(passenger, seats, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___removeTripPassenger(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx passenger;
	__is->read(passenger);
	__inS.endReadParams();
	bool __ret = removeTripPassenger(passenger, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___getNTripPassengers(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Int __ret = getNTripPassengers(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::___clearTripPassengers(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	clearTripPassengers(__current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__data__zerocice__TripOfferTyp_all[] = {
		"addTripPassenger", "addTripWaypoint", "clearTripPassengers",
		"clearTripWaypoints", "getAllowedFeatures", "getCharacteristics",
		"getDistance", "getNSeats", "getNTripPassengers", "getNTripWaypoints",
		"getPlace1", "getPlace2", "getPrice", "getTripCar", "getTripDate",
		"getTripDateTime", "getTripDriver", "getTripId", "getTripPassengers",
		"getTripPeriodicity", "getTripReturnDate", "getTripReturnDateTime",
		"getTripType", "getTripWaypoints", "getTripWeekDays",
		"hasCharacteristics", "hasDistance", "hasTripReturnDate",
		"hasWeekDaysPeriodicity", "ice_id", "ice_ids", "ice_isA", "ice_ping",
		"removeTripPassenger", "removeTripWaypoint", "setAllowedFeatures",
		"setCharacteristics", "setDistance", "setNSeats", "setPlace1",
		"setPlace2", "setPrice", "setTripCar", "setTripDate", "setTripDateTime",
		"setTripDriver", "setTripId", "setTripPassengers", "setTripReturnDate",
		"setTripReturnDateTime", "setTripType", "setTripWaypoints",
		"setTripWeekDaysPeriodicity", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::TripOfferTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__TripOfferTyp_all,
					__cardroid__data__zerocice__TripOfferTyp_all + 54,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__TripOfferTyp_all) {
	case 0: {
		return ___addTripPassenger(in, current);
	}
	case 1: {
		return ___addTripWaypoint(in, current);
	}
	case 2: {
		return ___clearTripPassengers(in, current);
	}
	case 3: {
		return ___clearTripWaypoints(in, current);
	}
	case 4: {
		return ___getAllowedFeatures(in, current);
	}
	case 5: {
		return ___getCharacteristics(in, current);
	}
	case 6: {
		return ___getDistance(in, current);
	}
	case 7: {
		return ___getNSeats(in, current);
	}
	case 8: {
		return ___getNTripPassengers(in, current);
	}
	case 9: {
		return ___getNTripWaypoints(in, current);
	}
	case 10: {
		return ___getPlace1(in, current);
	}
	case 11: {
		return ___getPlace2(in, current);
	}
	case 12: {
		return ___getPrice(in, current);
	}
	case 13: {
		return ___getTripCar(in, current);
	}
	case 14: {
		return ___getTripDate(in, current);
	}
	case 15: {
		return ___getTripDateTime(in, current);
	}
	case 16: {
		return ___getTripDriver(in, current);
	}
	case 17: {
		return ___getTripId(in, current);
	}
	case 18: {
		return ___getTripPassengers(in, current);
	}
	case 19: {
		return ___getTripPeriodicity(in, current);
	}
	case 20: {
		return ___getTripReturnDate(in, current);
	}
	case 21: {
		return ___getTripReturnDateTime(in, current);
	}
	case 22: {
		return ___getTripType(in, current);
	}
	case 23: {
		return ___getTripWaypoints(in, current);
	}
	case 24: {
		return ___getTripWeekDays(in, current);
	}
	case 25: {
		return ___hasCharacteristics(in, current);
	}
	case 26: {
		return ___hasDistance(in, current);
	}
	case 27: {
		return ___hasTripReturnDate(in, current);
	}
	case 28: {
		return ___hasWeekDaysPeriodicity(in, current);
	}
	case 29: {
		return ___ice_id(in, current);
	}
	case 30: {
		return ___ice_ids(in, current);
	}
	case 31: {
		return ___ice_isA(in, current);
	}
	case 32: {
		return ___ice_ping(in, current);
	}
	case 33: {
		return ___removeTripPassenger(in, current);
	}
	case 34: {
		return ___removeTripWaypoint(in, current);
	}
	case 35: {
		return ___setAllowedFeatures(in, current);
	}
	case 36: {
		return ___setCharacteristics(in, current);
	}
	case 37: {
		return ___setDistance(in, current);
	}
	case 38: {
		return ___setNSeats(in, current);
	}
	case 39: {
		return ___setPlace1(in, current);
	}
	case 40: {
		return ___setPlace2(in, current);
	}
	case 41: {
		return ___setPrice(in, current);
	}
	case 42: {
		return ___setTripCar(in, current);
	}
	case 43: {
		return ___setTripDate(in, current);
	}
	case 44: {
		return ___setTripDateTime(in, current);
	}
	case 45: {
		return ___setTripDriver(in, current);
	}
	case 46: {
		return ___setTripId(in, current);
	}
	case 47: {
		return ___setTripPassengers(in, current);
	}
	case 48: {
		return ___setTripReturnDate(in, current);
	}
	case 49: {
		return ___setTripReturnDateTime(in, current);
	}
	case 50: {
		return ___setTripType(in, current);
	}
	case 51: {
		return ___setTripWaypoints(in, current);
	}
	case 52: {
		return ___setTripWeekDaysPeriodicity(in, current);
	}
	case 53: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::TripOfferTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, false);
	__os->write(driver);
	__os->write(waypoints);
	__os->write(tripOfferCar);
	__os->write(passengers);
	__os->write(price);
	__os->write(allowed);
	__os->write(tDateTime);
	__os->write(11, tReturnDateTime);
	__os->endWriteSlice();
	::cardroid::data::zerocice::TripTyp::__writeImpl(__os);
}

void cardroid::data::zerocice::TripOfferTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(driver);
	__is->read(waypoints);
	__is->read(tripOfferCar);
	__is->read(passengers);
	__is->read(price);
	__is->read(allowed);
	__is->read(tDateTime);
	__is->read(11, tReturnDateTime);
	__is->endReadSlice();
	::cardroid::data::zerocice::TripTyp::__readImpl(__is);
}

void cardroid::data::zerocice::__patch(TripOfferTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::TripOfferTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::TripOfferTyp::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::TripRequestTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::TripRequestTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__TripRequestTyp_ids[3] = {
		"::Ice::Object", "::cardroid::data::zerocice::TripRequestTyp",
		"::cardroid::data::zerocice::TripTyp" };

}

bool cardroid::data::zerocice::TripRequestTyp::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__data__zerocice__TripRequestTyp_ids,
			__cardroid__data__zerocice__TripRequestTyp_ids + 3, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::TripRequestTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__TripRequestTyp_ids[0],
			&__cardroid__data__zerocice__TripRequestTyp_ids[3]);
}

const ::std::string&
cardroid::data::zerocice::TripRequestTyp::ice_id(const ::Ice::Current&) const {
	return __cardroid__data__zerocice__TripRequestTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::TripRequestTyp::ice_staticId() {
	return __cardroid__data__zerocice__TripRequestTyp_ids[1];
}

void cardroid::data::zerocice::TripRequestTyp::__gcReachable(
		::IceInternal::GCCountMap& _c) const {
	::cardroid::data::zerocice::TripTyp::__gcReachable(_c);
	if (tDateTimePrefs) {
		::cardroid::data::zerocice::upCast(tDateTimePrefs.get())->__addObject(
				_c);
	}
	if (tReturnDateTimePrefs) {
		if ((*tReturnDateTimePrefs)) {
			::cardroid::data::zerocice::upCast((*tReturnDateTimePrefs).get())->__addObject(
					_c);
		}
	}
}

void cardroid::data::zerocice::TripRequestTyp::__gcClear() {
	::cardroid::data::zerocice::TripTyp::__gcClear();
	if (tDateTimePrefs) {
		if (::cardroid::data::zerocice::upCast(tDateTimePrefs.get())->__usesGC()) {
			::cardroid::data::zerocice::upCast(tDateTimePrefs.get())->__decRefUnsafe();
			tDateTimePrefs.__clearHandleUnsafe();
		} else {
			tDateTimePrefs = 0;
		}
	}
	if (tReturnDateTimePrefs) {
		if ((*tReturnDateTimePrefs)) {
			if (::cardroid::data::zerocice::upCast(
					(*tReturnDateTimePrefs).get())->__usesGC()) {
				::cardroid::data::zerocice::upCast(
						(*tReturnDateTimePrefs).get())->__decRefUnsafe();
				(*tReturnDateTimePrefs).__clearHandleUnsafe();
			} else {
				(*tReturnDateTimePrefs) = 0;
			}
		}
	}
}

::Ice::DispatchStatus cardroid::data::zerocice::TripRequestTyp::___getTripDateTimePrefs(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::DateTimePrefsTypPtr __ret =
			getTripDateTimePrefs(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__os->writePendingObjects();
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripRequestTyp::___setTripDateTimePrefs(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::DateTimePrefsTypPtr dtp;
	__is->read(dtp);
	__is->readPendingObjects();
	__inS.endReadParams();
	setTripDateTimePrefs(dtp, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripRequestTyp::___getTripReturnDateTimePrefs(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::DateTimePrefsTypPtr __ret =
			getTripReturnDateTimePrefs(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__os->writePendingObjects();
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripRequestTyp::___setTripReturnDateTimePrefs(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::DateTimePrefsTypPtr rdtp;
	__is->read(rdtp);
	__is->readPendingObjects();
	__inS.endReadParams();
	setTripReturnDateTimePrefs(rdtp, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripRequestTyp::___getTripRequester(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::UserTypPrx __ret = getTripRequester(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::TripRequestTyp::___setTripRequester(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx requester;
	__is->read(requester);
	__inS.endReadParams();
	setTripRequester(requester, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__data__zerocice__TripRequestTyp_all[] = {
		"getCharacteristics", "getDistance", "getNSeats", "getPlace1",
		"getPlace2", "getTripDate", "getTripDateTimePrefs", "getTripId",
		"getTripPeriodicity", "getTripRequester", "getTripReturnDate",
		"getTripReturnDateTimePrefs", "getTripType", "getTripWeekDays",
		"hasCharacteristics", "hasDistance", "hasTripReturnDate",
		"hasWeekDaysPeriodicity", "ice_id", "ice_ids", "ice_isA", "ice_ping",
		"setCharacteristics", "setDistance", "setNSeats", "setPlace1",
		"setPlace2", "setTripDate", "setTripDateTimePrefs", "setTripId",
		"setTripRequester", "setTripReturnDate", "setTripReturnDateTimePrefs",
		"setTripType", "setTripWeekDaysPeriodicity", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::TripRequestTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__TripRequestTyp_all,
					__cardroid__data__zerocice__TripRequestTyp_all + 36,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__TripRequestTyp_all) {
	case 0: {
		return ___getCharacteristics(in, current);
	}
	case 1: {
		return ___getDistance(in, current);
	}
	case 2: {
		return ___getNSeats(in, current);
	}
	case 3: {
		return ___getPlace1(in, current);
	}
	case 4: {
		return ___getPlace2(in, current);
	}
	case 5: {
		return ___getTripDate(in, current);
	}
	case 6: {
		return ___getTripDateTimePrefs(in, current);
	}
	case 7: {
		return ___getTripId(in, current);
	}
	case 8: {
		return ___getTripPeriodicity(in, current);
	}
	case 9: {
		return ___getTripRequester(in, current);
	}
	case 10: {
		return ___getTripReturnDate(in, current);
	}
	case 11: {
		return ___getTripReturnDateTimePrefs(in, current);
	}
	case 12: {
		return ___getTripType(in, current);
	}
	case 13: {
		return ___getTripWeekDays(in, current);
	}
	case 14: {
		return ___hasCharacteristics(in, current);
	}
	case 15: {
		return ___hasDistance(in, current);
	}
	case 16: {
		return ___hasTripReturnDate(in, current);
	}
	case 17: {
		return ___hasWeekDaysPeriodicity(in, current);
	}
	case 18: {
		return ___ice_id(in, current);
	}
	case 19: {
		return ___ice_ids(in, current);
	}
	case 20: {
		return ___ice_isA(in, current);
	}
	case 21: {
		return ___ice_ping(in, current);
	}
	case 22: {
		return ___setCharacteristics(in, current);
	}
	case 23: {
		return ___setDistance(in, current);
	}
	case 24: {
		return ___setNSeats(in, current);
	}
	case 25: {
		return ___setPlace1(in, current);
	}
	case 26: {
		return ___setPlace2(in, current);
	}
	case 27: {
		return ___setTripDate(in, current);
	}
	case 28: {
		return ___setTripDateTimePrefs(in, current);
	}
	case 29: {
		return ___setTripId(in, current);
	}
	case 30: {
		return ___setTripRequester(in, current);
	}
	case 31: {
		return ___setTripReturnDate(in, current);
	}
	case 32: {
		return ___setTripReturnDateTimePrefs(in, current);
	}
	case 33: {
		return ___setTripType(in, current);
	}
	case 34: {
		return ___setTripWeekDaysPeriodicity(in, current);
	}
	case 35: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::TripRequestTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, false);
	__os->write(requester);
	__os->write(tDateTimePrefs);
	__os->write(11, tReturnDateTimePrefs);
	__os->endWriteSlice();
	::cardroid::data::zerocice::TripTyp::__writeImpl(__os);
}

void cardroid::data::zerocice::TripRequestTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(requester);
	__is->read(tDateTimePrefs);
	__is->read(11, tReturnDateTimePrefs);
	__is->endReadSlice();
	::cardroid::data::zerocice::TripTyp::__readImpl(__is);
}

void cardroid::data::zerocice::__patch(TripRequestTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::TripRequestTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::TripRequestTyp::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::UserActivityTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::UserActivityTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__UserActivityTyp_ids[2] = {
		"::Ice::Object", "::cardroid::data::zerocice::UserActivityTyp" };

}

bool cardroid::data::zerocice::UserActivityTyp::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__data__zerocice__UserActivityTyp_ids,
			__cardroid__data__zerocice__UserActivityTyp_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::UserActivityTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__UserActivityTyp_ids[0],
			&__cardroid__data__zerocice__UserActivityTyp_ids[2]);
}

const ::std::string&
cardroid::data::zerocice::UserActivityTyp::ice_id(const ::Ice::Current&) const {
	return __cardroid__data__zerocice__UserActivityTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::UserActivityTyp::ice_staticId() {
	return __cardroid__data__zerocice__UserActivityTyp_ids[1];
}

::Ice::DispatchStatus cardroid::data::zerocice::UserActivityTyp::___getActivityUser(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::UserTypPrx __ret = getActivityUser(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserActivityTyp::___setActivityUser(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx activityUser;
	__is->read(activityUser);
	__inS.endReadParams();
	setActivityUser(activityUser, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserActivityTyp::___getActivityTrip(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::TripOfferTypPrx __ret = getActivityTrip(
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserActivityTyp::___setActivityTrip(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::TripOfferTypPrx activityTrip;
	__is->read(activityTrip);
	__inS.endReadParams();
	setActivityTrip(activityTrip, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserActivityTyp::___getUserActivityType(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::ActivityType __ret = getUserActivityType(
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserActivityTyp::___setUserActivityType(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::ActivityType userActivityType;
	__is->read(userActivityType);
	__inS.endReadParams();
	setUserActivityType(userActivityType, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserActivityTyp::___getTimeStampInMillis(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Long __ret = getTimeStampInMillis(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserActivityTyp::___setTimeStampInMillis(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Long timeStampMillis;
	__is->read(timeStampMillis);
	__inS.endReadParams();
	setTimeStampInMillis(timeStampMillis, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::UserActivityTyp::___toString(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = toString(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__data__zerocice__UserActivityTyp_all[] = {
		"getActivityTrip", "getActivityUser", "getTimeStampInMillis",
		"getUserActivityType", "ice_id", "ice_ids", "ice_isA", "ice_ping",
		"setActivityTrip", "setActivityUser", "setTimeStampInMillis",
		"setUserActivityType", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::UserActivityTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__UserActivityTyp_all,
					__cardroid__data__zerocice__UserActivityTyp_all + 13,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__UserActivityTyp_all) {
	case 0: {
		return ___getActivityTrip(in, current);
	}
	case 1: {
		return ___getActivityUser(in, current);
	}
	case 2: {
		return ___getTimeStampInMillis(in, current);
	}
	case 3: {
		return ___getUserActivityType(in, current);
	}
	case 4: {
		return ___ice_id(in, current);
	}
	case 5: {
		return ___ice_ids(in, current);
	}
	case 6: {
		return ___ice_isA(in, current);
	}
	case 7: {
		return ___ice_ping(in, current);
	}
	case 8: {
		return ___setActivityTrip(in, current);
	}
	case 9: {
		return ___setActivityUser(in, current);
	}
	case 10: {
		return ___setTimeStampInMillis(in, current);
	}
	case 11: {
		return ___setUserActivityType(in, current);
	}
	case 12: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::UserActivityTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->write(activityUser);
	__os->write(activityTrip);
	__os->write(userActivityType);
	__os->write(timeStamp);
	__os->endWriteSlice();
}

void cardroid::data::zerocice::UserActivityTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(activityUser);
	__is->read(activityTrip);
	__is->read(userActivityType);
	__is->read(timeStamp);
	__is->endReadSlice();
}

void cardroid::data::zerocice::__patch(UserActivityTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::UserActivityTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::UserActivityTyp::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::data::zerocice::upCast(
		::cardroid::data::zerocice::MessageTyp* p) {
	return p;
}
::Ice::ObjectPtr cardroid::data::zerocice::MessageTyp::ice_clone() const {
	throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
	return 0; // to avoid a warning with some compilers
}

namespace {
const ::std::string __cardroid__data__zerocice__MessageTyp_ids[2] = {
		"::Ice::Object", "::cardroid::data::zerocice::MessageTyp" };

}

bool cardroid::data::zerocice::MessageTyp::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__data__zerocice__MessageTyp_ids,
			__cardroid__data__zerocice__MessageTyp_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::data::zerocice::MessageTyp::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__data__zerocice__MessageTyp_ids[0],
			&__cardroid__data__zerocice__MessageTyp_ids[2]);
}

const ::std::string&
cardroid::data::zerocice::MessageTyp::ice_id(const ::Ice::Current&) const {
	return __cardroid__data__zerocice__MessageTyp_ids[1];
}

const ::std::string&
cardroid::data::zerocice::MessageTyp::ice_staticId() {
	return __cardroid__data__zerocice__MessageTyp_ids[1];
}

::Ice::DispatchStatus cardroid::data::zerocice::MessageTyp::___getUser1(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::UserTypPrx __ret = getUser1(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::MessageTyp::___setUser1(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx user1;
	__is->read(user1);
	__inS.endReadParams();
	setUser1(user1, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::MessageTyp::___getUser2(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::cardroid::data::zerocice::UserTypPrx __ret = getUser2(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::MessageTyp::___setUser2(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx user2;
	__is->read(user2);
	__inS.endReadParams();
	setUser2(user2, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::MessageTyp::___getMessageText(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = getMessageText(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::MessageTyp::___setMessageText(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string msg;
	__is->read(msg);
	__inS.endReadParams();
	setMessageText(msg, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::MessageTyp::___getTimeStampInMillis(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Long __ret = getTimeStampInMillis(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::MessageTyp::___setTimeStampInMillis(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Long timeStampMillis;
	__is->read(timeStampMillis);
	__inS.endReadParams();
	setTimeStampInMillis(timeStampMillis, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::data::zerocice::MessageTyp::___toString(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::std::string __ret = toString(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__data__zerocice__MessageTyp_all[] = {
		"getMessageText", "getTimeStampInMillis", "getUser1", "getUser2",
		"ice_id", "ice_ids", "ice_isA", "ice_ping", "setMessageText",
		"setTimeStampInMillis", "setUser1", "setUser2", "toString" };

}

::Ice::DispatchStatus cardroid::data::zerocice::MessageTyp::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__data__zerocice__MessageTyp_all,
					__cardroid__data__zerocice__MessageTyp_all + 13,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__data__zerocice__MessageTyp_all) {
	case 0: {
		return ___getMessageText(in, current);
	}
	case 1: {
		return ___getTimeStampInMillis(in, current);
	}
	case 2: {
		return ___getUser1(in, current);
	}
	case 3: {
		return ___getUser2(in, current);
	}
	case 4: {
		return ___ice_id(in, current);
	}
	case 5: {
		return ___ice_ids(in, current);
	}
	case 6: {
		return ___ice_isA(in, current);
	}
	case 7: {
		return ___ice_ping(in, current);
	}
	case 8: {
		return ___setMessageText(in, current);
	}
	case 9: {
		return ___setTimeStampInMillis(in, current);
	}
	case 10: {
		return ___setUser1(in, current);
	}
	case 11: {
		return ___setUser2(in, current);
	}
	case 12: {
		return ___toString(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::data::zerocice::MessageTyp::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->write(user1);
	__os->write(user2);
	__os->write(msg);
	__os->write(timeStamp);
	__os->endWriteSlice();
}

void cardroid::data::zerocice::MessageTyp::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(user1);
	__is->read(user2);
	__is->read(msg);
	__is->read(timeStamp);
	__is->endReadSlice();
}

void cardroid::data::zerocice::__patch(MessageTypPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::data::zerocice::MessageTypPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::data::zerocice::MessageTyp::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::upCast(::cardroid::QueryResult* p) {
	return p;
}

namespace {
const ::std::string __cardroid__QueryResult_ids[2] = { "::Ice::Object",
		"::cardroid::QueryResult" };

}

bool cardroid::QueryResult::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__QueryResult_ids,
			__cardroid__QueryResult_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::QueryResult::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(&__cardroid__QueryResult_ids[0],
			&__cardroid__QueryResult_ids[2]);
}

const ::std::string&
cardroid::QueryResult::ice_id(const ::Ice::Current&) const {
	return __cardroid__QueryResult_ids[1];
}

const ::std::string&
cardroid::QueryResult::ice_staticId() {
	return __cardroid__QueryResult_ids[1];
}

::Ice::DispatchStatus cardroid::QueryResult::___next(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int n;
	__is->read(n);
	__inS.endReadParams();
	bool destroyed;
	::cardroid::ResultSeq __ret = next(n, destroyed, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(destroyed);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::QueryResult::___destroy(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	__inS.readEmptyParams();
	destroy(__current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__QueryResult_all[] = { "destroy", "ice_id",
		"ice_ids", "ice_isA", "ice_ping", "next" };

}

::Ice::DispatchStatus cardroid::QueryResult::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__QueryResult_all,
					__cardroid__QueryResult_all + 6, current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__QueryResult_all) {
	case 0: {
		return ___destroy(in, current);
	}
	case 1: {
		return ___ice_id(in, current);
	}
	case 2: {
		return ___ice_ids(in, current);
	}
	case 3: {
		return ___ice_isA(in, current);
	}
	case 4: {
		return ___ice_ping(in, current);
	}
	case 5: {
		return ___next(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::QueryResult::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->endWriteSlice();
}

void cardroid::QueryResult::__readImpl(::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->endReadSlice();
}

void cardroid::__patch(QueryResultPtr& handle, const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::QueryResultPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(::cardroid::QueryResult::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::zerocice::upCast(
		::cardroid::zerocice::CardroidManager* p) {
	return p;
}

namespace {
const ::std::string __cardroid__zerocice__CardroidManager_ids[2] = {
		"::Ice::Object", "::cardroid::zerocice::CardroidManager" };

}

bool cardroid::zerocice::CardroidManager::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__zerocice__CardroidManager_ids,
			__cardroid__zerocice__CardroidManager_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::zerocice::CardroidManager::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__zerocice__CardroidManager_ids[0],
			&__cardroid__zerocice__CardroidManager_ids[2]);
}

const ::std::string&
cardroid::zerocice::CardroidManager::ice_id(const ::Ice::Current&) const {
	return __cardroid__zerocice__CardroidManager_ids[1];
}

const ::std::string&
cardroid::zerocice::CardroidManager::ice_staticId() {
	return __cardroid__zerocice__CardroidManager_ids[1];
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___getUserPlaces(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx usr;
	::Ice::Int n;
	__is->read(usr);
	__is->read(n);
	__inS.endReadParams();
	::cardroid::ResultSeq first;
	::Ice::Int nrows;
	::cardroid::QueryResultPrx result;
	getUserPlaces(usr, n, first, nrows, result, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(first);
	__os->write(nrows);
	__os->write(result);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___searchTrips(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::TripRequestTypPtr tRequest;
	::Ice::Int n;
	__is->read(tRequest);
	__is->read(n);
	__is->readPendingObjects();
	__inS.endReadParams();
	::cardroid::ResultSeq first;
	::Ice::Int nrows;
	::cardroid::QueryResultPrx result;
	searchTrips(tRequest, n, first, nrows, result, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(first);
	__os->write(nrows);
	__os->write(result);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___getTripFromId(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int tripId;
	__is->read(tripId);
	__inS.endReadParams();
	::cardroid::data::zerocice::TripTypPrx __ret = getTripFromId(tripId,
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___getTripOfferFromId(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int tripId;
	__is->read(tripId);
	__inS.endReadParams();
	::cardroid::data::zerocice::TripOfferTypPrx __ret = getTripOfferFromId(
			tripId, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___getTripRequestFromId(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::Ice::Int tripId;
	__is->read(tripId);
	__inS.endReadParams();
	::cardroid::data::zerocice::TripRequestTypPrx __ret = getTripRequestFromId(
			tripId, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___joinTrip(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::TripOfferTypPrx trip;
	::cardroid::data::zerocice::UserTypPrx passenger;
	::Ice::Int nSeats;
	__is->read(trip);
	__is->read(passenger);
	__is->read(nSeats);
	__inS.endReadParams();
	joinTrip(trip, passenger, nSeats, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___organizeTrip(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::TripRequestTypPrx tripRequest;
	::cardroid::data::zerocice::TripOfferTypPtr tripOffer;
	__is->read(tripRequest);
	__is->read(tripOffer);
	__is->readPendingObjects();
	__inS.endReadParams();
	::cardroid::data::zerocice::TripOfferTypPrx __ret = organizeTrip(
			tripRequest, tripOffer, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___getUserTrips(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx usr;
	::Ice::Int n;
	__is->read(usr);
	__is->read(n);
	__inS.endReadParams();
	::cardroid::ResultSeq first;
	::Ice::Int nrows;
	::cardroid::QueryResultPrx result;
	getUserTrips(usr, n, first, nrows, result, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(first);
	__os->write(nrows);
	__os->write(result);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___getPassengerTrips(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx passenger;
	::Ice::Int n;
	__is->read(passenger);
	__is->read(n);
	__inS.endReadParams();
	::cardroid::ResultSeq first;
	::Ice::Int nrows;
	::cardroid::QueryResultPrx result;
	getPassengerTrips(passenger, n, first, nrows, result, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(first);
	__os->write(nrows);
	__os->write(result);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___userTripRegistered(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx usr;
	::cardroid::data::zerocice::TripTypPrx trip;
	__is->read(usr);
	__is->read(trip);
	__inS.endReadParams();
	bool __ret = userTripRegistered(usr, trip, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___calculatePriceEstimation(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::Fuel f;
	::Ice::Int distance;
	__is->read(f);
	__is->read(distance);
	__inS.endReadParams();
	::Ice::Double __ret = calculatePriceEstimation(f, distance, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___newTripOffer(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::TripOfferTypPtr tOffer;
	__is->read(tOffer);
	__is->readPendingObjects();
	__inS.endReadParams();
	::cardroid::data::zerocice::TripOfferTypPrx __ret = newTripOffer(tOffer,
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___newTripRequest(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::TripRequestTypPtr tRequest;
	__is->read(tRequest);
	__is->readPendingObjects();
	__inS.endReadParams();
	::cardroid::data::zerocice::TripRequestTypPrx __ret = newTripRequest(
			tRequest, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___getMessageTalksSpeakers(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx usr;
	::Ice::Int n;
	__is->read(usr);
	__is->read(n);
	__inS.endReadParams();
	::cardroid::ResultSeq first;
	::Ice::Int nrows;
	::cardroid::QueryResultPrx result;
	getMessageTalksSpeakers(usr, n, first, nrows, result, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(first);
	__os->write(nrows);
	__os->write(result);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___getMessageTalks(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx usr1;
	::cardroid::data::zerocice::UserTypPrx usr2;
	::Ice::Int n;
	__is->read(usr1);
	__is->read(usr2);
	__is->read(n);
	__inS.endReadParams();
	::cardroid::ResultSeq first;
	::Ice::Int nrows;
	::cardroid::QueryResultPrx result;
	getMessageTalks(usr1, usr2, n, first, nrows, result, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(first);
	__os->write(nrows);
	__os->write(result);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___newMessage(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx usr1;
	::cardroid::data::zerocice::UserTypPrx usr2;
	::std::string message;
	__is->read(usr1);
	__is->read(usr2);
	__is->read(message);
	__inS.endReadParams();
	::cardroid::data::zerocice::MessageTypPrx __ret = newMessage(usr1, usr2,
			message, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___getUserActivity(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPrx usr;
	::Ice::Int n;
	__is->read(usr);
	__is->read(n);
	__inS.endReadParams();
	::cardroid::ResultSeq first;
	::Ice::Int nrows;
	::cardroid::QueryResultPrx result;
	getUserActivity(usr, n, first, nrows, result, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(first);
	__os->write(nrows);
	__os->write(result);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___getUserFromEmail(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string email;
	__is->read(email);
	__inS.endReadParams();
	::cardroid::data::zerocice::UserTypPrx __ret = getUserFromEmail(email,
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___getCarFromPlate(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string plate;
	::cardroid::data::zerocice::UserTypPrx owner;
	__is->read(plate);
	__is->read(owner);
	__inS.endReadParams();
	::cardroid::data::zerocice::CarTypPrx __ret = getCarFromPlate(plate, owner,
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___getCarFromPlateEmail(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string plate;
	::std::string ownerEmail;
	__is->read(plate);
	__is->read(ownerEmail);
	__inS.endReadParams();
	::cardroid::data::zerocice::CarTypPrx __ret = getCarFromPlateEmail(plate,
			ownerEmail, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___updateUserData(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPtr usr;
	__is->read(usr);
	__is->readPendingObjects();
	__inS.endReadParams();
	::cardroid::data::zerocice::UserTypPrx __ret = updateUserData(usr,
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___updateCarData(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::CarTypPtr car;
	::cardroid::data::zerocice::UserTypPtr usr;
	__is->read(car);
	__is->read(usr);
	__is->readPendingObjects();
	__inS.endReadParams();
	::cardroid::data::zerocice::CarTypPrx __ret = updateCarData(car, usr,
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___updateCarDataEmail(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::CarTypPtr car;
	::std::string usrEmail;
	__is->read(car);
	__is->read(usrEmail);
	__is->readPendingObjects();
	__inS.endReadParams();
	::cardroid::data::zerocice::CarTypPrx __ret = updateCarDataEmail(car,
			usrEmail, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___addCar(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::CarTypPtr car;
	::cardroid::data::zerocice::UserTypPrx usr;
	__is->read(car);
	__is->read(usr);
	__is->readPendingObjects();
	__inS.endReadParams();
	::cardroid::data::zerocice::CarTypPrx __ret = addCar(car, usr, __current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___addCarEmail(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::CarTypPtr car;
	::std::string usrEmail;
	__is->read(car);
	__is->read(usrEmail);
	__is->readPendingObjects();
	__inS.endReadParams();
	::cardroid::data::zerocice::CarTypPrx __ret = addCarEmail(car, usrEmail,
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___removeCar(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::CarTypPrx car;
	::cardroid::data::zerocice::UserTypPrx usr;
	__is->read(car);
	__is->read(usr);
	__inS.endReadParams();
	removeCar(car, usr, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::___removeCarPlateEmail(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::std::string plate;
	::std::string ownerEmail;
	__is->read(plate);
	__is->read(ownerEmail);
	__inS.endReadParams();
	removeCarPlateEmail(plate, ownerEmail, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__zerocice__CardroidManager_all[] = { "addCar",
		"addCarEmail", "calculatePriceEstimation", "getCarFromPlate",
		"getCarFromPlateEmail", "getMessageTalks", "getMessageTalksSpeakers",
		"getPassengerTrips", "getTripFromId", "getTripOfferFromId",
		"getTripRequestFromId", "getUserActivity", "getUserFromEmail",
		"getUserPlaces", "getUserTrips", "ice_id", "ice_ids", "ice_isA",
		"ice_ping", "joinTrip", "newMessage", "newTripOffer", "newTripRequest",
		"organizeTrip", "removeCar", "removeCarPlateEmail", "searchTrips",
		"updateCarData", "updateCarDataEmail", "updateUserData",
		"userTripRegistered" };

}

::Ice::DispatchStatus cardroid::zerocice::CardroidManager::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__zerocice__CardroidManager_all,
					__cardroid__zerocice__CardroidManager_all + 31,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__zerocice__CardroidManager_all) {
	case 0: {
		return ___addCar(in, current);
	}
	case 1: {
		return ___addCarEmail(in, current);
	}
	case 2: {
		return ___calculatePriceEstimation(in, current);
	}
	case 3: {
		return ___getCarFromPlate(in, current);
	}
	case 4: {
		return ___getCarFromPlateEmail(in, current);
	}
	case 5: {
		return ___getMessageTalks(in, current);
	}
	case 6: {
		return ___getMessageTalksSpeakers(in, current);
	}
	case 7: {
		return ___getPassengerTrips(in, current);
	}
	case 8: {
		return ___getTripFromId(in, current);
	}
	case 9: {
		return ___getTripOfferFromId(in, current);
	}
	case 10: {
		return ___getTripRequestFromId(in, current);
	}
	case 11: {
		return ___getUserActivity(in, current);
	}
	case 12: {
		return ___getUserFromEmail(in, current);
	}
	case 13: {
		return ___getUserPlaces(in, current);
	}
	case 14: {
		return ___getUserTrips(in, current);
	}
	case 15: {
		return ___ice_id(in, current);
	}
	case 16: {
		return ___ice_ids(in, current);
	}
	case 17: {
		return ___ice_isA(in, current);
	}
	case 18: {
		return ___ice_ping(in, current);
	}
	case 19: {
		return ___joinTrip(in, current);
	}
	case 20: {
		return ___newMessage(in, current);
	}
	case 21: {
		return ___newTripOffer(in, current);
	}
	case 22: {
		return ___newTripRequest(in, current);
	}
	case 23: {
		return ___organizeTrip(in, current);
	}
	case 24: {
		return ___removeCar(in, current);
	}
	case 25: {
		return ___removeCarPlateEmail(in, current);
	}
	case 26: {
		return ___searchTrips(in, current);
	}
	case 27: {
		return ___updateCarData(in, current);
	}
	case 28: {
		return ___updateCarDataEmail(in, current);
	}
	case 29: {
		return ___updateUserData(in, current);
	}
	case 30: {
		return ___userTripRegistered(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::zerocice::CardroidManager::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->endWriteSlice();
}

void cardroid::zerocice::CardroidManager::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->endReadSlice();
}

void cardroid::zerocice::__patch(CardroidManagerPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::zerocice::CardroidManagerPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::zerocice::CardroidManager::ice_staticId(), v);
	}
}
