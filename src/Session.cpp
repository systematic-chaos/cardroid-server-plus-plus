// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Session.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Session.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <Ice/SlicedData.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace {

namespace {

namespace {

}

}

namespace {

}

namespace {

namespace {

const ::std::string __cardroid__network__zerocice__Glacier2Session__getCardroidManager_name =
		"getCardroidManager";

const ::std::string __cardroid__network__zerocice__Glacier2Session__getTopic_name =
		"getTopic";

const ::std::string __cardroid__network__zerocice__Glacier2Session__refresh_name =
		"refresh";

const ::std::string __cardroid__network__zerocice__Session__getCardroidManager_name =
		"getCardroidManager";

const ::std::string __cardroid__network__zerocice__Session__getTopic_name =
		"getTopic";

const ::std::string __cardroid__network__zerocice__Session__refresh_name =
		"refresh";

const ::std::string __cardroid__network__zerocice__Session__destroy_name =
		"destroy";

const ::std::string __cardroid__network__zerocice__SessionFactory__create_name =
		"create";

const ::std::string __cardroid__network__zerocice__SessionFactory__getSessionTimeout_name =
		"getSessionTimeout";

const ::std::string __cardroid__network__zerocice__CardroidEventStorm__notify_name =
		"notify";

const ::std::string __cardroid__network__zerocice__CardroidEventStorm__message_name =
		"message";

}

}

}
::IceProxy::Ice::Object* ::IceProxy::cardroid::network::zerocice::upCast(
		::IceProxy::cardroid::network::zerocice::Glacier2Session* p) {
	return p;
}

void ::IceProxy::cardroid::network::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::network::zerocice::Glacier2Session>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::network::zerocice::Glacier2Session;
		v->__copyFrom(proxy);
	}
}

::cardroid::zerocice::CardroidManagerPrx IceProxy::cardroid::network::zerocice::Glacier2Session::getCardroidManager(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__network__zerocice__Glacier2Session__getCardroidManager_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__network__zerocice__Glacier2Session__getCardroidManager_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::network::zerocice::Glacier2Session* __del =
					dynamic_cast< ::IceDelegate::cardroid::network::zerocice::Glacier2Session*>(__delBase.get());
			return __del->getCardroidManager(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::network::zerocice::Glacier2Session::begin_getCardroidManager(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__network__zerocice__Glacier2Session__getCardroidManager_name);
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__network__zerocice__Glacier2Session__getCardroidManager_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__network__zerocice__Glacier2Session__getCardroidManager_name,
				::Ice::Normal, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::zerocice::CardroidManagerPrx IceProxy::cardroid::network::zerocice::Glacier2Session::end_getCardroidManager(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__network__zerocice__Glacier2Session__getCardroidManager_name);
	::cardroid::zerocice::CardroidManagerPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::IceStorm::TopicPrx IceProxy::cardroid::network::zerocice::Glacier2Session::getTopic(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__network__zerocice__Glacier2Session__getTopic_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__network__zerocice__Glacier2Session__getTopic_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::network::zerocice::Glacier2Session* __del =
					dynamic_cast< ::IceDelegate::cardroid::network::zerocice::Glacier2Session*>(__delBase.get());
			return __del->getTopic(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::network::zerocice::Glacier2Session::begin_getTopic(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__network__zerocice__Glacier2Session__getTopic_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__network__zerocice__Glacier2Session__getTopic_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__network__zerocice__Glacier2Session__getTopic_name,
				::Ice::Normal, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::IceStorm::TopicPrx IceProxy::cardroid::network::zerocice::Glacier2Session::end_getTopic(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__network__zerocice__Glacier2Session__getTopic_name);
	::IceStorm::TopicPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::network::zerocice::Glacier2Session::refresh(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__network__zerocice__Glacier2Session__refresh_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::network::zerocice::Glacier2Session* __del =
					dynamic_cast< ::IceDelegate::cardroid::network::zerocice::Glacier2Session*>(__delBase.get());
			__del->refresh(__ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::network::zerocice::Glacier2Session::begin_refresh(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__network__zerocice__Glacier2Session__refresh_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__network__zerocice__Glacier2Session__refresh_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::network::zerocice::Glacier2Session::end_refresh(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__network__zerocice__Glacier2Session__refresh_name);
}

const ::std::string&
IceProxy::cardroid::network::zerocice::Glacier2Session::ice_staticId() {
	return ::cardroid::network::zerocice::Glacier2Session::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::network::zerocice::Glacier2Session::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::network::zerocice::Glacier2Session);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::network::zerocice::Glacier2Session::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::network::zerocice::Glacier2Session);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::network::zerocice::Glacier2Session::__newInstance() const {
	return new Glacier2Session;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::network::zerocice::upCast(
		::IceProxy::cardroid::network::zerocice::Session* p) {
	return p;
}

void ::IceProxy::cardroid::network::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::network::zerocice::Session>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::network::zerocice::Session;
		v->__copyFrom(proxy);
	}
}

::cardroid::zerocice::CardroidManagerPrx IceProxy::cardroid::network::zerocice::Session::getCardroidManager(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__network__zerocice__Session__getCardroidManager_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__network__zerocice__Session__getCardroidManager_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::network::zerocice::Session* __del =
					dynamic_cast< ::IceDelegate::cardroid::network::zerocice::Session*>(__delBase.get());
			return __del->getCardroidManager(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::network::zerocice::Session::begin_getCardroidManager(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__network__zerocice__Session__getCardroidManager_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__network__zerocice__Session__getCardroidManager_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__network__zerocice__Session__getCardroidManager_name,
				::Ice::Normal, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::zerocice::CardroidManagerPrx IceProxy::cardroid::network::zerocice::Session::end_getCardroidManager(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__network__zerocice__Session__getCardroidManager_name);
	::cardroid::zerocice::CardroidManagerPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::IceStorm::TopicPrx IceProxy::cardroid::network::zerocice::Session::getTopic(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__network__zerocice__Session__getTopic_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__network__zerocice__Session__getTopic_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::network::zerocice::Session* __del =
					dynamic_cast< ::IceDelegate::cardroid::network::zerocice::Session*>(__delBase.get());
			return __del->getTopic(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::network::zerocice::Session::begin_getTopic(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__network__zerocice__Session__getTopic_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__network__zerocice__Session__getTopic_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__network__zerocice__Session__getTopic_name,
				::Ice::Normal, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::IceStorm::TopicPrx IceProxy::cardroid::network::zerocice::Session::end_getTopic(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__network__zerocice__Session__getTopic_name);
	::IceStorm::TopicPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

void IceProxy::cardroid::network::zerocice::Session::refresh(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__network__zerocice__Session__refresh_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::network::zerocice::Session* __del =
					dynamic_cast< ::IceDelegate::cardroid::network::zerocice::Session*>(__delBase.get());
			__del->refresh(__ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::network::zerocice::Session::begin_refresh(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__network__zerocice__Session__refresh_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__network__zerocice__Session__refresh_name,
				::Ice::Idempotent, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::network::zerocice::Session::end_refresh(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__network__zerocice__Session__refresh_name);
}

void IceProxy::cardroid::network::zerocice::Session::destroy(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__network__zerocice__Session__destroy_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::network::zerocice::Session* __del =
					dynamic_cast< ::IceDelegate::cardroid::network::zerocice::Session*>(__delBase.get());
			__del->destroy(__ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::network::zerocice::Session::begin_destroy(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__network__zerocice__Session__destroy_name, __del,
			__cookie);
	try {
		__result->__prepare(
				__cardroid__network__zerocice__Session__destroy_name,
				::Ice::Normal, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::network::zerocice::Session::end_destroy(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result, __cardroid__network__zerocice__Session__destroy_name);
}

const ::std::string&
IceProxy::cardroid::network::zerocice::Session::ice_staticId() {
	return ::cardroid::network::zerocice::Session::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::network::zerocice::Session::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::network::zerocice::Session);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::network::zerocice::Session::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::network::zerocice::Session);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::network::zerocice::Session::__newInstance() const {
	return new Session;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::network::zerocice::upCast(
		::IceProxy::cardroid::network::zerocice::SessionFactory* p) {
	return p;
}

void ::IceProxy::cardroid::network::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::network::zerocice::SessionFactory>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::network::zerocice::SessionFactory;
		v->__copyFrom(proxy);
	}
}

::cardroid::network::zerocice::SessionPrx IceProxy::cardroid::network::zerocice::SessionFactory::create(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__network__zerocice__SessionFactory__create_name, __ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__network__zerocice__SessionFactory__create_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::network::zerocice::SessionFactory* __del =
					dynamic_cast< ::IceDelegate::cardroid::network::zerocice::SessionFactory*>(__delBase.get());
			return __del->create(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::network::zerocice::SessionFactory::begin_create(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__network__zerocice__SessionFactory__create_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this, __cardroid__network__zerocice__SessionFactory__create_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__network__zerocice__SessionFactory__create_name,
				::Ice::Normal, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::cardroid::network::zerocice::SessionPrx IceProxy::cardroid::network::zerocice::SessionFactory::end_create(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__network__zerocice__SessionFactory__create_name);
	::cardroid::network::zerocice::SessionPrx __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

::Ice::Long IceProxy::cardroid::network::zerocice::SessionFactory::getSessionTimeout(
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__network__zerocice__SessionFactory__getSessionTimeout_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__network__zerocice__SessionFactory__getSessionTimeout_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::network::zerocice::SessionFactory* __del =
					dynamic_cast< ::IceDelegate::cardroid::network::zerocice::SessionFactory*>(__delBase.get());
			return __del->getSessionTimeout(__ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt,
					__observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::network::zerocice::SessionFactory::begin_getSessionTimeout(
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__network__zerocice__SessionFactory__getSessionTimeout_name);
	::IceInternal::OutgoingAsyncPtr __result =
			new ::IceInternal::OutgoingAsync(this,
					__cardroid__network__zerocice__SessionFactory__getSessionTimeout_name,
					__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__network__zerocice__SessionFactory__getSessionTimeout_name,
				::Ice::Nonmutating, __ctx);
		__result->__writeEmptyParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

::Ice::Long IceProxy::cardroid::network::zerocice::SessionFactory::end_getSessionTimeout(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__network__zerocice__SessionFactory__getSessionTimeout_name);
	::Ice::Long __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

const ::std::string&
IceProxy::cardroid::network::zerocice::SessionFactory::ice_staticId() {
	return ::cardroid::network::zerocice::SessionFactory::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::network::zerocice::SessionFactory::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::network::zerocice::SessionFactory);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::network::zerocice::SessionFactory::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::network::zerocice::SessionFactory);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::network::zerocice::SessionFactory::__newInstance() const {
	return new SessionFactory;
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::network::zerocice::upCast(
		::IceProxy::cardroid::network::zerocice::CardroidEventStorm* p) {
	return p;
}

void ::IceProxy::cardroid::network::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::network::zerocice::CardroidEventStorm>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::network::zerocice::CardroidEventStorm;
		v->__copyFrom(proxy);
	}
}

void IceProxy::cardroid::network::zerocice::CardroidEventStorm::notify(
		const ::cardroid::data::zerocice::UserActivityTypPrx& action,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__network__zerocice__CardroidEventStorm__notify_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::network::zerocice::CardroidEventStorm* __del =
					dynamic_cast< ::IceDelegate::cardroid::network::zerocice::CardroidEventStorm*>(__delBase.get());
			__del->notify(action, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::network::zerocice::CardroidEventStorm::begin_notify(
		const ::cardroid::data::zerocice::UserActivityTypPrx& action,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__network__zerocice__CardroidEventStorm__notify_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__network__zerocice__CardroidEventStorm__notify_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(action);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::network::zerocice::CardroidEventStorm::end_notify(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__network__zerocice__CardroidEventStorm__notify_name);
}

void IceProxy::cardroid::network::zerocice::CardroidEventStorm::message(
		const ::cardroid::data::zerocice::MessageTypPrx& msg,
		const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__network__zerocice__CardroidEventStorm__message_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::network::zerocice::CardroidEventStorm* __del =
					dynamic_cast< ::IceDelegate::cardroid::network::zerocice::CardroidEventStorm*>(__delBase.get());
			__del->message(msg, __ctx, __observer);
			return;
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::network::zerocice::CardroidEventStorm::begin_message(
		const ::cardroid::data::zerocice::MessageTypPrx& msg,
		const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__network__zerocice__CardroidEventStorm__message_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__network__zerocice__CardroidEventStorm__message_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(msg);
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

void IceProxy::cardroid::network::zerocice::CardroidEventStorm::end_message(
		const ::Ice::AsyncResultPtr& __result) {
	__end(__result,
			__cardroid__network__zerocice__CardroidEventStorm__message_name);
}

const ::std::string&
IceProxy::cardroid::network::zerocice::CardroidEventStorm::ice_staticId() {
	return ::cardroid::network::zerocice::CardroidEventStorm::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::network::zerocice::CardroidEventStorm::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::network::zerocice::CardroidEventStorm);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::network::zerocice::CardroidEventStorm::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::network::zerocice::CardroidEventStorm);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::network::zerocice::CardroidEventStorm::__newInstance() const {
	return new CardroidEventStorm;
}

::cardroid::zerocice::CardroidManagerPrx IceDelegateM::cardroid::network::zerocice::Glacier2Session::getCardroidManager(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__network__zerocice__Glacier2Session__getCardroidManager_name,
			::Ice::Normal, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::zerocice::CardroidManagerPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::IceStorm::TopicPrx IceDelegateM::cardroid::network::zerocice::Glacier2Session::getTopic(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__network__zerocice__Glacier2Session__getTopic_name,
			::Ice::Normal, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::IceStorm::TopicPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::network::zerocice::Glacier2Session::refresh(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__network__zerocice__Glacier2Session__refresh_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::zerocice::CardroidManagerPrx IceDelegateM::cardroid::network::zerocice::Session::getCardroidManager(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__network__zerocice__Session__getCardroidManager_name,
			::Ice::Normal, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::zerocice::CardroidManagerPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::IceStorm::TopicPrx IceDelegateM::cardroid::network::zerocice::Session::getTopic(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__network__zerocice__Session__getTopic_name,
			::Ice::Normal, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::IceStorm::TopicPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::network::zerocice::Session::refresh(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__network__zerocice__Session__refresh_name,
			::Ice::Idempotent, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

void IceDelegateM::cardroid::network::zerocice::Session::destroy(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__network__zerocice__Session__destroy_name, ::Ice::Normal,
			__context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::network::zerocice::SessionPrx IceDelegateM::cardroid::network::zerocice::SessionFactory::create(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__network__zerocice__SessionFactory__create_name,
			::Ice::Normal, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::cardroid::network::zerocice::SessionPrx __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

::Ice::Long IceDelegateM::cardroid::network::zerocice::SessionFactory::getSessionTimeout(
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__network__zerocice__SessionFactory__getSessionTimeout_name,
			::Ice::Nonmutating, __context, __observer);
	__og.writeEmptyParams();
	bool __ok = __og.invoke();
	::Ice::Long __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

void IceDelegateM::cardroid::network::zerocice::CardroidEventStorm::notify(
		const ::cardroid::data::zerocice::UserActivityTypPrx& action,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__network__zerocice__CardroidEventStorm__notify_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(action);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

void IceDelegateM::cardroid::network::zerocice::CardroidEventStorm::message(
		const ::cardroid::data::zerocice::MessageTypPrx& msg,
		const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__network__zerocice__CardroidEventStorm__message_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(msg);
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	if (__og.hasResponse()) {
		try {
			if (!__ok) {
				try {
					__og.throwUserException();
				} catch (const ::Ice::UserException& __ex) {
					::Ice::UnknownUserException __uue(__FILE__, __LINE__,
							__ex.ice_name());
					throw __uue;
				}
			}
			__og.readEmptyParams();
		} catch (const ::Ice::LocalException& __ex) {
			throw ::IceInternal::LocalExceptionWrapper(__ex, false);
		}
	}
}

::cardroid::zerocice::CardroidManagerPrx IceDelegateD::cardroid::network::zerocice::Glacier2Session::getCardroidManager(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::zerocice::CardroidManagerPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::network::zerocice::Glacier2Session* servant =
					dynamic_cast< ::cardroid::network::zerocice::Glacier2Session*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getCardroidManager(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::zerocice::CardroidManagerPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__network__zerocice__Glacier2Session__getCardroidManager_name,
			::Ice::Normal, __context);
	::cardroid::zerocice::CardroidManagerPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::IceStorm::TopicPrx IceDelegateD::cardroid::network::zerocice::Glacier2Session::getTopic(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::IceStorm::TopicPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::network::zerocice::Glacier2Session* servant =
					dynamic_cast< ::cardroid::network::zerocice::Glacier2Session*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTopic(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::IceStorm::TopicPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__network__zerocice__Glacier2Session__getTopic_name,
			::Ice::Normal, __context);
	::IceStorm::TopicPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::network::zerocice::Glacier2Session::refresh(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::Ice::Current& __current) :
				::IceInternal::Direct(__current) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::network::zerocice::Glacier2Session* servant =
					dynamic_cast< ::cardroid::network::zerocice::Glacier2Session*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->refresh(_current);
			return ::Ice::DispatchOK;
		}

	private:

	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__network__zerocice__Glacier2Session__refresh_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(__current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::zerocice::CardroidManagerPrx IceDelegateD::cardroid::network::zerocice::Session::getCardroidManager(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::zerocice::CardroidManagerPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::network::zerocice::Session* servant =
					dynamic_cast< ::cardroid::network::zerocice::Session*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getCardroidManager(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::zerocice::CardroidManagerPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__network__zerocice__Session__getCardroidManager_name,
			::Ice::Normal, __context);
	::cardroid::zerocice::CardroidManagerPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::IceStorm::TopicPrx IceDelegateD::cardroid::network::zerocice::Session::getTopic(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::IceStorm::TopicPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::network::zerocice::Session* servant =
					dynamic_cast< ::cardroid::network::zerocice::Session*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getTopic(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::IceStorm::TopicPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__network__zerocice__Session__getTopic_name,
			::Ice::Normal, __context);
	::IceStorm::TopicPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::network::zerocice::Session::refresh(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::Ice::Current& __current) :
				::IceInternal::Direct(__current) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::network::zerocice::Session* servant =
					dynamic_cast< ::cardroid::network::zerocice::Session*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->refresh(_current);
			return ::Ice::DispatchOK;
		}

	private:

	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__network__zerocice__Session__refresh_name,
			::Ice::Idempotent, __context);
	try {
		_DirectI __direct(__current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

void IceDelegateD::cardroid::network::zerocice::Session::destroy(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::Ice::Current& __current) :
				::IceInternal::Direct(__current) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::network::zerocice::Session* servant =
					dynamic_cast< ::cardroid::network::zerocice::Session*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->destroy(_current);
			return ::Ice::DispatchOK;
		}

	private:

	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__network__zerocice__Session__destroy_name, ::Ice::Normal,
			__context);
	try {
		_DirectI __direct(__current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::cardroid::network::zerocice::SessionPrx IceDelegateD::cardroid::network::zerocice::SessionFactory::create(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::cardroid::network::zerocice::SessionPrx& __result,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::network::zerocice::SessionFactory* servant =
					dynamic_cast< ::cardroid::network::zerocice::SessionFactory*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->create(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::cardroid::network::zerocice::SessionPrx& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__network__zerocice__SessionFactory__create_name,
			::Ice::Normal, __context);
	::cardroid::network::zerocice::SessionPrx __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::Ice::Long IceDelegateD::cardroid::network::zerocice::SessionFactory::getSessionTimeout(
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(::Ice::Long& __result, const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::network::zerocice::SessionFactory* servant =
					dynamic_cast< ::cardroid::network::zerocice::SessionFactory*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			_result = servant->getSessionTimeout(_current);
			return ::Ice::DispatchOK;
		}

	private:

		::Ice::Long& _result;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__network__zerocice__SessionFactory__getSessionTimeout_name,
			::Ice::Nonmutating, __context);
	::Ice::Long __result;
	try {
		_DirectI __direct(__result, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

void IceDelegateD::cardroid::network::zerocice::CardroidEventStorm::notify(
		const ::cardroid::data::zerocice::UserActivityTypPrx& action,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(
				const ::cardroid::data::zerocice::UserActivityTypPrx& __p_action,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_action(__p_action) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::network::zerocice::CardroidEventStorm* servant =
					dynamic_cast< ::cardroid::network::zerocice::CardroidEventStorm*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->notify(_m_action, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::UserActivityTypPrx& _m_action;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__network__zerocice__CardroidEventStorm__notify_name,
			::Ice::Normal, __context);
	try {
		_DirectI __direct(action, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

void IceDelegateD::cardroid::network::zerocice::CardroidEventStorm::message(
		const ::cardroid::data::zerocice::MessageTypPrx& msg,
		const ::Ice::Context* __context, ::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(const ::cardroid::data::zerocice::MessageTypPrx& __p_msg,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _m_msg(__p_msg) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::network::zerocice::CardroidEventStorm* servant =
					dynamic_cast< ::cardroid::network::zerocice::CardroidEventStorm*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			servant->message(_m_msg, _current);
			return ::Ice::DispatchOK;
		}

	private:

		const ::cardroid::data::zerocice::MessageTypPrx& _m_msg;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__network__zerocice__CardroidEventStorm__message_name,
			::Ice::Normal, __context);
	try {
		_DirectI __direct(msg, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
}

::Ice::Object* cardroid::network::zerocice::upCast(
		::cardroid::network::zerocice::Glacier2Session* p) {
	return p;
}

namespace {
const ::std::string __cardroid__network__zerocice__Glacier2Session_ids[3] = {
		"::Glacier2::Session", "::Ice::Object",
		"::cardroid::network::zerocice::Glacier2Session" };

}

bool cardroid::network::zerocice::Glacier2Session::ice_isA(
		const ::std::string& _s, const ::Ice::Current&) const {
	return ::std::binary_search(
			__cardroid__network__zerocice__Glacier2Session_ids,
			__cardroid__network__zerocice__Glacier2Session_ids + 3, _s);
}

::std::vector< ::std::string> cardroid::network::zerocice::Glacier2Session::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__network__zerocice__Glacier2Session_ids[0],
			&__cardroid__network__zerocice__Glacier2Session_ids[3]);
}

const ::std::string&
cardroid::network::zerocice::Glacier2Session::ice_id(
		const ::Ice::Current&) const {
	return __cardroid__network__zerocice__Glacier2Session_ids[2];
}

const ::std::string&
cardroid::network::zerocice::Glacier2Session::ice_staticId() {
	return __cardroid__network__zerocice__Glacier2Session_ids[2];
}

::Ice::DispatchStatus cardroid::network::zerocice::Glacier2Session::___getCardroidManager(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	__inS.readEmptyParams();
	::cardroid::zerocice::CardroidManagerPrx __ret = getCardroidManager(
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::network::zerocice::Glacier2Session::___getTopic(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	__inS.readEmptyParams();
	::IceStorm::TopicPrx __ret = getTopic(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::network::zerocice::Glacier2Session::___refresh(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	refresh(__current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__network__zerocice__Glacier2Session_all[] = {
		"destroy", "getCardroidManager", "getTopic", "ice_id", "ice_ids",
		"ice_isA", "ice_ping", "refresh" };

}

::Ice::DispatchStatus cardroid::network::zerocice::Glacier2Session::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(
					__cardroid__network__zerocice__Glacier2Session_all,
					__cardroid__network__zerocice__Glacier2Session_all + 8,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__network__zerocice__Glacier2Session_all) {
	case 0: {
		return ___destroy(in, current);
	}
	case 1: {
		return ___getCardroidManager(in, current);
	}
	case 2: {
		return ___getTopic(in, current);
	}
	case 3: {
		return ___ice_id(in, current);
	}
	case 4: {
		return ___ice_ids(in, current);
	}
	case 5: {
		return ___ice_isA(in, current);
	}
	case 6: {
		return ___ice_ping(in, current);
	}
	case 7: {
		return ___refresh(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::network::zerocice::Glacier2Session::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->endWriteSlice();
}

void cardroid::network::zerocice::Glacier2Session::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->endReadSlice();
}

void cardroid::network::zerocice::__patch(Glacier2SessionPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::network::zerocice::Glacier2SessionPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::network::zerocice::Glacier2Session::ice_staticId(),
				v);
	}
}

::Ice::Object* cardroid::network::zerocice::upCast(
		::cardroid::network::zerocice::Session* p) {
	return p;
}

namespace {
const ::std::string __cardroid__network__zerocice__Session_ids[2] = {
		"::Ice::Object", "::cardroid::network::zerocice::Session" };

}

bool cardroid::network::zerocice::Session::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__network__zerocice__Session_ids,
			__cardroid__network__zerocice__Session_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::network::zerocice::Session::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__network__zerocice__Session_ids[0],
			&__cardroid__network__zerocice__Session_ids[2]);
}

const ::std::string&
cardroid::network::zerocice::Session::ice_id(const ::Ice::Current&) const {
	return __cardroid__network__zerocice__Session_ids[1];
}

const ::std::string&
cardroid::network::zerocice::Session::ice_staticId() {
	return __cardroid__network__zerocice__Session_ids[1];
}

::Ice::DispatchStatus cardroid::network::zerocice::Session::___getCardroidManager(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	__inS.readEmptyParams();
	::cardroid::zerocice::CardroidManagerPrx __ret = getCardroidManager(
			__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::network::zerocice::Session::___getTopic(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	__inS.readEmptyParams();
	::IceStorm::TopicPrx __ret = getTopic(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::network::zerocice::Session::___refresh(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	refresh(__current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::network::zerocice::Session::___destroy(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	__inS.readEmptyParams();
	destroy(__current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__network__zerocice__Session_all[] = { "destroy",
		"getCardroidManager", "getTopic", "ice_id", "ice_ids", "ice_isA",
		"ice_ping", "refresh" };

}

::Ice::DispatchStatus cardroid::network::zerocice::Session::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__network__zerocice__Session_all,
					__cardroid__network__zerocice__Session_all + 8,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__network__zerocice__Session_all) {
	case 0: {
		return ___destroy(in, current);
	}
	case 1: {
		return ___getCardroidManager(in, current);
	}
	case 2: {
		return ___getTopic(in, current);
	}
	case 3: {
		return ___ice_id(in, current);
	}
	case 4: {
		return ___ice_ids(in, current);
	}
	case 5: {
		return ___ice_isA(in, current);
	}
	case 6: {
		return ___ice_ping(in, current);
	}
	case 7: {
		return ___refresh(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::network::zerocice::Session::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->endWriteSlice();
}

void cardroid::network::zerocice::Session::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->endReadSlice();
}

void cardroid::network::zerocice::__patch(SessionPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::network::zerocice::SessionPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::network::zerocice::Session::ice_staticId(), v);
	}
}

::Ice::Object* cardroid::network::zerocice::upCast(
		::cardroid::network::zerocice::SessionFactory* p) {
	return p;
}

namespace {
const ::std::string __cardroid__network__zerocice__SessionFactory_ids[2] = {
		"::Ice::Object", "::cardroid::network::zerocice::SessionFactory" };

}

bool cardroid::network::zerocice::SessionFactory::ice_isA(
		const ::std::string& _s, const ::Ice::Current&) const {
	return ::std::binary_search(
			__cardroid__network__zerocice__SessionFactory_ids,
			__cardroid__network__zerocice__SessionFactory_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::network::zerocice::SessionFactory::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__network__zerocice__SessionFactory_ids[0],
			&__cardroid__network__zerocice__SessionFactory_ids[2]);
}

const ::std::string&
cardroid::network::zerocice::SessionFactory::ice_id(
		const ::Ice::Current&) const {
	return __cardroid__network__zerocice__SessionFactory_ids[1];
}

const ::std::string&
cardroid::network::zerocice::SessionFactory::ice_staticId() {
	return __cardroid__network__zerocice__SessionFactory_ids[1];
}

::Ice::DispatchStatus cardroid::network::zerocice::SessionFactory::___create(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	__inS.readEmptyParams();
	::cardroid::network::zerocice::SessionPrx __ret = create(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::network::zerocice::SessionFactory::___getSessionTimeout(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Idempotent, __current.mode);
	__inS.readEmptyParams();
	::Ice::Long __ret = getSessionTimeout(__current);
	::IceInternal::BasicStream* __os = __inS.__startWriteParams(
			::Ice::DefaultFormat);
	__os->write(__ret);
	__inS.__endWriteParams(true);
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__network__zerocice__SessionFactory_all[] = {
		"create", "getSessionTimeout", "ice_id", "ice_ids", "ice_isA",
		"ice_ping" };

}

::Ice::DispatchStatus cardroid::network::zerocice::SessionFactory::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(
					__cardroid__network__zerocice__SessionFactory_all,
					__cardroid__network__zerocice__SessionFactory_all + 6,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__network__zerocice__SessionFactory_all) {
	case 0: {
		return ___create(in, current);
	}
	case 1: {
		return ___getSessionTimeout(in, current);
	}
	case 2: {
		return ___ice_id(in, current);
	}
	case 3: {
		return ___ice_ids(in, current);
	}
	case 4: {
		return ___ice_isA(in, current);
	}
	case 5: {
		return ___ice_ping(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::network::zerocice::SessionFactory::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->endWriteSlice();
}

void cardroid::network::zerocice::SessionFactory::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->endReadSlice();
}

void cardroid::network::zerocice::__patch(SessionFactoryPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::network::zerocice::SessionFactoryPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::network::zerocice::SessionFactory::ice_staticId(),
				v);
	}
}

::Ice::Object* cardroid::network::zerocice::upCast(
		::cardroid::network::zerocice::CardroidEventStorm* p) {
	return p;
}

namespace {
const ::std::string __cardroid__network__zerocice__CardroidEventStorm_ids[2] = {
		"::Ice::Object", "::cardroid::network::zerocice::CardroidEventStorm" };

}

bool cardroid::network::zerocice::CardroidEventStorm::ice_isA(
		const ::std::string& _s, const ::Ice::Current&) const {
	return ::std::binary_search(
			__cardroid__network__zerocice__CardroidEventStorm_ids,
			__cardroid__network__zerocice__CardroidEventStorm_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::network::zerocice::CardroidEventStorm::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__network__zerocice__CardroidEventStorm_ids[0],
			&__cardroid__network__zerocice__CardroidEventStorm_ids[2]);
}

const ::std::string&
cardroid::network::zerocice::CardroidEventStorm::ice_id(
		const ::Ice::Current&) const {
	return __cardroid__network__zerocice__CardroidEventStorm_ids[1];
}

const ::std::string&
cardroid::network::zerocice::CardroidEventStorm::ice_staticId() {
	return __cardroid__network__zerocice__CardroidEventStorm_ids[1];
}

::Ice::DispatchStatus cardroid::network::zerocice::CardroidEventStorm::___notify(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserActivityTypPrx action;
	__is->read(action);
	__inS.endReadParams();
	notify(action, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

::Ice::DispatchStatus cardroid::network::zerocice::CardroidEventStorm::___message(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::MessageTypPrx msg;
	__is->read(msg);
	__inS.endReadParams();
	message(msg, __current);
	__inS.__writeEmptyParams();
	return ::Ice::DispatchOK;
}

namespace {
const ::std::string __cardroid__network__zerocice__CardroidEventStorm_all[] = {
		"ice_id", "ice_ids", "ice_isA", "ice_ping", "message", "notify" };

}

::Ice::DispatchStatus cardroid::network::zerocice::CardroidEventStorm::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(
					__cardroid__network__zerocice__CardroidEventStorm_all,
					__cardroid__network__zerocice__CardroidEventStorm_all + 6,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__network__zerocice__CardroidEventStorm_all) {
	case 0: {
		return ___ice_id(in, current);
	}
	case 1: {
		return ___ice_ids(in, current);
	}
	case 2: {
		return ___ice_isA(in, current);
	}
	case 3: {
		return ___ice_ping(in, current);
	}
	case 4: {
		return ___message(in, current);
	}
	case 5: {
		return ___notify(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::network::zerocice::CardroidEventStorm::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->endWriteSlice();
}

void cardroid::network::zerocice::CardroidEventStorm::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->endReadSlice();
}

void cardroid::network::zerocice::__patch(CardroidEventStormPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::network::zerocice::CardroidEventStormPtr::dynamicCast(
			v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::network::zerocice::CardroidEventStorm::ice_staticId(),
				v);
	}
}
