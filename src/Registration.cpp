// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Registration.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Registration.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace {

namespace {

namespace {

}

}

namespace {

namespace {

const ::std::string __cardroid__network__zerocice__Registration__registerNewUser_name =
		"registerNewUser";

}

}

}

namespace {

const char* __cardroid__network__zerocice__RegistrationDeniedException_name =
		"cardroid::network::zerocice::RegistrationDeniedException";

struct __F__cardroid__network__zerocice__RegistrationDeniedException: public ::IceInternal::UserExceptionFactory {
	virtual void createAndThrow(const ::std::string&) {
		throw ::cardroid::network::zerocice::RegistrationDeniedException();
	}
};

class __F__cardroid__network__zerocice__RegistrationDeniedException__Init {
public:

	__F__cardroid__network__zerocice__RegistrationDeniedException__Init() {
		::IceInternal::factoryTable->addExceptionFactory(
				"::cardroid::network::zerocice::RegistrationDeniedException",
				new __F__cardroid__network__zerocice__RegistrationDeniedException);
	}

	~__F__cardroid__network__zerocice__RegistrationDeniedException__Init() {
		::IceInternal::factoryTable->removeExceptionFactory(
				"::cardroid::network::zerocice::RegistrationDeniedException");
	}
};

const __F__cardroid__network__zerocice__RegistrationDeniedException__Init   __F__cardroid__network__zerocice__RegistrationDeniedException__i;
}

cardroid::network::zerocice::RegistrationDeniedException::RegistrationDeniedException(
		const ::std::string& __ice_reason) :
		::Ice::UserException(), reason(__ice_reason) {
}

cardroid::network::zerocice::RegistrationDeniedException::~RegistrationDeniedException() throw () {
}

::std::string cardroid::network::zerocice::RegistrationDeniedException::ice_name() const {
	return __cardroid__network__zerocice__RegistrationDeniedException_name;
}

cardroid::network::zerocice::RegistrationDeniedException*
cardroid::network::zerocice::RegistrationDeniedException::ice_clone() const {
	return new RegistrationDeniedException(*this);
}

void cardroid::network::zerocice::RegistrationDeniedException::ice_throw() const {
	throw *this;
}

void cardroid::network::zerocice::RegistrationDeniedException::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(
			"::cardroid::network::zerocice::RegistrationDeniedException", -1,
			true);
	__os->write(reason);
	__os->endWriteSlice();
}

void cardroid::network::zerocice::RegistrationDeniedException::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->read(reason);
	__is->endReadSlice();
}

namespace Ice {
}
::IceProxy::Ice::Object* ::IceProxy::cardroid::network::zerocice::upCast(
		::IceProxy::cardroid::network::zerocice::Registration* p) {
	return p;
}

void ::IceProxy::cardroid::network::zerocice::__read(
		::IceInternal::BasicStream* __is,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::network::zerocice::Registration>& v) {
	::Ice::ObjectPrx proxy;
	__is->read(proxy);
	if (!proxy) {
		v = 0;
	} else {
		v = new ::IceProxy::cardroid::network::zerocice::Registration;
		v->__copyFrom(proxy);
	}
}

bool IceProxy::cardroid::network::zerocice::Registration::registerNewUser(
		const ::cardroid::data::zerocice::UserTypPtr& newUser,
		const ::std::string& password, const ::Ice::Context* __ctx) {
	::IceInternal::InvocationObserver __observer(this,
			__cardroid__network__zerocice__Registration__registerNewUser_name,
			__ctx);
	int __cnt = 0;
	while (true) {
		::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
		try {
			__checkTwowayOnly(
					__cardroid__network__zerocice__Registration__registerNewUser_name);
			__delBase = __getDelegate(false);
			::IceDelegate::cardroid::network::zerocice::Registration* __del =
					dynamic_cast< ::IceDelegate::cardroid::network::zerocice::Registration*>(__delBase.get());
			return __del->registerNewUser(newUser, password, __ctx, __observer);
		} catch (const ::IceInternal::LocalExceptionWrapper& __ex) {
			__handleExceptionWrapper(__delBase, __ex, __observer);
		} catch (const ::Ice::LocalException& __ex) {
			__handleException(__delBase, __ex, true, __cnt, __observer);
		}
	}
}

::Ice::AsyncResultPtr IceProxy::cardroid::network::zerocice::Registration::begin_registerNewUser(
		const ::cardroid::data::zerocice::UserTypPtr& newUser,
		const ::std::string& password, const ::Ice::Context* __ctx,
		const ::IceInternal::CallbackBasePtr& __del,
		const ::Ice::LocalObjectPtr& __cookie) {
	__checkAsyncTwowayOnly(
			__cardroid__network__zerocice__Registration__registerNewUser_name);
	::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(
			this,
			__cardroid__network__zerocice__Registration__registerNewUser_name,
			__del, __cookie);
	try {
		__result->__prepare(
				__cardroid__network__zerocice__Registration__registerNewUser_name,
				::Ice::Normal, __ctx);
		::IceInternal::BasicStream* __os = __result->__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(newUser);
		__os->write(password);
		__os->writePendingObjects();
		__result->__endWriteParams();
		__result->__send(true);
	} catch (const ::Ice::LocalException& __ex) {
		__result->__exceptionAsync(__ex);
	}
	return __result;
}

bool IceProxy::cardroid::network::zerocice::Registration::end_registerNewUser(
		const ::Ice::AsyncResultPtr& __result) {
	::Ice::AsyncResult::__check(__result, this,
			__cardroid__network__zerocice__Registration__registerNewUser_name);
	bool __ret;
	bool __ok = __result->__wait();
	try {
		if (!__ok) {
			try {
				__result->__throwUserException();
			} catch (const ::cardroid::network::zerocice::RegistrationDeniedException&) {
				throw;
			} catch (const ::Ice::UserException& __ex) {
				throw ::Ice::UnknownUserException(__FILE__, __LINE__,
						__ex.ice_name());
			}
		}
		::IceInternal::BasicStream* __is = __result->__startReadParams();
		__is->read(__ret);
		__result->__endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& ex) {
		__result->__getObserver().failed(ex.ice_name());
		throw;
	}
}

const ::std::string&
IceProxy::cardroid::network::zerocice::Registration::ice_staticId() {
	return ::cardroid::network::zerocice::Registration::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object> IceProxy::cardroid::network::zerocice::Registration::__createDelegateM() {
	return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(
			new ::IceDelegateM::cardroid::network::zerocice::Registration);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object> IceProxy::cardroid::network::zerocice::Registration::__createDelegateD() {
	return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(
			new ::IceDelegateD::cardroid::network::zerocice::Registration);
}

::IceProxy::Ice::Object*
IceProxy::cardroid::network::zerocice::Registration::__newInstance() const {
	return new Registration;
}

bool IceDelegateM::cardroid::network::zerocice::Registration::registerNewUser(
		const ::cardroid::data::zerocice::UserTypPtr& newUser,
		const ::std::string& password, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver& __observer) {
	::IceInternal::Outgoing __og(__handler.get(),
			__cardroid__network__zerocice__Registration__registerNewUser_name,
			::Ice::Normal, __context, __observer);
	try {
		::IceInternal::BasicStream* __os = __og.startWriteParams(
				::Ice::DefaultFormat);
		__os->write(newUser);
		__os->write(password);
		__os->writePendingObjects();
		__og.endWriteParams();
	} catch (const ::Ice::LocalException& __ex) {
		__og.abort(__ex);
	}
	bool __ok = __og.invoke();
	bool __ret;
	try {
		if (!__ok) {
			try {
				__og.throwUserException();
			} catch (const ::cardroid::network::zerocice::RegistrationDeniedException&) {
				throw;
			} catch (const ::Ice::UserException& __ex) {
				::Ice::UnknownUserException __uue(__FILE__, __LINE__,
						__ex.ice_name());
				throw __uue;
			}
		}
		::IceInternal::BasicStream* __is = __og.startReadParams();
		__is->read(__ret);
		__og.endReadParams();
		return __ret;
	} catch (const ::Ice::LocalException& __ex) {
		throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
}

bool IceDelegateD::cardroid::network::zerocice::Registration::registerNewUser(
		const ::cardroid::data::zerocice::UserTypPtr& newUser,
		const ::std::string& password, const ::Ice::Context* __context,
		::IceInternal::InvocationObserver&) {
	class _DirectI: public ::IceInternal::Direct {
	public:

		_DirectI(bool& __result,
				const ::cardroid::data::zerocice::UserTypPtr& __p_newUser,
				const ::std::string& __p_password,
				const ::Ice::Current& __current) :
				::IceInternal::Direct(__current), _result(__result), _m_newUser(
						__p_newUser), _m_password(__p_password) {
		}

		virtual ::Ice::DispatchStatus run(::Ice::Object* object) {
			::cardroid::network::zerocice::Registration* servant =
					dynamic_cast< ::cardroid::network::zerocice::Registration*>(object);
			if (!servant) {
				throw ::Ice::OperationNotExistException(__FILE__, __LINE__,
						_current.id, _current.facet, _current.operation);
			}
			try {
				_result = servant->registerNewUser(_m_newUser, _m_password,
						_current);
				return ::Ice::DispatchOK;
			} catch (const ::Ice::UserException& __ex) {
				setUserException(__ex);
				return ::Ice::DispatchUserException;
			}
		}

	private:

		bool& _result;
		const ::cardroid::data::zerocice::UserTypPtr& _m_newUser;
		const ::std::string& _m_password;
	};

	::Ice::Current __current;
	__initCurrent(__current,
			__cardroid__network__zerocice__Registration__registerNewUser_name,
			::Ice::Normal, __context);
	bool __result;
	try {
		_DirectI __direct(__result, newUser, password, __current);
		try {
			__direct.getServant()->__collocDispatch(__direct);
		} catch (...) {
			__direct.destroy();
			throw;
		}
		__direct.destroy();
	} catch (const ::cardroid::network::zerocice::RegistrationDeniedException&) {
		throw;
	} catch (const ::Ice::SystemException&) {
		throw;
	} catch (const ::IceInternal::LocalExceptionWrapper&) {
		throw;
	} catch (const ::std::exception& __ex) {
		::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
	} catch (...) {
		throw ::IceInternal::LocalExceptionWrapper(
				::Ice::UnknownException(__FILE__, __LINE__,
						"unknown c++ exception"), false);
	}
	return __result;
}

::Ice::Object* cardroid::network::zerocice::upCast(
		::cardroid::network::zerocice::Registration* p) {
	return p;
}

namespace {
const ::std::string __cardroid__network__zerocice__Registration_ids[2] = {
		"::Ice::Object", "::cardroid::network::zerocice::Registration" };

}

bool cardroid::network::zerocice::Registration::ice_isA(const ::std::string& _s,
		const ::Ice::Current&) const {
	return ::std::binary_search(__cardroid__network__zerocice__Registration_ids,
			__cardroid__network__zerocice__Registration_ids + 2, _s);
}

::std::vector< ::std::string> cardroid::network::zerocice::Registration::ice_ids(
		const ::Ice::Current&) const {
	return ::std::vector< ::std::string>(
			&__cardroid__network__zerocice__Registration_ids[0],
			&__cardroid__network__zerocice__Registration_ids[2]);
}

const ::std::string&
cardroid::network::zerocice::Registration::ice_id(const ::Ice::Current&) const {
	return __cardroid__network__zerocice__Registration_ids[1];
}

const ::std::string&
cardroid::network::zerocice::Registration::ice_staticId() {
	return __cardroid__network__zerocice__Registration_ids[1];
}

::Ice::DispatchStatus cardroid::network::zerocice::Registration::___registerNewUser(
		::IceInternal::Incoming& __inS, const ::Ice::Current& __current) {
	__checkMode(::Ice::Normal, __current.mode);
	::IceInternal::BasicStream* __is = __inS.startReadParams();
	::cardroid::data::zerocice::UserTypPtr newUser;
	::std::string password;
	__is->read(newUser);
	__is->read(password);
	__is->readPendingObjects();
	__inS.endReadParams();
	try {
		bool __ret = registerNewUser(newUser, password, __current);
		::IceInternal::BasicStream* __os = __inS.__startWriteParams(
				::Ice::DefaultFormat);
		__os->write(__ret);
		__inS.__endWriteParams(true);
		return ::Ice::DispatchOK;
	} catch (const ::cardroid::network::zerocice::RegistrationDeniedException& __ex) {
		__inS.__writeUserException(__ex, ::Ice::DefaultFormat);
	}
	return ::Ice::DispatchUserException;
}

namespace {
const ::std::string __cardroid__network__zerocice__Registration_all[] = {
		"ice_id", "ice_ids", "ice_isA", "ice_ping", "registerNewUser" };

}

::Ice::DispatchStatus cardroid::network::zerocice::Registration::__dispatch(
		::IceInternal::Incoming& in, const ::Ice::Current& current) {
	::std::pair<const ::std::string*, const ::std::string*> r =
			::std::equal_range(__cardroid__network__zerocice__Registration_all,
					__cardroid__network__zerocice__Registration_all + 5,
					current.operation);
	if (r.first == r.second) {
		throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
				current.facet, current.operation);
	}

	switch (r.first - __cardroid__network__zerocice__Registration_all) {
	case 0: {
		return ___ice_id(in, current);
	}
	case 1: {
		return ___ice_ids(in, current);
	}
	case 2: {
		return ___ice_isA(in, current);
	}
	case 3: {
		return ___ice_ping(in, current);
	}
	case 4: {
		return ___registerNewUser(in, current);
	}
	}

	assert(false);
	throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id,
			current.facet, current.operation);
}

void cardroid::network::zerocice::Registration::__writeImpl(
		::IceInternal::BasicStream* __os) const {
	__os->startWriteSlice(ice_staticId(), -1, true);
	__os->endWriteSlice();
}

void cardroid::network::zerocice::Registration::__readImpl(
		::IceInternal::BasicStream* __is) {
	__is->startReadSlice();
	__is->endReadSlice();
}

void cardroid::network::zerocice::__patch(RegistrationPtr& handle,
		const ::Ice::ObjectPtr& v) {
	handle = ::cardroid::network::zerocice::RegistrationPtr::dynamicCast(v);
	if (v && !handle) {
		IceInternal::Ex::throwUOE(
				::cardroid::network::zerocice::Registration::ice_staticId(), v);
	}
}
