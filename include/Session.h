// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Session.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Session_h__
#define __Session_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/SlicedDataF.h>
#include <Glacier2/Session.h>
#include <IceStorm/IceStorm.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy {

namespace cardroid {

namespace data {

namespace zerocice {

class UserActivityTyp;
void __read(::IceInternal::BasicStream*,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::data::zerocice::UserActivityTyp>&);
::IceProxy::Ice::Object* upCast(
		::IceProxy::cardroid::data::zerocice::UserActivityTyp*);

class MessageTyp;
void __read(::IceInternal::BasicStream*,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::data::zerocice::MessageTyp>&);
::IceProxy::Ice::Object* upCast(
		::IceProxy::cardroid::data::zerocice::MessageTyp*);

}

}

namespace zerocice {

class CardroidManager;
void __read(::IceInternal::BasicStream*,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::zerocice::CardroidManager>&);
::IceProxy::Ice::Object* upCast(
		::IceProxy::cardroid::zerocice::CardroidManager*);

}

namespace network {

namespace zerocice {

class Glacier2Session;
void __read(::IceInternal::BasicStream*,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::network::zerocice::Glacier2Session>&);
::IceProxy::Ice::Object* upCast(
		::IceProxy::cardroid::network::zerocice::Glacier2Session*);

class Session;
void __read(::IceInternal::BasicStream*,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::network::zerocice::Session>&);
::IceProxy::Ice::Object* upCast(
		::IceProxy::cardroid::network::zerocice::Session*);

class SessionFactory;
void __read(::IceInternal::BasicStream*,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::network::zerocice::SessionFactory>&);
::IceProxy::Ice::Object* upCast(
		::IceProxy::cardroid::network::zerocice::SessionFactory*);

class CardroidEventStorm;
void __read(::IceInternal::BasicStream*,
		::IceInternal::ProxyHandle<
				::IceProxy::cardroid::network::zerocice::CardroidEventStorm>&);
::IceProxy::Ice::Object* upCast(
		::IceProxy::cardroid::network::zerocice::CardroidEventStorm*);

}

}

}

}

namespace cardroid {

namespace data {

namespace zerocice {

class UserActivityTyp;
bool operator==(const UserActivityTyp&, const UserActivityTyp&);
bool operator<(const UserActivityTyp&, const UserActivityTyp&);
::Ice::Object* upCast(::cardroid::data::zerocice::UserActivityTyp*);
typedef ::IceInternal::Handle< ::cardroid::data::zerocice::UserActivityTyp> UserActivityTypPtr;
typedef ::IceInternal::ProxyHandle<
		::IceProxy::cardroid::data::zerocice::UserActivityTyp> UserActivityTypPrx;
void __patch(UserActivityTypPtr&, const ::Ice::ObjectPtr&);

class MessageTyp;
bool operator==(const MessageTyp&, const MessageTyp&);
bool operator<(const MessageTyp&, const MessageTyp&);
::Ice::Object* upCast(::cardroid::data::zerocice::MessageTyp*);
typedef ::IceInternal::Handle< ::cardroid::data::zerocice::MessageTyp> MessageTypPtr;
typedef ::IceInternal::ProxyHandle<
		::IceProxy::cardroid::data::zerocice::MessageTyp> MessageTypPrx;
void __patch(MessageTypPtr&, const ::Ice::ObjectPtr&);

}

}

namespace zerocice {

class CardroidManager;
bool operator==(const CardroidManager&, const CardroidManager&);
bool operator<(const CardroidManager&, const CardroidManager&);
::Ice::Object* upCast(::cardroid::zerocice::CardroidManager*);
typedef ::IceInternal::Handle< ::cardroid::zerocice::CardroidManager> CardroidManagerPtr;
typedef ::IceInternal::ProxyHandle<
		::IceProxy::cardroid::zerocice::CardroidManager> CardroidManagerPrx;
void __patch(CardroidManagerPtr&, const ::Ice::ObjectPtr&);

}

namespace network {

namespace zerocice {

class Glacier2Session;
bool operator==(const Glacier2Session&, const Glacier2Session&);
bool operator<(const Glacier2Session&, const Glacier2Session&);
::Ice::Object* upCast(::cardroid::network::zerocice::Glacier2Session*);
typedef ::IceInternal::Handle< ::cardroid::network::zerocice::Glacier2Session> Glacier2SessionPtr;
typedef ::IceInternal::ProxyHandle<
		::IceProxy::cardroid::network::zerocice::Glacier2Session> Glacier2SessionPrx;
void __patch(Glacier2SessionPtr&, const ::Ice::ObjectPtr&);

class Session;
bool operator==(const Session&, const Session&);
bool operator<(const Session&, const Session&);
::Ice::Object* upCast(::cardroid::network::zerocice::Session*);
typedef ::IceInternal::Handle< ::cardroid::network::zerocice::Session> SessionPtr;
typedef ::IceInternal::ProxyHandle<
		::IceProxy::cardroid::network::zerocice::Session> SessionPrx;
void __patch(SessionPtr&, const ::Ice::ObjectPtr&);

class SessionFactory;
bool operator==(const SessionFactory&, const SessionFactory&);
bool operator<(const SessionFactory&, const SessionFactory&);
::Ice::Object* upCast(::cardroid::network::zerocice::SessionFactory*);
typedef ::IceInternal::Handle< ::cardroid::network::zerocice::SessionFactory> SessionFactoryPtr;
typedef ::IceInternal::ProxyHandle<
		::IceProxy::cardroid::network::zerocice::SessionFactory> SessionFactoryPrx;
void __patch(SessionFactoryPtr&, const ::Ice::ObjectPtr&);

class CardroidEventStorm;
bool operator==(const CardroidEventStorm&, const CardroidEventStorm&);
bool operator<(const CardroidEventStorm&, const CardroidEventStorm&);
::Ice::Object* upCast(::cardroid::network::zerocice::CardroidEventStorm*);
typedef ::IceInternal::Handle< ::cardroid::network::zerocice::CardroidEventStorm> CardroidEventStormPtr;
typedef ::IceInternal::ProxyHandle<
		::IceProxy::cardroid::network::zerocice::CardroidEventStorm> CardroidEventStormPrx;
void __patch(CardroidEventStormPtr&, const ::Ice::ObjectPtr&);

}

}

}

namespace cardroid {

namespace network {

namespace zerocice {

class Callback_Glacier2Session_getCardroidManager_Base: virtual public ::IceInternal::CallbackBase {
};
typedef ::IceUtil::Handle<Callback_Glacier2Session_getCardroidManager_Base> Callback_Glacier2Session_getCardroidManagerPtr;

class Callback_Glacier2Session_getTopic_Base: virtual public ::IceInternal::CallbackBase {
};
typedef ::IceUtil::Handle<Callback_Glacier2Session_getTopic_Base> Callback_Glacier2Session_getTopicPtr;

class Callback_Glacier2Session_refresh_Base: virtual public ::IceInternal::CallbackBase {
};
typedef ::IceUtil::Handle<Callback_Glacier2Session_refresh_Base> Callback_Glacier2Session_refreshPtr;

class Callback_Session_getCardroidManager_Base: virtual public ::IceInternal::CallbackBase {
};
typedef ::IceUtil::Handle<Callback_Session_getCardroidManager_Base> Callback_Session_getCardroidManagerPtr;

class Callback_Session_getTopic_Base: virtual public ::IceInternal::CallbackBase {
};
typedef ::IceUtil::Handle<Callback_Session_getTopic_Base> Callback_Session_getTopicPtr;

class Callback_Session_refresh_Base: virtual public ::IceInternal::CallbackBase {
};
typedef ::IceUtil::Handle<Callback_Session_refresh_Base> Callback_Session_refreshPtr;

class Callback_Session_destroy_Base: virtual public ::IceInternal::CallbackBase {
};
typedef ::IceUtil::Handle<Callback_Session_destroy_Base> Callback_Session_destroyPtr;

class Callback_SessionFactory_create_Base: virtual public ::IceInternal::CallbackBase {
};
typedef ::IceUtil::Handle<Callback_SessionFactory_create_Base> Callback_SessionFactory_createPtr;

class Callback_SessionFactory_getSessionTimeout_Base: virtual public ::IceInternal::CallbackBase {
};
typedef ::IceUtil::Handle<Callback_SessionFactory_getSessionTimeout_Base> Callback_SessionFactory_getSessionTimeoutPtr;

class Callback_CardroidEventStorm_notify_Base: virtual public ::IceInternal::CallbackBase {
};
typedef ::IceUtil::Handle<Callback_CardroidEventStorm_notify_Base> Callback_CardroidEventStorm_notifyPtr;

class Callback_CardroidEventStorm_message_Base: virtual public ::IceInternal::CallbackBase {
};
typedef ::IceUtil::Handle<Callback_CardroidEventStorm_message_Base> Callback_CardroidEventStorm_messagePtr;

}

}

}

namespace IceProxy {

namespace cardroid {

namespace network {

namespace zerocice {

class Glacier2Session: virtual public ::IceProxy::Glacier2::Session {
public:

	::cardroid::zerocice::CardroidManagerPrx getCardroidManager() {
		return getCardroidManager(0);
	}
	::cardroid::zerocice::CardroidManagerPrx getCardroidManager(
			const ::Ice::Context& __ctx) {
		return getCardroidManager(&__ctx);
	}
#ifdef ICE_CPP11
	::Ice::AsyncResultPtr begin_getCardroidManager(
			const ::IceInternal::Function<
					void(const ::cardroid::zerocice::CardroidManagerPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return __begin_getCardroidManager(0, __response, __exception, __sent);
	}
	::Ice::AsyncResultPtr begin_getCardroidManager(
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_getCardroidManager(0,
				::Ice::newCallback(__completed, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_getCardroidManager(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<
					void(const ::cardroid::zerocice::CardroidManagerPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return __begin_getCardroidManager(&__ctx, __response, __exception,
				__sent);
	}
	::Ice::AsyncResultPtr begin_getCardroidManager(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_getCardroidManager(&__ctx,
				::Ice::newCallback(__completed, __sent));
	}

private:

	::Ice::AsyncResultPtr __begin_getCardroidManager(
			const ::Ice::Context* __ctx,
			const ::IceInternal::Function<
					void(const ::cardroid::zerocice::CardroidManagerPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception,
			const ::IceInternal::Function<void(bool)>& __sent) {
		class Cpp11CB: public ::IceInternal::Cpp11FnCallbackNC {
		public:

			Cpp11CB(
					const ::std::function<
							void(
									const ::cardroid::zerocice::CardroidManagerPrx&)>& responseFunc,
					const ::std::function<void(const ::Ice::Exception&)>& exceptionFunc,
					const ::std::function<void(bool)>& sentFunc) :
					::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc), _response(
							responseFunc) {
				CallbackBase::checkCallback(true,
						responseFunc || exceptionFunc != nullptr);
			}

			virtual void __completed(
					const ::Ice::AsyncResultPtr& __result) const {
				::cardroid::network::zerocice::Glacier2SessionPrx __proxy =
						::cardroid::network::zerocice::Glacier2SessionPrx::uncheckedCast(
								__result->getProxy());
				::cardroid::zerocice::CardroidManagerPrx __ret;
				try {
					__ret = __proxy->end_getCardroidManager(__result);
				} catch (::Ice::Exception& ex) {
					Cpp11FnCallbackNC::__exception(__result, ex);
					return;
				}
				if (_response != nullptr) {
					_response(__ret);
				}
			}

		private:

			::std::function<
					void(const ::cardroid::zerocice::CardroidManagerPrx&)> _response;
		};
		return begin_getCardroidManager(__ctx,
				new Cpp11CB(__response, __exception, __sent));
	}

public:
#endif

	::Ice::AsyncResultPtr begin_getCardroidManager() {
		return begin_getCardroidManager(0, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_getCardroidManager(
			const ::Ice::Context& __ctx) {
		return begin_getCardroidManager(&__ctx, ::IceInternal::__dummyCallback,
				0);
	}

	::Ice::AsyncResultPtr begin_getCardroidManager(
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getCardroidManager(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getCardroidManager(const ::Ice::Context& __ctx,
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getCardroidManager(&__ctx, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getCardroidManager(
			const ::cardroid::network::zerocice::Callback_Glacier2Session_getCardroidManagerPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getCardroidManager(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getCardroidManager(const ::Ice::Context& __ctx,
			const ::cardroid::network::zerocice::Callback_Glacier2Session_getCardroidManagerPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getCardroidManager(&__ctx, __del, __cookie);
	}

	::cardroid::zerocice::CardroidManagerPrx end_getCardroidManager(
			const ::Ice::AsyncResultPtr&);

private:

	::cardroid::zerocice::CardroidManagerPrx getCardroidManager(
			const ::Ice::Context*);
	::Ice::AsyncResultPtr begin_getCardroidManager(const ::Ice::Context*,
			const ::IceInternal::CallbackBasePtr&,
			const ::Ice::LocalObjectPtr& __cookie = 0);

public:

	::IceStorm::TopicPrx getTopic() {
		return getTopic(0);
	}
	::IceStorm::TopicPrx getTopic(const ::Ice::Context& __ctx) {
		return getTopic(&__ctx);
	}
#ifdef ICE_CPP11
	::Ice::AsyncResultPtr begin_getTopic(
			const ::IceInternal::Function<void(const ::IceStorm::TopicPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return __begin_getTopic(0, __response, __exception, __sent);
	}
	::Ice::AsyncResultPtr begin_getTopic(
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_getTopic(0, ::Ice::newCallback(__completed, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::IceStorm::TopicPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return __begin_getTopic(&__ctx, __response, __exception, __sent);
	}
	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_getTopic(&__ctx, ::Ice::newCallback(__completed, __sent));
	}

private:

	::Ice::AsyncResultPtr __begin_getTopic(const ::Ice::Context* __ctx,
			const ::IceInternal::Function<void(const ::IceStorm::TopicPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception,
			const ::IceInternal::Function<void(bool)>& __sent) {
		class Cpp11CB: public ::IceInternal::Cpp11FnCallbackNC {
		public:

			Cpp11CB(
					const ::std::function<void(const ::IceStorm::TopicPrx&)>& responseFunc,
					const ::std::function<void(const ::Ice::Exception&)>& exceptionFunc,
					const ::std::function<void(bool)>& sentFunc) :
					::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc), _response(
							responseFunc) {
				CallbackBase::checkCallback(true,
						responseFunc || exceptionFunc != nullptr);
			}

			virtual void __completed(
					const ::Ice::AsyncResultPtr& __result) const {
				::cardroid::network::zerocice::Glacier2SessionPrx __proxy =
						::cardroid::network::zerocice::Glacier2SessionPrx::uncheckedCast(
								__result->getProxy());
				::IceStorm::TopicPrx __ret;
				try {
					__ret = __proxy->end_getTopic(__result);
				} catch (::Ice::Exception& ex) {
					Cpp11FnCallbackNC::__exception(__result, ex);
					return;
				}
				if (_response != nullptr) {
					_response(__ret);
				}
			}

		private:

			::std::function<void(const ::IceStorm::TopicPrx&)> _response;
		};
		return begin_getTopic(__ctx,
				new Cpp11CB(__response, __exception, __sent));
	}

public:
#endif

	::Ice::AsyncResultPtr begin_getTopic() {
		return begin_getTopic(0, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::Context& __ctx) {
		return begin_getTopic(&__ctx, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getTopic(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::Context& __ctx,
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getTopic(&__ctx, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getTopic(
			const ::cardroid::network::zerocice::Callback_Glacier2Session_getTopicPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getTopic(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::Context& __ctx,
			const ::cardroid::network::zerocice::Callback_Glacier2Session_getTopicPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getTopic(&__ctx, __del, __cookie);
	}

	::IceStorm::TopicPrx end_getTopic(const ::Ice::AsyncResultPtr&);

private:

	::IceStorm::TopicPrx getTopic(const ::Ice::Context*);
	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::Context*,
			const ::IceInternal::CallbackBasePtr&,
			const ::Ice::LocalObjectPtr& __cookie = 0);

public:

	void refresh() {
		refresh(0);
	}
	void refresh(const ::Ice::Context& __ctx) {
		refresh(&__ctx);
	}
#ifdef ICE_CPP11
	::Ice::AsyncResultPtr begin_refresh(
			const ::IceInternal::Function<void()>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return begin_refresh(0,
				new ::IceInternal::Cpp11FnOnewayCallbackNC(__response,
						__exception, __sent));
	}
	::Ice::AsyncResultPtr begin_refresh(
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_refresh(0, ::Ice::newCallback(__completed, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void()>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return begin_refresh(&__ctx,
				new ::IceInternal::Cpp11FnOnewayCallbackNC(__response,
						__exception, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_refresh(&__ctx, ::Ice::newCallback(__completed, __sent));
	}
#endif

	::Ice::AsyncResultPtr begin_refresh() {
		return begin_refresh(0, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& __ctx) {
		return begin_refresh(&__ctx, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_refresh(const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_refresh(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& __ctx,
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_refresh(&__ctx, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_refresh(
			const ::cardroid::network::zerocice::Callback_Glacier2Session_refreshPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_refresh(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& __ctx,
			const ::cardroid::network::zerocice::Callback_Glacier2Session_refreshPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_refresh(&__ctx, __del, __cookie);
	}

	void end_refresh(const ::Ice::AsyncResultPtr&);

private:

	void refresh(const ::Ice::Context*);
	::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context*,
			const ::IceInternal::CallbackBasePtr&,
			const ::Ice::LocalObjectPtr& __cookie = 0);

public:

	::IceInternal::ProxyHandle<Glacier2Session> ice_context(
			const ::Ice::Context& __context) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_context(
				__context).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_adapterId(
			const ::std::string& __id) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_adapterId(
				__id).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_endpoints(
			const ::Ice::EndpointSeq& __endpoints) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_endpoints(
				__endpoints).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_locatorCacheTimeout(
			int __timeout) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(
				__timeout).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_connectionCached(
			bool __cached) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_connectionCached(
				__cached).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_endpointSelection(
			::Ice::EndpointSelectionType __est) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_endpointSelection(
				__est).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_secure(
			bool __secure) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_secure(
				__secure).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_preferSecure(
			bool __preferSecure) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_preferSecure(
				__preferSecure).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_router(
			const ::Ice::RouterPrx& __router) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_router(
				__router).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_locator(
			const ::Ice::LocatorPrx& __locator) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_locator(
				__locator).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_collocationOptimized(
			bool __co) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_collocationOptimized(
				__co).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_twoway() const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_twoway().get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_oneway() const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_oneway().get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_batchOneway() const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_batchOneway().get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_datagram() const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_datagram().get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_batchDatagram() const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_compress(
			bool __compress) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_compress(
				__compress).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_timeout(
			int __timeout) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_timeout(
				__timeout).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_connectionId(
			const ::std::string& __id) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_connectionId(
				__id).get());
	}

	::IceInternal::ProxyHandle<Glacier2Session> ice_encodingVersion(
			const ::Ice::EncodingVersion& __v) const {
		return dynamic_cast<Glacier2Session*>(::IceProxy::Ice::Object::ice_encodingVersion(
				__v).get());
	}

	static const ::std::string& ice_staticId();

private:

	virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
	virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
	virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Session: virtual public ::IceProxy::Ice::Object {
public:

	::cardroid::zerocice::CardroidManagerPrx getCardroidManager() {
		return getCardroidManager(0);
	}
	::cardroid::zerocice::CardroidManagerPrx getCardroidManager(
			const ::Ice::Context& __ctx) {
		return getCardroidManager(&__ctx);
	}
#ifdef ICE_CPP11
	::Ice::AsyncResultPtr begin_getCardroidManager(
			const ::IceInternal::Function<
					void(const ::cardroid::zerocice::CardroidManagerPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return __begin_getCardroidManager(0, __response, __exception, __sent);
	}
	::Ice::AsyncResultPtr begin_getCardroidManager(
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_getCardroidManager(0,
				::Ice::newCallback(__completed, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_getCardroidManager(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<
					void(const ::cardroid::zerocice::CardroidManagerPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return __begin_getCardroidManager(&__ctx, __response, __exception,
				__sent);
	}
	::Ice::AsyncResultPtr begin_getCardroidManager(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_getCardroidManager(&__ctx,
				::Ice::newCallback(__completed, __sent));
	}

private:

	::Ice::AsyncResultPtr __begin_getCardroidManager(
			const ::Ice::Context* __ctx,
			const ::IceInternal::Function<
					void(const ::cardroid::zerocice::CardroidManagerPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception,
			const ::IceInternal::Function<void(bool)>& __sent) {
		class Cpp11CB: public ::IceInternal::Cpp11FnCallbackNC {
		public:

			Cpp11CB(
					const ::std::function<
							void(
									const ::cardroid::zerocice::CardroidManagerPrx&)>& responseFunc,
					const ::std::function<void(const ::Ice::Exception&)>& exceptionFunc,
					const ::std::function<void(bool)>& sentFunc) :
					::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc), _response(
							responseFunc) {
				CallbackBase::checkCallback(true,
						responseFunc || exceptionFunc != nullptr);
			}

			virtual void __completed(
					const ::Ice::AsyncResultPtr& __result) const {
				::cardroid::network::zerocice::SessionPrx __proxy =
						::cardroid::network::zerocice::SessionPrx::uncheckedCast(
								__result->getProxy());
				::cardroid::zerocice::CardroidManagerPrx __ret;
				try {
					__ret = __proxy->end_getCardroidManager(__result);
				} catch (::Ice::Exception& ex) {
					Cpp11FnCallbackNC::__exception(__result, ex);
					return;
				}
				if (_response != nullptr) {
					_response(__ret);
				}
			}

		private:

			::std::function<
					void(const ::cardroid::zerocice::CardroidManagerPrx&)> _response;
		};
		return begin_getCardroidManager(__ctx,
				new Cpp11CB(__response, __exception, __sent));
	}

public:
#endif

	::Ice::AsyncResultPtr begin_getCardroidManager() {
		return begin_getCardroidManager(0, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_getCardroidManager(
			const ::Ice::Context& __ctx) {
		return begin_getCardroidManager(&__ctx, ::IceInternal::__dummyCallback,
				0);
	}

	::Ice::AsyncResultPtr begin_getCardroidManager(
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getCardroidManager(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getCardroidManager(const ::Ice::Context& __ctx,
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getCardroidManager(&__ctx, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getCardroidManager(
			const ::cardroid::network::zerocice::Callback_Session_getCardroidManagerPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getCardroidManager(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getCardroidManager(const ::Ice::Context& __ctx,
			const ::cardroid::network::zerocice::Callback_Session_getCardroidManagerPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getCardroidManager(&__ctx, __del, __cookie);
	}

	::cardroid::zerocice::CardroidManagerPrx end_getCardroidManager(
			const ::Ice::AsyncResultPtr&);

private:

	::cardroid::zerocice::CardroidManagerPrx getCardroidManager(
			const ::Ice::Context*);
	::Ice::AsyncResultPtr begin_getCardroidManager(const ::Ice::Context*,
			const ::IceInternal::CallbackBasePtr&,
			const ::Ice::LocalObjectPtr& __cookie = 0);

public:

	::IceStorm::TopicPrx getTopic() {
		return getTopic(0);
	}
	::IceStorm::TopicPrx getTopic(const ::Ice::Context& __ctx) {
		return getTopic(&__ctx);
	}
#ifdef ICE_CPP11
	::Ice::AsyncResultPtr begin_getTopic(
			const ::IceInternal::Function<void(const ::IceStorm::TopicPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return __begin_getTopic(0, __response, __exception, __sent);
	}
	::Ice::AsyncResultPtr begin_getTopic(
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_getTopic(0, ::Ice::newCallback(__completed, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::IceStorm::TopicPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return __begin_getTopic(&__ctx, __response, __exception, __sent);
	}
	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_getTopic(&__ctx, ::Ice::newCallback(__completed, __sent));
	}

private:

	::Ice::AsyncResultPtr __begin_getTopic(const ::Ice::Context* __ctx,
			const ::IceInternal::Function<void(const ::IceStorm::TopicPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception,
			const ::IceInternal::Function<void(bool)>& __sent) {
		class Cpp11CB: public ::IceInternal::Cpp11FnCallbackNC {
		public:

			Cpp11CB(
					const ::std::function<void(const ::IceStorm::TopicPrx&)>& responseFunc,
					const ::std::function<void(const ::Ice::Exception&)>& exceptionFunc,
					const ::std::function<void(bool)>& sentFunc) :
					::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc), _response(
							responseFunc) {
				CallbackBase::checkCallback(true,
						responseFunc || exceptionFunc != nullptr);
			}

			virtual void __completed(
					const ::Ice::AsyncResultPtr& __result) const {
				::cardroid::network::zerocice::SessionPrx __proxy =
						::cardroid::network::zerocice::SessionPrx::uncheckedCast(
								__result->getProxy());
				::IceStorm::TopicPrx __ret;
				try {
					__ret = __proxy->end_getTopic(__result);
				} catch (::Ice::Exception& ex) {
					Cpp11FnCallbackNC::__exception(__result, ex);
					return;
				}
				if (_response != nullptr) {
					_response(__ret);
				}
			}

		private:

			::std::function<void(const ::IceStorm::TopicPrx&)> _response;
		};
		return begin_getTopic(__ctx,
				new Cpp11CB(__response, __exception, __sent));
	}

public:
#endif

	::Ice::AsyncResultPtr begin_getTopic() {
		return begin_getTopic(0, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::Context& __ctx) {
		return begin_getTopic(&__ctx, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getTopic(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::Context& __ctx,
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getTopic(&__ctx, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getTopic(
			const ::cardroid::network::zerocice::Callback_Session_getTopicPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getTopic(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::Context& __ctx,
			const ::cardroid::network::zerocice::Callback_Session_getTopicPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getTopic(&__ctx, __del, __cookie);
	}

	::IceStorm::TopicPrx end_getTopic(const ::Ice::AsyncResultPtr&);

private:

	::IceStorm::TopicPrx getTopic(const ::Ice::Context*);
	::Ice::AsyncResultPtr begin_getTopic(const ::Ice::Context*,
			const ::IceInternal::CallbackBasePtr&,
			const ::Ice::LocalObjectPtr& __cookie = 0);

public:

	void refresh() {
		refresh(0);
	}
	void refresh(const ::Ice::Context& __ctx) {
		refresh(&__ctx);
	}
#ifdef ICE_CPP11
	::Ice::AsyncResultPtr begin_refresh(
			const ::IceInternal::Function<void()>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return begin_refresh(0,
				new ::IceInternal::Cpp11FnOnewayCallbackNC(__response,
						__exception, __sent));
	}
	::Ice::AsyncResultPtr begin_refresh(
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_refresh(0, ::Ice::newCallback(__completed, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void()>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return begin_refresh(&__ctx,
				new ::IceInternal::Cpp11FnOnewayCallbackNC(__response,
						__exception, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_refresh(&__ctx, ::Ice::newCallback(__completed, __sent));
	}
#endif

	::Ice::AsyncResultPtr begin_refresh() {
		return begin_refresh(0, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& __ctx) {
		return begin_refresh(&__ctx, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_refresh(const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_refresh(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& __ctx,
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_refresh(&__ctx, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_refresh(
			const ::cardroid::network::zerocice::Callback_Session_refreshPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_refresh(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& __ctx,
			const ::cardroid::network::zerocice::Callback_Session_refreshPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_refresh(&__ctx, __del, __cookie);
	}

	void end_refresh(const ::Ice::AsyncResultPtr&);

private:

	void refresh(const ::Ice::Context*);
	::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context*,
			const ::IceInternal::CallbackBasePtr&,
			const ::Ice::LocalObjectPtr& __cookie = 0);

public:

	void destroy() {
		destroy(0);
	}
	void destroy(const ::Ice::Context& __ctx) {
		destroy(&__ctx);
	}
#ifdef ICE_CPP11
	::Ice::AsyncResultPtr begin_destroy(
			const ::IceInternal::Function<void()>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return begin_destroy(0,
				new ::IceInternal::Cpp11FnOnewayCallbackNC(__response,
						__exception, __sent));
	}
	::Ice::AsyncResultPtr begin_destroy(
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_destroy(0, ::Ice::newCallback(__completed, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_destroy(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void()>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return begin_destroy(&__ctx,
				new ::IceInternal::Cpp11FnOnewayCallbackNC(__response,
						__exception, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_destroy(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_destroy(&__ctx, ::Ice::newCallback(__completed, __sent));
	}
#endif

	::Ice::AsyncResultPtr begin_destroy() {
		return begin_destroy(0, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_destroy(const ::Ice::Context& __ctx) {
		return begin_destroy(&__ctx, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_destroy(const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_destroy(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_destroy(const ::Ice::Context& __ctx,
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_destroy(&__ctx, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_destroy(
			const ::cardroid::network::zerocice::Callback_Session_destroyPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_destroy(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_destroy(const ::Ice::Context& __ctx,
			const ::cardroid::network::zerocice::Callback_Session_destroyPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_destroy(&__ctx, __del, __cookie);
	}

	void end_destroy(const ::Ice::AsyncResultPtr&);

private:

	void destroy(const ::Ice::Context*);
	::Ice::AsyncResultPtr begin_destroy(const ::Ice::Context*,
			const ::IceInternal::CallbackBasePtr&,
			const ::Ice::LocalObjectPtr& __cookie = 0);

public:

	::IceInternal::ProxyHandle<Session> ice_context(
			const ::Ice::Context& __context) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_context(
				__context).get());
	}

	::IceInternal::ProxyHandle<Session> ice_adapterId(
			const ::std::string& __id) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_adapterId(
				__id).get());
	}

	::IceInternal::ProxyHandle<Session> ice_endpoints(
			const ::Ice::EndpointSeq& __endpoints) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_endpoints(
				__endpoints).get());
	}

	::IceInternal::ProxyHandle<Session> ice_locatorCacheTimeout(
			int __timeout) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(
				__timeout).get());
	}

	::IceInternal::ProxyHandle<Session> ice_connectionCached(
			bool __cached) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_connectionCached(
				__cached).get());
	}

	::IceInternal::ProxyHandle<Session> ice_endpointSelection(
			::Ice::EndpointSelectionType __est) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_endpointSelection(
				__est).get());
	}

	::IceInternal::ProxyHandle<Session> ice_secure(bool __secure) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_secure(
				__secure).get());
	}

	::IceInternal::ProxyHandle<Session> ice_preferSecure(
			bool __preferSecure) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_preferSecure(
				__preferSecure).get());
	}

	::IceInternal::ProxyHandle<Session> ice_router(
			const ::Ice::RouterPrx& __router) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_router(
				__router).get());
	}

	::IceInternal::ProxyHandle<Session> ice_locator(
			const ::Ice::LocatorPrx& __locator) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_locator(
				__locator).get());
	}

	::IceInternal::ProxyHandle<Session> ice_collocationOptimized(
			bool __co) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_collocationOptimized(
				__co).get());
	}

	::IceInternal::ProxyHandle<Session> ice_twoway() const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_twoway().get());
	}

	::IceInternal::ProxyHandle<Session> ice_oneway() const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_oneway().get());
	}

	::IceInternal::ProxyHandle<Session> ice_batchOneway() const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_batchOneway().get());
	}

	::IceInternal::ProxyHandle<Session> ice_datagram() const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_datagram().get());
	}

	::IceInternal::ProxyHandle<Session> ice_batchDatagram() const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
	}

	::IceInternal::ProxyHandle<Session> ice_compress(bool __compress) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_compress(
				__compress).get());
	}

	::IceInternal::ProxyHandle<Session> ice_timeout(int __timeout) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_timeout(
				__timeout).get());
	}

	::IceInternal::ProxyHandle<Session> ice_connectionId(
			const ::std::string& __id) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_connectionId(
				__id).get());
	}

	::IceInternal::ProxyHandle<Session> ice_encodingVersion(
			const ::Ice::EncodingVersion& __v) const {
		return dynamic_cast<Session*>(::IceProxy::Ice::Object::ice_encodingVersion(
				__v).get());
	}

	static const ::std::string& ice_staticId();

private:

	virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
	virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
	virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class SessionFactory: virtual public ::IceProxy::Ice::Object {
public:

	::cardroid::network::zerocice::SessionPrx create() {
		return create(0);
	}
	::cardroid::network::zerocice::SessionPrx create(
			const ::Ice::Context& __ctx) {
		return create(&__ctx);
	}
#ifdef ICE_CPP11
	::Ice::AsyncResultPtr begin_create(
			const ::IceInternal::Function<
					void(const ::cardroid::network::zerocice::SessionPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return __begin_create(0, __response, __exception, __sent);
	}
	::Ice::AsyncResultPtr begin_create(
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_create(0, ::Ice::newCallback(__completed, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_create(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<
					void(const ::cardroid::network::zerocice::SessionPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return __begin_create(&__ctx, __response, __exception, __sent);
	}
	::Ice::AsyncResultPtr begin_create(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_create(&__ctx, ::Ice::newCallback(__completed, __sent));
	}

private:

	::Ice::AsyncResultPtr __begin_create(const ::Ice::Context* __ctx,
			const ::IceInternal::Function<
					void(const ::cardroid::network::zerocice::SessionPrx&)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception,
			const ::IceInternal::Function<void(bool)>& __sent) {
		class Cpp11CB: public ::IceInternal::Cpp11FnCallbackNC {
		public:

			Cpp11CB(
					const ::std::function<
							void(
									const ::cardroid::network::zerocice::SessionPrx&)>& responseFunc,
					const ::std::function<void(const ::Ice::Exception&)>& exceptionFunc,
					const ::std::function<void(bool)>& sentFunc) :
					::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc), _response(
							responseFunc) {
				CallbackBase::checkCallback(true,
						responseFunc || exceptionFunc != nullptr);
			}

			virtual void __completed(
					const ::Ice::AsyncResultPtr& __result) const {
				::cardroid::network::zerocice::SessionFactoryPrx __proxy =
						::cardroid::network::zerocice::SessionFactoryPrx::uncheckedCast(
								__result->getProxy());
				::cardroid::network::zerocice::SessionPrx __ret;
				try {
					__ret = __proxy->end_create(__result);
				} catch (::Ice::Exception& ex) {
					Cpp11FnCallbackNC::__exception(__result, ex);
					return;
				}
				if (_response != nullptr) {
					_response(__ret);
				}
			}

		private:

			::std::function<
					void(const ::cardroid::network::zerocice::SessionPrx&)> _response;
		};
		return begin_create(__ctx, new Cpp11CB(__response, __exception, __sent));
	}

public:
#endif

	::Ice::AsyncResultPtr begin_create() {
		return begin_create(0, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_create(const ::Ice::Context& __ctx) {
		return begin_create(&__ctx, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_create(const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_create(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_create(const ::Ice::Context& __ctx,
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_create(&__ctx, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_create(
			const ::cardroid::network::zerocice::Callback_SessionFactory_createPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_create(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_create(const ::Ice::Context& __ctx,
			const ::cardroid::network::zerocice::Callback_SessionFactory_createPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_create(&__ctx, __del, __cookie);
	}

	::cardroid::network::zerocice::SessionPrx end_create(
			const ::Ice::AsyncResultPtr&);

private:

	::cardroid::network::zerocice::SessionPrx create(const ::Ice::Context*);
	::Ice::AsyncResultPtr begin_create(const ::Ice::Context*,
			const ::IceInternal::CallbackBasePtr&,
			const ::Ice::LocalObjectPtr& __cookie = 0);

public:

	::Ice::Long getSessionTimeout() {
		return getSessionTimeout(0);
	}
	::Ice::Long getSessionTimeout(const ::Ice::Context& __ctx) {
		return getSessionTimeout(&__ctx);
	}
#ifdef ICE_CPP11
	::Ice::AsyncResultPtr begin_getSessionTimeout(
			const ::IceInternal::Function<void(::Ice::Long)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return __begin_getSessionTimeout(0, __response, __exception, __sent);
	}
	::Ice::AsyncResultPtr begin_getSessionTimeout(
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_getSessionTimeout(0,
				::Ice::newCallback(__completed, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_getSessionTimeout(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(::Ice::Long)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return __begin_getSessionTimeout(&__ctx, __response, __exception,
				__sent);
	}
	::Ice::AsyncResultPtr begin_getSessionTimeout(const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_getSessionTimeout(&__ctx,
				::Ice::newCallback(__completed, __sent));
	}

private:

	::Ice::AsyncResultPtr __begin_getSessionTimeout(const ::Ice::Context* __ctx,
			const ::IceInternal::Function<void(::Ice::Long)>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception,
			const ::IceInternal::Function<void(bool)>& __sent) {
		class Cpp11CB: public ::IceInternal::Cpp11FnCallbackNC {
		public:

			Cpp11CB(const ::std::function<void(::Ice::Long)>& responseFunc,
					const ::std::function<void(const ::Ice::Exception&)>& exceptionFunc,
					const ::std::function<void(bool)>& sentFunc) :
					::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc), _response(
							responseFunc) {
				CallbackBase::checkCallback(true,
						responseFunc || exceptionFunc != nullptr);
			}

			virtual void __completed(
					const ::Ice::AsyncResultPtr& __result) const {
				::cardroid::network::zerocice::SessionFactoryPrx __proxy =
						::cardroid::network::zerocice::SessionFactoryPrx::uncheckedCast(
								__result->getProxy());
				::Ice::Long __ret;
				try {
					__ret = __proxy->end_getSessionTimeout(__result);
				} catch (::Ice::Exception& ex) {
					Cpp11FnCallbackNC::__exception(__result, ex);
					return;
				}
				if (_response != nullptr) {
					_response(__ret);
				}
			}

		private:

			::std::function<void(::Ice::Long)> _response;
		};
		return begin_getSessionTimeout(__ctx,
				new Cpp11CB(__response, __exception, __sent));
	}

public:
#endif

	::Ice::AsyncResultPtr begin_getSessionTimeout() {
		return begin_getSessionTimeout(0, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_getSessionTimeout(const ::Ice::Context& __ctx) {
		return begin_getSessionTimeout(&__ctx, ::IceInternal::__dummyCallback,
				0);
	}

	::Ice::AsyncResultPtr begin_getSessionTimeout(
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getSessionTimeout(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getSessionTimeout(const ::Ice::Context& __ctx,
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getSessionTimeout(&__ctx, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getSessionTimeout(
			const ::cardroid::network::zerocice::Callback_SessionFactory_getSessionTimeoutPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getSessionTimeout(0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_getSessionTimeout(const ::Ice::Context& __ctx,
			const ::cardroid::network::zerocice::Callback_SessionFactory_getSessionTimeoutPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_getSessionTimeout(&__ctx, __del, __cookie);
	}

	::Ice::Long end_getSessionTimeout(const ::Ice::AsyncResultPtr&);

private:

	::Ice::Long getSessionTimeout(const ::Ice::Context*);
	::Ice::AsyncResultPtr begin_getSessionTimeout(const ::Ice::Context*,
			const ::IceInternal::CallbackBasePtr&,
			const ::Ice::LocalObjectPtr& __cookie = 0);

public:

	::IceInternal::ProxyHandle<SessionFactory> ice_context(
			const ::Ice::Context& __context) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_context(
				__context).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_adapterId(
			const ::std::string& __id) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_adapterId(
				__id).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_endpoints(
			const ::Ice::EndpointSeq& __endpoints) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_endpoints(
				__endpoints).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_locatorCacheTimeout(
			int __timeout) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(
				__timeout).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_connectionCached(
			bool __cached) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_connectionCached(
				__cached).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_endpointSelection(
			::Ice::EndpointSelectionType __est) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_endpointSelection(
				__est).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_secure(bool __secure) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_secure(
				__secure).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_preferSecure(
			bool __preferSecure) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_preferSecure(
				__preferSecure).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_router(
			const ::Ice::RouterPrx& __router) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_router(
				__router).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_locator(
			const ::Ice::LocatorPrx& __locator) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_locator(
				__locator).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_collocationOptimized(
			bool __co) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_collocationOptimized(
				__co).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_twoway() const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_twoway().get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_oneway() const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_oneway().get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_batchOneway() const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_batchOneway().get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_datagram() const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_datagram().get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_batchDatagram() const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_compress(
			bool __compress) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_compress(
				__compress).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_timeout(
			int __timeout) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_timeout(
				__timeout).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_connectionId(
			const ::std::string& __id) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_connectionId(
				__id).get());
	}

	::IceInternal::ProxyHandle<SessionFactory> ice_encodingVersion(
			const ::Ice::EncodingVersion& __v) const {
		return dynamic_cast<SessionFactory*>(::IceProxy::Ice::Object::ice_encodingVersion(
				__v).get());
	}

	static const ::std::string& ice_staticId();

private:

	virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
	virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
	virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class CardroidEventStorm: virtual public ::IceProxy::Ice::Object {
public:

	void notify(const ::cardroid::data::zerocice::UserActivityTypPrx& action) {
		notify(action, 0);
	}
	void notify(const ::cardroid::data::zerocice::UserActivityTypPrx& action,
			const ::Ice::Context& __ctx) {
		notify(action, &__ctx);
	}
#ifdef ICE_CPP11
	::Ice::AsyncResultPtr begin_notify(
			const ::cardroid::data::zerocice::UserActivityTypPrx& action,
			const ::IceInternal::Function<void()>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return begin_notify(action, 0,
				new ::IceInternal::Cpp11FnOnewayCallbackNC(__response,
						__exception, __sent));
	}
	::Ice::AsyncResultPtr begin_notify(
			const ::cardroid::data::zerocice::UserActivityTypPrx& action,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_notify(action, 0, ::Ice::newCallback(__completed, __sent),
				0);
	}
	::Ice::AsyncResultPtr begin_notify(
			const ::cardroid::data::zerocice::UserActivityTypPrx& action,
			const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void()>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return begin_notify(action, &__ctx,
				new ::IceInternal::Cpp11FnOnewayCallbackNC(__response,
						__exception, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_notify(
			const ::cardroid::data::zerocice::UserActivityTypPrx& action,
			const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_notify(action, &__ctx,
				::Ice::newCallback(__completed, __sent));
	}
#endif

	::Ice::AsyncResultPtr begin_notify(
			const ::cardroid::data::zerocice::UserActivityTypPrx& action) {
		return begin_notify(action, 0, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_notify(
			const ::cardroid::data::zerocice::UserActivityTypPrx& action,
			const ::Ice::Context& __ctx) {
		return begin_notify(action, &__ctx, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_notify(
			const ::cardroid::data::zerocice::UserActivityTypPrx& action,
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_notify(action, 0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_notify(
			const ::cardroid::data::zerocice::UserActivityTypPrx& action,
			const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_notify(action, &__ctx, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_notify(
			const ::cardroid::data::zerocice::UserActivityTypPrx& action,
			const ::cardroid::network::zerocice::Callback_CardroidEventStorm_notifyPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_notify(action, 0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_notify(
			const ::cardroid::data::zerocice::UserActivityTypPrx& action,
			const ::Ice::Context& __ctx,
			const ::cardroid::network::zerocice::Callback_CardroidEventStorm_notifyPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_notify(action, &__ctx, __del, __cookie);
	}

	void end_notify(const ::Ice::AsyncResultPtr&);

private:

	void notify(const ::cardroid::data::zerocice::UserActivityTypPrx&,
			const ::Ice::Context*);
	::Ice::AsyncResultPtr begin_notify(
			const ::cardroid::data::zerocice::UserActivityTypPrx&,
			const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&,
			const ::Ice::LocalObjectPtr& __cookie = 0);

public:

	void message(const ::cardroid::data::zerocice::MessageTypPrx& msg) {
		message(msg, 0);
	}
	void message(const ::cardroid::data::zerocice::MessageTypPrx& msg,
			const ::Ice::Context& __ctx) {
		message(msg, &__ctx);
	}
#ifdef ICE_CPP11
	::Ice::AsyncResultPtr begin_message(
			const ::cardroid::data::zerocice::MessageTypPrx& msg,
			const ::IceInternal::Function<void()>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return begin_message(msg, 0,
				new ::IceInternal::Cpp11FnOnewayCallbackNC(__response,
						__exception, __sent));
	}
	::Ice::AsyncResultPtr begin_message(
			const ::cardroid::data::zerocice::MessageTypPrx& msg,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_message(msg, 0, ::Ice::newCallback(__completed, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_message(
			const ::cardroid::data::zerocice::MessageTypPrx& msg,
			const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void()>& __response,
			const ::IceInternal::Function<void(const ::Ice::Exception&)>& __exception =
					::IceInternal::Function<void(const ::Ice::Exception&)>(),
			const ::IceInternal::Function<void(bool)>& __sent =
					::IceInternal::Function<void(bool)>()) {
		return begin_message(msg, &__ctx,
				new ::IceInternal::Cpp11FnOnewayCallbackNC(__response,
						__exception, __sent), 0);
	}
	::Ice::AsyncResultPtr begin_message(
			const ::cardroid::data::zerocice::MessageTypPrx& msg,
			const ::Ice::Context& __ctx,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __completed,
			const ::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>& __sent =
					::IceInternal::Function<void(const ::Ice::AsyncResultPtr&)>()) {
		return begin_message(msg, &__ctx,
				::Ice::newCallback(__completed, __sent));
	}
#endif

	::Ice::AsyncResultPtr begin_message(
			const ::cardroid::data::zerocice::MessageTypPrx& msg) {
		return begin_message(msg, 0, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_message(
			const ::cardroid::data::zerocice::MessageTypPrx& msg,
			const ::Ice::Context& __ctx) {
		return begin_message(msg, &__ctx, ::IceInternal::__dummyCallback, 0);
	}

	::Ice::AsyncResultPtr begin_message(
			const ::cardroid::data::zerocice::MessageTypPrx& msg,
			const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_message(msg, 0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_message(
			const ::cardroid::data::zerocice::MessageTypPrx& msg,
			const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_message(msg, &__ctx, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_message(
			const ::cardroid::data::zerocice::MessageTypPrx& msg,
			const ::cardroid::network::zerocice::Callback_CardroidEventStorm_messagePtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_message(msg, 0, __del, __cookie);
	}

	::Ice::AsyncResultPtr begin_message(
			const ::cardroid::data::zerocice::MessageTypPrx& msg,
			const ::Ice::Context& __ctx,
			const ::cardroid::network::zerocice::Callback_CardroidEventStorm_messagePtr& __del,
			const ::Ice::LocalObjectPtr& __cookie = 0) {
		return begin_message(msg, &__ctx, __del, __cookie);
	}

	void end_message(const ::Ice::AsyncResultPtr&);

private:

	void message(const ::cardroid::data::zerocice::MessageTypPrx&,
			const ::Ice::Context*);
	::Ice::AsyncResultPtr begin_message(
			const ::cardroid::data::zerocice::MessageTypPrx&,
			const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&,
			const ::Ice::LocalObjectPtr& __cookie = 0);

public:

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_context(
			const ::Ice::Context& __context) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_context(
				__context).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_adapterId(
			const ::std::string& __id) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_adapterId(
				__id).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_endpoints(
			const ::Ice::EndpointSeq& __endpoints) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_endpoints(
				__endpoints).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_locatorCacheTimeout(
			int __timeout) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(
				__timeout).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_connectionCached(
			bool __cached) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_connectionCached(
				__cached).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_endpointSelection(
			::Ice::EndpointSelectionType __est) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_endpointSelection(
				__est).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_secure(
			bool __secure) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_secure(
				__secure).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_preferSecure(
			bool __preferSecure) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_preferSecure(
				__preferSecure).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_router(
			const ::Ice::RouterPrx& __router) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_router(
				__router).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_locator(
			const ::Ice::LocatorPrx& __locator) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_locator(
				__locator).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_collocationOptimized(
			bool __co) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_collocationOptimized(
				__co).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_twoway() const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_twoway().get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_oneway() const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_oneway().get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_batchOneway() const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_batchOneway().get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_datagram() const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_datagram().get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_batchDatagram() const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_compress(
			bool __compress) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_compress(
				__compress).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_timeout(
			int __timeout) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_timeout(
				__timeout).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_connectionId(
			const ::std::string& __id) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_connectionId(
				__id).get());
	}

	::IceInternal::ProxyHandle<CardroidEventStorm> ice_encodingVersion(
			const ::Ice::EncodingVersion& __v) const {
		return dynamic_cast<CardroidEventStorm*>(::IceProxy::Ice::Object::ice_encodingVersion(
				__v).get());
	}

	static const ::std::string& ice_staticId();

private:

	virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
	virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
	virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

}

namespace IceDelegate {

namespace cardroid {

namespace network {

namespace zerocice {

class Glacier2Session: virtual public ::IceDelegate::Glacier2::Session {
public:

	virtual ::cardroid::zerocice::CardroidManagerPrx getCardroidManager(
			const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

	virtual ::IceStorm::TopicPrx getTopic(const ::Ice::Context*,
			::IceInternal::InvocationObserver&) = 0;

	virtual void refresh(const ::Ice::Context*,
			::IceInternal::InvocationObserver&) = 0;
};

class Session: virtual public ::IceDelegate::Ice::Object {
public:

	virtual ::cardroid::zerocice::CardroidManagerPrx getCardroidManager(
			const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

	virtual ::IceStorm::TopicPrx getTopic(const ::Ice::Context*,
			::IceInternal::InvocationObserver&) = 0;

	virtual void refresh(const ::Ice::Context*,
			::IceInternal::InvocationObserver&) = 0;

	virtual void destroy(const ::Ice::Context*,
			::IceInternal::InvocationObserver&) = 0;
};

class SessionFactory: virtual public ::IceDelegate::Ice::Object {
public:

	virtual ::cardroid::network::zerocice::SessionPrx create(
			const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

	virtual ::Ice::Long getSessionTimeout(const ::Ice::Context*,
			::IceInternal::InvocationObserver&) = 0;
};

class CardroidEventStorm: virtual public ::IceDelegate::Ice::Object {
public:

	virtual void notify(const ::cardroid::data::zerocice::UserActivityTypPrx&,
			const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

	virtual void message(const ::cardroid::data::zerocice::MessageTypPrx&,
			const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

}

}

namespace IceDelegateM {

namespace cardroid {

namespace network {

namespace zerocice {

class Glacier2Session: virtual public ::IceDelegate::cardroid::network::zerocice::Glacier2Session,
		virtual public ::IceDelegateM::Glacier2::Session {
public:

	virtual ::cardroid::zerocice::CardroidManagerPrx getCardroidManager(
			const ::Ice::Context*, ::IceInternal::InvocationObserver&);

	virtual ::IceStorm::TopicPrx getTopic(const ::Ice::Context*,
			::IceInternal::InvocationObserver&);

	virtual void refresh(const ::Ice::Context*,
			::IceInternal::InvocationObserver&);
};

class Session: virtual public ::IceDelegate::cardroid::network::zerocice::Session,
		virtual public ::IceDelegateM::Ice::Object {
public:

	virtual ::cardroid::zerocice::CardroidManagerPrx getCardroidManager(
			const ::Ice::Context*, ::IceInternal::InvocationObserver&);

	virtual ::IceStorm::TopicPrx getTopic(const ::Ice::Context*,
			::IceInternal::InvocationObserver&);

	virtual void refresh(const ::Ice::Context*,
			::IceInternal::InvocationObserver&);

	virtual void destroy(const ::Ice::Context*,
			::IceInternal::InvocationObserver&);
};

class SessionFactory: virtual public ::IceDelegate::cardroid::network::zerocice::SessionFactory,
		virtual public ::IceDelegateM::Ice::Object {
public:

	virtual ::cardroid::network::zerocice::SessionPrx create(
			const ::Ice::Context*, ::IceInternal::InvocationObserver&);

	virtual ::Ice::Long getSessionTimeout(const ::Ice::Context*,
			::IceInternal::InvocationObserver&);
};

class CardroidEventStorm: virtual public ::IceDelegate::cardroid::network::zerocice::CardroidEventStorm,
		virtual public ::IceDelegateM::Ice::Object {
public:

	virtual void notify(const ::cardroid::data::zerocice::UserActivityTypPrx&,
			const ::Ice::Context*, ::IceInternal::InvocationObserver&);

	virtual void message(const ::cardroid::data::zerocice::MessageTypPrx&,
			const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

}

namespace IceDelegateD {

namespace cardroid {

namespace network {

namespace zerocice {

class Glacier2Session: virtual public ::IceDelegate::cardroid::network::zerocice::Glacier2Session,
		virtual public ::IceDelegateD::Glacier2::Session {
public:

	virtual ::cardroid::zerocice::CardroidManagerPrx getCardroidManager(
			const ::Ice::Context*, ::IceInternal::InvocationObserver&);

	virtual ::IceStorm::TopicPrx getTopic(const ::Ice::Context*,
			::IceInternal::InvocationObserver&);

	virtual void refresh(const ::Ice::Context*,
			::IceInternal::InvocationObserver&);
};

class Session: virtual public ::IceDelegate::cardroid::network::zerocice::Session,
		virtual public ::IceDelegateD::Ice::Object {
public:

	virtual ::cardroid::zerocice::CardroidManagerPrx getCardroidManager(
			const ::Ice::Context*, ::IceInternal::InvocationObserver&);

	virtual ::IceStorm::TopicPrx getTopic(const ::Ice::Context*,
			::IceInternal::InvocationObserver&);

	virtual void refresh(const ::Ice::Context*,
			::IceInternal::InvocationObserver&);

	virtual void destroy(const ::Ice::Context*,
			::IceInternal::InvocationObserver&);
};

class SessionFactory: virtual public ::IceDelegate::cardroid::network::zerocice::SessionFactory,
		virtual public ::IceDelegateD::Ice::Object {
public:

	virtual ::cardroid::network::zerocice::SessionPrx create(
			const ::Ice::Context*, ::IceInternal::InvocationObserver&);

	virtual ::Ice::Long getSessionTimeout(const ::Ice::Context*,
			::IceInternal::InvocationObserver&);
};

class CardroidEventStorm: virtual public ::IceDelegate::cardroid::network::zerocice::CardroidEventStorm,
		virtual public ::IceDelegateD::Ice::Object {
public:

	virtual void notify(const ::cardroid::data::zerocice::UserActivityTypPrx&,
			const ::Ice::Context*, ::IceInternal::InvocationObserver&);

	virtual void message(const ::cardroid::data::zerocice::MessageTypPrx&,
			const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

}

namespace cardroid {

namespace network {

namespace zerocice {

class Glacier2Session: virtual public ::Glacier2::Session {
public:

	typedef Glacier2SessionPrx ProxyType;
	typedef Glacier2SessionPtr PointerType;

	virtual bool ice_isA(const ::std::string&, const ::Ice::Current& =
			::Ice::Current()) const;
	virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& =
			::Ice::Current()) const;
	virtual const ::std::string& ice_id(const ::Ice::Current& =
			::Ice::Current()) const;
	static const ::std::string& ice_staticId();

	virtual ::cardroid::zerocice::CardroidManagerPrx getCardroidManager(
			const ::Ice::Current& = ::Ice::Current()) = 0;
	::Ice::DispatchStatus ___getCardroidManager(::IceInternal::Incoming&,
			const ::Ice::Current&);

	virtual ::IceStorm::TopicPrx getTopic(const ::Ice::Current& =
			::Ice::Current()) = 0;
	::Ice::DispatchStatus ___getTopic(::IceInternal::Incoming&,
			const ::Ice::Current&);

	virtual void refresh(const ::Ice::Current& = ::Ice::Current()) = 0;
	::Ice::DispatchStatus ___refresh(::IceInternal::Incoming&,
			const ::Ice::Current&);

	virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&,
			const ::Ice::Current&);

protected:
	virtual void __writeImpl(::IceInternal::BasicStream*) const;
	virtual void __readImpl(::IceInternal::BasicStream*);
#ifdef __SUNPRO_CC
	using ::Ice::Object::__writeImpl;
	using ::Ice::Object::__readImpl;
#endif
};

inline bool operator==(const Glacier2Session& l, const Glacier2Session& r) {
	return static_cast<const ::Ice::Object&>(l)
			== static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Glacier2Session& l, const Glacier2Session& r) {
	return static_cast<const ::Ice::Object&>(l)
			< static_cast<const ::Ice::Object&>(r);
}

class Session: virtual public ::Ice::Object {
public:

	typedef SessionPrx ProxyType;
	typedef SessionPtr PointerType;

	virtual bool ice_isA(const ::std::string&, const ::Ice::Current& =
			::Ice::Current()) const;
	virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& =
			::Ice::Current()) const;
	virtual const ::std::string& ice_id(const ::Ice::Current& =
			::Ice::Current()) const;
	static const ::std::string& ice_staticId();

	virtual ::cardroid::zerocice::CardroidManagerPrx getCardroidManager(
			const ::Ice::Current& = ::Ice::Current()) = 0;
	::Ice::DispatchStatus ___getCardroidManager(::IceInternal::Incoming&,
			const ::Ice::Current&);

	virtual ::IceStorm::TopicPrx getTopic(const ::Ice::Current& =
			::Ice::Current()) = 0;
	::Ice::DispatchStatus ___getTopic(::IceInternal::Incoming&,
			const ::Ice::Current&);

	virtual void refresh(const ::Ice::Current& = ::Ice::Current()) = 0;
	::Ice::DispatchStatus ___refresh(::IceInternal::Incoming&,
			const ::Ice::Current&);

	virtual void destroy(const ::Ice::Current& = ::Ice::Current()) = 0;
	::Ice::DispatchStatus ___destroy(::IceInternal::Incoming&,
			const ::Ice::Current&);

	virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&,
			const ::Ice::Current&);

protected:
	virtual void __writeImpl(::IceInternal::BasicStream*) const;
	virtual void __readImpl(::IceInternal::BasicStream*);
#ifdef __SUNPRO_CC
	using ::Ice::Object::__writeImpl;
	using ::Ice::Object::__readImpl;
#endif
};

inline bool operator==(const Session& l, const Session& r) {
	return static_cast<const ::Ice::Object&>(l)
			== static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Session& l, const Session& r) {
	return static_cast<const ::Ice::Object&>(l)
			< static_cast<const ::Ice::Object&>(r);
}

class SessionFactory: virtual public ::Ice::Object {
public:

	typedef SessionFactoryPrx ProxyType;
	typedef SessionFactoryPtr PointerType;

	virtual bool ice_isA(const ::std::string&, const ::Ice::Current& =
			::Ice::Current()) const;
	virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& =
			::Ice::Current()) const;
	virtual const ::std::string& ice_id(const ::Ice::Current& =
			::Ice::Current()) const;
	static const ::std::string& ice_staticId();

	virtual ::cardroid::network::zerocice::SessionPrx create(
			const ::Ice::Current& = ::Ice::Current()) = 0;
	::Ice::DispatchStatus ___create(::IceInternal::Incoming&,
			const ::Ice::Current&);

	virtual ::Ice::Long getSessionTimeout(const ::Ice::Current& =
			::Ice::Current()) = 0;
	::Ice::DispatchStatus ___getSessionTimeout(::IceInternal::Incoming&,
			const ::Ice::Current&);

	virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&,
			const ::Ice::Current&);

protected:
	virtual void __writeImpl(::IceInternal::BasicStream*) const;
	virtual void __readImpl(::IceInternal::BasicStream*);
#ifdef __SUNPRO_CC
	using ::Ice::Object::__writeImpl;
	using ::Ice::Object::__readImpl;
#endif
};

inline bool operator==(const SessionFactory& l, const SessionFactory& r) {
	return static_cast<const ::Ice::Object&>(l)
			== static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SessionFactory& l, const SessionFactory& r) {
	return static_cast<const ::Ice::Object&>(l)
			< static_cast<const ::Ice::Object&>(r);
}

class CardroidEventStorm: virtual public ::Ice::Object {
public:

	typedef CardroidEventStormPrx ProxyType;
	typedef CardroidEventStormPtr PointerType;

	virtual bool ice_isA(const ::std::string&, const ::Ice::Current& =
			::Ice::Current()) const;
	virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& =
			::Ice::Current()) const;
	virtual const ::std::string& ice_id(const ::Ice::Current& =
			::Ice::Current()) const;
	static const ::std::string& ice_staticId();

	virtual void notify(const ::cardroid::data::zerocice::UserActivityTypPrx&,
			const ::Ice::Current& = ::Ice::Current()) = 0;
	::Ice::DispatchStatus ___notify(::IceInternal::Incoming&,
			const ::Ice::Current&);

	virtual void message(const ::cardroid::data::zerocice::MessageTypPrx&,
			const ::Ice::Current& = ::Ice::Current()) = 0;
	::Ice::DispatchStatus ___message(::IceInternal::Incoming&,
			const ::Ice::Current&);

	virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&,
			const ::Ice::Current&);

protected:
	virtual void __writeImpl(::IceInternal::BasicStream*) const;
	virtual void __readImpl(::IceInternal::BasicStream*);
#ifdef __SUNPRO_CC
	using ::Ice::Object::__writeImpl;
	using ::Ice::Object::__readImpl;
#endif
};

inline bool operator==(const CardroidEventStorm& l,
		const CardroidEventStorm& r) {
	return static_cast<const ::Ice::Object&>(l)
			== static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const CardroidEventStorm& l,
		const CardroidEventStorm& r) {
	return static_cast<const ::Ice::Object&>(l)
			< static_cast<const ::Ice::Object&>(r);
}

}

}

}

namespace cardroid {

namespace network {

namespace zerocice {

template<class T>
class CallbackNC_Glacier2Session_getCardroidManager: public Callback_Glacier2Session_getCardroidManager_Base,
		public ::IceInternal::TwowayCallbackNC<T> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&);
	typedef void (T::*Sent)(bool);
	typedef void (T::*Response)(
			const ::cardroid::zerocice::CardroidManagerPrx&);

	CallbackNC_Glacier2Session_getCardroidManager(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(
					cb) {
	}

	virtual void __completed(const ::Ice::AsyncResultPtr& __result) const {
		::cardroid::network::zerocice::Glacier2SessionPrx __proxy =
				::cardroid::network::zerocice::Glacier2SessionPrx::uncheckedCast(
						__result->getProxy());
		::cardroid::zerocice::CardroidManagerPrx __ret;
		try {
			__ret = __proxy->end_getCardroidManager(__result);
		} catch (::Ice::Exception& ex) {
			::IceInternal::CallbackNC<T>::__exception(__result, ex);
			return;
		}
		if (response) {
			(::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
		}
	}

	Response response;
};

template<class T> Callback_Glacier2Session_getCardroidManagerPtr newCallback_Glacier2Session_getCardroidManager(
		const IceUtil::Handle<T>& instance,
		void (T::*cb)(const ::cardroid::zerocice::CardroidManagerPrx&),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Glacier2Session_getCardroidManager<T>(instance, cb,
			excb, sentcb);
}

template<class T> Callback_Glacier2Session_getCardroidManagerPtr newCallback_Glacier2Session_getCardroidManager(
		T* instance,
		void (T::*cb)(const ::cardroid::zerocice::CardroidManagerPrx&),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Glacier2Session_getCardroidManager<T>(instance, cb,
			excb, sentcb);
}

template<class T, typename CT>
class Callback_Glacier2Session_getCardroidManager: public Callback_Glacier2Session_getCardroidManager_Base,
		public ::IceInternal::TwowayCallback<T, CT> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&, const CT&);
	typedef void (T::*Sent)(bool, const CT&);
	typedef void (T::*Response)(const ::cardroid::zerocice::CardroidManagerPrx&,
			const CT&);

	Callback_Glacier2Session_getCardroidManager(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(
					cb) {
	}

	virtual void __completed(const ::Ice::AsyncResultPtr& __result) const {
		::cardroid::network::zerocice::Glacier2SessionPrx __proxy =
				::cardroid::network::zerocice::Glacier2SessionPrx::uncheckedCast(
						__result->getProxy());
		::cardroid::zerocice::CardroidManagerPrx __ret;
		try {
			__ret = __proxy->end_getCardroidManager(__result);
		} catch (::Ice::Exception& ex) {
			::IceInternal::Callback<T, CT>::__exception(__result, ex);
			return;
		}
		if (response) {
			(::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret,
					CT::dynamicCast(__result->getCookie()));
		}
	}

	Response response;
};

template<class T, typename CT> Callback_Glacier2Session_getCardroidManagerPtr newCallback_Glacier2Session_getCardroidManager(
		const IceUtil::Handle<T>& instance,
		void (T::*cb)(const ::cardroid::zerocice::CardroidManagerPrx&,
				const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Glacier2Session_getCardroidManager<T, CT>(instance, cb,
			excb, sentcb);
}

template<class T, typename CT> Callback_Glacier2Session_getCardroidManagerPtr newCallback_Glacier2Session_getCardroidManager(
		T* instance,
		void (T::*cb)(const ::cardroid::zerocice::CardroidManagerPrx&,
				const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Glacier2Session_getCardroidManager<T, CT>(instance, cb,
			excb, sentcb);
}

template<class T>
class CallbackNC_Glacier2Session_getTopic: public Callback_Glacier2Session_getTopic_Base,
		public ::IceInternal::TwowayCallbackNC<T> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&);
	typedef void (T::*Sent)(bool);
	typedef void (T::*Response)(const ::IceStorm::TopicPrx&);

	CallbackNC_Glacier2Session_getTopic(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(
					cb) {
	}

	virtual void __completed(const ::Ice::AsyncResultPtr& __result) const {
		::cardroid::network::zerocice::Glacier2SessionPrx __proxy =
				::cardroid::network::zerocice::Glacier2SessionPrx::uncheckedCast(
						__result->getProxy());
		::IceStorm::TopicPrx __ret;
		try {
			__ret = __proxy->end_getTopic(__result);
		} catch (::Ice::Exception& ex) {
			::IceInternal::CallbackNC<T>::__exception(__result, ex);
			return;
		}
		if (response) {
			(::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
		}
	}

	Response response;
};

template<class T> Callback_Glacier2Session_getTopicPtr newCallback_Glacier2Session_getTopic(
		const IceUtil::Handle<T>& instance,
		void (T::*cb)(const ::IceStorm::TopicPrx&),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Glacier2Session_getTopic<T>(instance, cb, excb,
			sentcb);
}

template<class T> Callback_Glacier2Session_getTopicPtr newCallback_Glacier2Session_getTopic(
		T* instance, void (T::*cb)(const ::IceStorm::TopicPrx&),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Glacier2Session_getTopic<T>(instance, cb, excb,
			sentcb);
}

template<class T, typename CT>
class Callback_Glacier2Session_getTopic: public Callback_Glacier2Session_getTopic_Base,
		public ::IceInternal::TwowayCallback<T, CT> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&, const CT&);
	typedef void (T::*Sent)(bool, const CT&);
	typedef void (T::*Response)(const ::IceStorm::TopicPrx&, const CT&);

	Callback_Glacier2Session_getTopic(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(
					cb) {
	}

	virtual void __completed(const ::Ice::AsyncResultPtr& __result) const {
		::cardroid::network::zerocice::Glacier2SessionPrx __proxy =
				::cardroid::network::zerocice::Glacier2SessionPrx::uncheckedCast(
						__result->getProxy());
		::IceStorm::TopicPrx __ret;
		try {
			__ret = __proxy->end_getTopic(__result);
		} catch (::Ice::Exception& ex) {
			::IceInternal::Callback<T, CT>::__exception(__result, ex);
			return;
		}
		if (response) {
			(::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret,
					CT::dynamicCast(__result->getCookie()));
		}
	}

	Response response;
};

template<class T, typename CT> Callback_Glacier2Session_getTopicPtr newCallback_Glacier2Session_getTopic(
		const IceUtil::Handle<T>& instance,
		void (T::*cb)(const ::IceStorm::TopicPrx&, const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Glacier2Session_getTopic<T, CT>(instance, cb, excb,
			sentcb);
}

template<class T, typename CT> Callback_Glacier2Session_getTopicPtr newCallback_Glacier2Session_getTopic(
		T* instance, void (T::*cb)(const ::IceStorm::TopicPrx&, const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Glacier2Session_getTopic<T, CT>(instance, cb, excb,
			sentcb);
}

template<class T>
class CallbackNC_Glacier2Session_refresh: public Callback_Glacier2Session_refresh_Base,
		public ::IceInternal::OnewayCallbackNC<T> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&);
	typedef void (T::*Sent)(bool);
	typedef void (T::*Response)();

	CallbackNC_Glacier2Session_refresh(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb) {
	}
};

template<class T> Callback_Glacier2Session_refreshPtr newCallback_Glacier2Session_refresh(
		const IceUtil::Handle<T>& instance, void (T::*cb)(),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Glacier2Session_refresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Glacier2Session_refreshPtr newCallback_Glacier2Session_refresh(
		const IceUtil::Handle<T>& instance,
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Glacier2Session_refresh<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Glacier2Session_refreshPtr newCallback_Glacier2Session_refresh(
		T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&),
		void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Glacier2Session_refresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Glacier2Session_refreshPtr newCallback_Glacier2Session_refresh(
		T* instance, void (T::*excb)(const ::Ice::Exception&),
		void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Glacier2Session_refresh<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Glacier2Session_refresh: public Callback_Glacier2Session_refresh_Base,
		public ::IceInternal::OnewayCallback<T, CT> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&, const CT&);
	typedef void (T::*Sent)(bool, const CT&);
	typedef void (T::*Response)(const CT&);

	Callback_Glacier2Session_refresh(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb) {
	}
};

template<class T, typename CT> Callback_Glacier2Session_refreshPtr newCallback_Glacier2Session_refresh(
		const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Glacier2Session_refresh<T, CT>(instance, cb, excb,
			sentcb);
}

template<class T, typename CT> Callback_Glacier2Session_refreshPtr newCallback_Glacier2Session_refresh(
		const IceUtil::Handle<T>& instance,
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Glacier2Session_refresh<T, CT>(instance, 0, excb,
			sentcb);
}

template<class T, typename CT> Callback_Glacier2Session_refreshPtr newCallback_Glacier2Session_refresh(
		T* instance, void (T::*cb)(const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Glacier2Session_refresh<T, CT>(instance, cb, excb,
			sentcb);
}

template<class T, typename CT> Callback_Glacier2Session_refreshPtr newCallback_Glacier2Session_refresh(
		T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Glacier2Session_refresh<T, CT>(instance, 0, excb,
			sentcb);
}

template<class T>
class CallbackNC_Session_getCardroidManager: public Callback_Session_getCardroidManager_Base,
		public ::IceInternal::TwowayCallbackNC<T> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&);
	typedef void (T::*Sent)(bool);
	typedef void (T::*Response)(
			const ::cardroid::zerocice::CardroidManagerPrx&);

	CallbackNC_Session_getCardroidManager(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(
					cb) {
	}

	virtual void __completed(const ::Ice::AsyncResultPtr& __result) const {
		::cardroid::network::zerocice::SessionPrx __proxy =
				::cardroid::network::zerocice::SessionPrx::uncheckedCast(
						__result->getProxy());
		::cardroid::zerocice::CardroidManagerPrx __ret;
		try {
			__ret = __proxy->end_getCardroidManager(__result);
		} catch (::Ice::Exception& ex) {
			::IceInternal::CallbackNC<T>::__exception(__result, ex);
			return;
		}
		if (response) {
			(::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
		}
	}

	Response response;
};

template<class T> Callback_Session_getCardroidManagerPtr newCallback_Session_getCardroidManager(
		const IceUtil::Handle<T>& instance,
		void (T::*cb)(const ::cardroid::zerocice::CardroidManagerPrx&),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Session_getCardroidManager<T>(instance, cb, excb,
			sentcb);
}

template<class T> Callback_Session_getCardroidManagerPtr newCallback_Session_getCardroidManager(
		T* instance,
		void (T::*cb)(const ::cardroid::zerocice::CardroidManagerPrx&),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Session_getCardroidManager<T>(instance, cb, excb,
			sentcb);
}

template<class T, typename CT>
class Callback_Session_getCardroidManager: public Callback_Session_getCardroidManager_Base,
		public ::IceInternal::TwowayCallback<T, CT> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&, const CT&);
	typedef void (T::*Sent)(bool, const CT&);
	typedef void (T::*Response)(const ::cardroid::zerocice::CardroidManagerPrx&,
			const CT&);

	Callback_Session_getCardroidManager(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(
					cb) {
	}

	virtual void __completed(const ::Ice::AsyncResultPtr& __result) const {
		::cardroid::network::zerocice::SessionPrx __proxy =
				::cardroid::network::zerocice::SessionPrx::uncheckedCast(
						__result->getProxy());
		::cardroid::zerocice::CardroidManagerPrx __ret;
		try {
			__ret = __proxy->end_getCardroidManager(__result);
		} catch (::Ice::Exception& ex) {
			::IceInternal::Callback<T, CT>::__exception(__result, ex);
			return;
		}
		if (response) {
			(::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret,
					CT::dynamicCast(__result->getCookie()));
		}
	}

	Response response;
};

template<class T, typename CT> Callback_Session_getCardroidManagerPtr newCallback_Session_getCardroidManager(
		const IceUtil::Handle<T>& instance,
		void (T::*cb)(const ::cardroid::zerocice::CardroidManagerPrx&,
				const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Session_getCardroidManager<T, CT>(instance, cb, excb,
			sentcb);
}

template<class T, typename CT> Callback_Session_getCardroidManagerPtr newCallback_Session_getCardroidManager(
		T* instance,
		void (T::*cb)(const ::cardroid::zerocice::CardroidManagerPrx&,
				const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Session_getCardroidManager<T, CT>(instance, cb, excb,
			sentcb);
}

template<class T>
class CallbackNC_Session_getTopic: public Callback_Session_getTopic_Base,
		public ::IceInternal::TwowayCallbackNC<T> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&);
	typedef void (T::*Sent)(bool);
	typedef void (T::*Response)(const ::IceStorm::TopicPrx&);

	CallbackNC_Session_getTopic(const TPtr& obj, Response cb, Exception excb,
			Sent sentcb) :
			::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(
					cb) {
	}

	virtual void __completed(const ::Ice::AsyncResultPtr& __result) const {
		::cardroid::network::zerocice::SessionPrx __proxy =
				::cardroid::network::zerocice::SessionPrx::uncheckedCast(
						__result->getProxy());
		::IceStorm::TopicPrx __ret;
		try {
			__ret = __proxy->end_getTopic(__result);
		} catch (::Ice::Exception& ex) {
			::IceInternal::CallbackNC<T>::__exception(__result, ex);
			return;
		}
		if (response) {
			(::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
		}
	}

	Response response;
};

template<class T> Callback_Session_getTopicPtr newCallback_Session_getTopic(
		const IceUtil::Handle<T>& instance,
		void (T::*cb)(const ::IceStorm::TopicPrx&),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Session_getTopic<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Session_getTopicPtr newCallback_Session_getTopic(
		T* instance, void (T::*cb)(const ::IceStorm::TopicPrx&),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Session_getTopic<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Session_getTopic: public Callback_Session_getTopic_Base,
		public ::IceInternal::TwowayCallback<T, CT> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&, const CT&);
	typedef void (T::*Sent)(bool, const CT&);
	typedef void (T::*Response)(const ::IceStorm::TopicPrx&, const CT&);

	Callback_Session_getTopic(const TPtr& obj, Response cb, Exception excb,
			Sent sentcb) :
			::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(
					cb) {
	}

	virtual void __completed(const ::Ice::AsyncResultPtr& __result) const {
		::cardroid::network::zerocice::SessionPrx __proxy =
				::cardroid::network::zerocice::SessionPrx::uncheckedCast(
						__result->getProxy());
		::IceStorm::TopicPrx __ret;
		try {
			__ret = __proxy->end_getTopic(__result);
		} catch (::Ice::Exception& ex) {
			::IceInternal::Callback<T, CT>::__exception(__result, ex);
			return;
		}
		if (response) {
			(::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret,
					CT::dynamicCast(__result->getCookie()));
		}
	}

	Response response;
};

template<class T, typename CT> Callback_Session_getTopicPtr newCallback_Session_getTopic(
		const IceUtil::Handle<T>& instance,
		void (T::*cb)(const ::IceStorm::TopicPrx&, const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Session_getTopic<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Session_getTopicPtr newCallback_Session_getTopic(
		T* instance, void (T::*cb)(const ::IceStorm::TopicPrx&, const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Session_getTopic<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Session_refresh: public Callback_Session_refresh_Base,
		public ::IceInternal::OnewayCallbackNC<T> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&);
	typedef void (T::*Sent)(bool);
	typedef void (T::*Response)();

	CallbackNC_Session_refresh(const TPtr& obj, Response cb, Exception excb,
			Sent sentcb) :
			::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb) {
	}
};

template<class T> Callback_Session_refreshPtr newCallback_Session_refresh(
		const IceUtil::Handle<T>& instance, void (T::*cb)(),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Session_refresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Session_refreshPtr newCallback_Session_refresh(
		const IceUtil::Handle<T>& instance,
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Session_refresh<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Session_refreshPtr newCallback_Session_refresh(
		T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&),
		void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Session_refresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Session_refreshPtr newCallback_Session_refresh(
		T* instance, void (T::*excb)(const ::Ice::Exception&),
		void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Session_refresh<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Session_refresh: public Callback_Session_refresh_Base,
		public ::IceInternal::OnewayCallback<T, CT> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&, const CT&);
	typedef void (T::*Sent)(bool, const CT&);
	typedef void (T::*Response)(const CT&);

	Callback_Session_refresh(const TPtr& obj, Response cb, Exception excb,
			Sent sentcb) :
			::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb) {
	}
};

template<class T, typename CT> Callback_Session_refreshPtr newCallback_Session_refresh(
		const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Session_refresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Session_refreshPtr newCallback_Session_refresh(
		const IceUtil::Handle<T>& instance,
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Session_refresh<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Session_refreshPtr newCallback_Session_refresh(
		T* instance, void (T::*cb)(const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Session_refresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Session_refreshPtr newCallback_Session_refresh(
		T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Session_refresh<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Session_destroy: public Callback_Session_destroy_Base,
		public ::IceInternal::OnewayCallbackNC<T> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&);
	typedef void (T::*Sent)(bool);
	typedef void (T::*Response)();

	CallbackNC_Session_destroy(const TPtr& obj, Response cb, Exception excb,
			Sent sentcb) :
			::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb) {
	}
};

template<class T> Callback_Session_destroyPtr newCallback_Session_destroy(
		const IceUtil::Handle<T>& instance, void (T::*cb)(),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Session_destroy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Session_destroyPtr newCallback_Session_destroy(
		const IceUtil::Handle<T>& instance,
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Session_destroy<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Session_destroyPtr newCallback_Session_destroy(
		T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&),
		void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Session_destroy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Session_destroyPtr newCallback_Session_destroy(
		T* instance, void (T::*excb)(const ::Ice::Exception&),
		void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_Session_destroy<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Session_destroy: public Callback_Session_destroy_Base,
		public ::IceInternal::OnewayCallback<T, CT> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&, const CT&);
	typedef void (T::*Sent)(bool, const CT&);
	typedef void (T::*Response)(const CT&);

	Callback_Session_destroy(const TPtr& obj, Response cb, Exception excb,
			Sent sentcb) :
			::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb) {
	}
};

template<class T, typename CT> Callback_Session_destroyPtr newCallback_Session_destroy(
		const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Session_destroy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Session_destroyPtr newCallback_Session_destroy(
		const IceUtil::Handle<T>& instance,
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Session_destroy<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Session_destroyPtr newCallback_Session_destroy(
		T* instance, void (T::*cb)(const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Session_destroy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Session_destroyPtr newCallback_Session_destroy(
		T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_Session_destroy<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_SessionFactory_create: public Callback_SessionFactory_create_Base,
		public ::IceInternal::TwowayCallbackNC<T> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&);
	typedef void (T::*Sent)(bool);
	typedef void (T::*Response)(
			const ::cardroid::network::zerocice::SessionPrx&);

	CallbackNC_SessionFactory_create(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(
					cb) {
	}

	virtual void __completed(const ::Ice::AsyncResultPtr& __result) const {
		::cardroid::network::zerocice::SessionFactoryPrx __proxy =
				::cardroid::network::zerocice::SessionFactoryPrx::uncheckedCast(
						__result->getProxy());
		::cardroid::network::zerocice::SessionPrx __ret;
		try {
			__ret = __proxy->end_create(__result);
		} catch (::Ice::Exception& ex) {
			::IceInternal::CallbackNC<T>::__exception(__result, ex);
			return;
		}
		if (response) {
			(::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
		}
	}

	Response response;
};

template<class T> Callback_SessionFactory_createPtr newCallback_SessionFactory_create(
		const IceUtil::Handle<T>& instance,
		void (T::*cb)(const ::cardroid::network::zerocice::SessionPrx&),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_SessionFactory_create<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionFactory_createPtr newCallback_SessionFactory_create(
		T* instance,
		void (T::*cb)(const ::cardroid::network::zerocice::SessionPrx&),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_SessionFactory_create<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionFactory_create: public Callback_SessionFactory_create_Base,
		public ::IceInternal::TwowayCallback<T, CT> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&, const CT&);
	typedef void (T::*Sent)(bool, const CT&);
	typedef void (T::*Response)(
			const ::cardroid::network::zerocice::SessionPrx&, const CT&);

	Callback_SessionFactory_create(const TPtr& obj, Response cb, Exception excb,
			Sent sentcb) :
			::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(
					cb) {
	}

	virtual void __completed(const ::Ice::AsyncResultPtr& __result) const {
		::cardroid::network::zerocice::SessionFactoryPrx __proxy =
				::cardroid::network::zerocice::SessionFactoryPrx::uncheckedCast(
						__result->getProxy());
		::cardroid::network::zerocice::SessionPrx __ret;
		try {
			__ret = __proxy->end_create(__result);
		} catch (::Ice::Exception& ex) {
			::IceInternal::Callback<T, CT>::__exception(__result, ex);
			return;
		}
		if (response) {
			(::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret,
					CT::dynamicCast(__result->getCookie()));
		}
	}

	Response response;
};

template<class T, typename CT> Callback_SessionFactory_createPtr newCallback_SessionFactory_create(
		const IceUtil::Handle<T>& instance,
		void (T::*cb)(const ::cardroid::network::zerocice::SessionPrx&,
				const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_SessionFactory_create<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionFactory_createPtr newCallback_SessionFactory_create(
		T* instance,
		void (T::*cb)(const ::cardroid::network::zerocice::SessionPrx&,
				const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_SessionFactory_create<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_SessionFactory_getSessionTimeout: public Callback_SessionFactory_getSessionTimeout_Base,
		public ::IceInternal::TwowayCallbackNC<T> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&);
	typedef void (T::*Sent)(bool);
	typedef void (T::*Response)(::Ice::Long);

	CallbackNC_SessionFactory_getSessionTimeout(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(
					cb) {
	}

	virtual void __completed(const ::Ice::AsyncResultPtr& __result) const {
		::cardroid::network::zerocice::SessionFactoryPrx __proxy =
				::cardroid::network::zerocice::SessionFactoryPrx::uncheckedCast(
						__result->getProxy());
		::Ice::Long __ret;
		try {
			__ret = __proxy->end_getSessionTimeout(__result);
		} catch (::Ice::Exception& ex) {
			::IceInternal::CallbackNC<T>::__exception(__result, ex);
			return;
		}
		if (response) {
			(::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
		}
	}

	Response response;
};

template<class T> Callback_SessionFactory_getSessionTimeoutPtr newCallback_SessionFactory_getSessionTimeout(
		const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_SessionFactory_getSessionTimeout<T>(instance, cb,
			excb, sentcb);
}

template<class T> Callback_SessionFactory_getSessionTimeoutPtr newCallback_SessionFactory_getSessionTimeout(
		T* instance, void (T::*cb)(::Ice::Long),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_SessionFactory_getSessionTimeout<T>(instance, cb,
			excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionFactory_getSessionTimeout: public Callback_SessionFactory_getSessionTimeout_Base,
		public ::IceInternal::TwowayCallback<T, CT> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&, const CT&);
	typedef void (T::*Sent)(bool, const CT&);
	typedef void (T::*Response)(::Ice::Long, const CT&);

	Callback_SessionFactory_getSessionTimeout(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(
					cb) {
	}

	virtual void __completed(const ::Ice::AsyncResultPtr& __result) const {
		::cardroid::network::zerocice::SessionFactoryPrx __proxy =
				::cardroid::network::zerocice::SessionFactoryPrx::uncheckedCast(
						__result->getProxy());
		::Ice::Long __ret;
		try {
			__ret = __proxy->end_getSessionTimeout(__result);
		} catch (::Ice::Exception& ex) {
			::IceInternal::Callback<T, CT>::__exception(__result, ex);
			return;
		}
		if (response) {
			(::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret,
					CT::dynamicCast(__result->getCookie()));
		}
	}

	Response response;
};

template<class T, typename CT> Callback_SessionFactory_getSessionTimeoutPtr newCallback_SessionFactory_getSessionTimeout(
		const IceUtil::Handle<T>& instance,
		void (T::*cb)(::Ice::Long, const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_SessionFactory_getSessionTimeout<T, CT>(instance, cb,
			excb, sentcb);
}

template<class T, typename CT> Callback_SessionFactory_getSessionTimeoutPtr newCallback_SessionFactory_getSessionTimeout(
		T* instance, void (T::*cb)(::Ice::Long, const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_SessionFactory_getSessionTimeout<T, CT>(instance, cb,
			excb, sentcb);
}

template<class T>
class CallbackNC_CardroidEventStorm_notify: public Callback_CardroidEventStorm_notify_Base,
		public ::IceInternal::OnewayCallbackNC<T> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&);
	typedef void (T::*Sent)(bool);
	typedef void (T::*Response)();

	CallbackNC_CardroidEventStorm_notify(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb) {
	}
};

template<class T> Callback_CardroidEventStorm_notifyPtr newCallback_CardroidEventStorm_notify(
		const IceUtil::Handle<T>& instance, void (T::*cb)(),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_CardroidEventStorm_notify<T>(instance, cb, excb,
			sentcb);
}

template<class T> Callback_CardroidEventStorm_notifyPtr newCallback_CardroidEventStorm_notify(
		const IceUtil::Handle<T>& instance,
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_CardroidEventStorm_notify<T>(instance, 0, excb,
			sentcb);
}

template<class T> Callback_CardroidEventStorm_notifyPtr newCallback_CardroidEventStorm_notify(
		T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&),
		void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_CardroidEventStorm_notify<T>(instance, cb, excb,
			sentcb);
}

template<class T> Callback_CardroidEventStorm_notifyPtr newCallback_CardroidEventStorm_notify(
		T* instance, void (T::*excb)(const ::Ice::Exception&),
		void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_CardroidEventStorm_notify<T>(instance, 0, excb,
			sentcb);
}

template<class T, typename CT>
class Callback_CardroidEventStorm_notify: public Callback_CardroidEventStorm_notify_Base,
		public ::IceInternal::OnewayCallback<T, CT> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&, const CT&);
	typedef void (T::*Sent)(bool, const CT&);
	typedef void (T::*Response)(const CT&);

	Callback_CardroidEventStorm_notify(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb) {
	}
};

template<class T, typename CT> Callback_CardroidEventStorm_notifyPtr newCallback_CardroidEventStorm_notify(
		const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_CardroidEventStorm_notify<T, CT>(instance, cb, excb,
			sentcb);
}

template<class T, typename CT> Callback_CardroidEventStorm_notifyPtr newCallback_CardroidEventStorm_notify(
		const IceUtil::Handle<T>& instance,
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_CardroidEventStorm_notify<T, CT>(instance, 0, excb,
			sentcb);
}

template<class T, typename CT> Callback_CardroidEventStorm_notifyPtr newCallback_CardroidEventStorm_notify(
		T* instance, void (T::*cb)(const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_CardroidEventStorm_notify<T, CT>(instance, cb, excb,
			sentcb);
}

template<class T, typename CT> Callback_CardroidEventStorm_notifyPtr newCallback_CardroidEventStorm_notify(
		T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_CardroidEventStorm_notify<T, CT>(instance, 0, excb,
			sentcb);
}

template<class T>
class CallbackNC_CardroidEventStorm_message: public Callback_CardroidEventStorm_message_Base,
		public ::IceInternal::OnewayCallbackNC<T> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&);
	typedef void (T::*Sent)(bool);
	typedef void (T::*Response)();

	CallbackNC_CardroidEventStorm_message(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb) {
	}
};

template<class T> Callback_CardroidEventStorm_messagePtr newCallback_CardroidEventStorm_message(
		const IceUtil::Handle<T>& instance, void (T::*cb)(),
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_CardroidEventStorm_message<T>(instance, cb, excb,
			sentcb);
}

template<class T> Callback_CardroidEventStorm_messagePtr newCallback_CardroidEventStorm_message(
		const IceUtil::Handle<T>& instance,
		void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_CardroidEventStorm_message<T>(instance, 0, excb,
			sentcb);
}

template<class T> Callback_CardroidEventStorm_messagePtr newCallback_CardroidEventStorm_message(
		T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&),
		void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_CardroidEventStorm_message<T>(instance, cb, excb,
			sentcb);
}

template<class T> Callback_CardroidEventStorm_messagePtr newCallback_CardroidEventStorm_message(
		T* instance, void (T::*excb)(const ::Ice::Exception&),
		void (T::*sentcb)(bool) = 0) {
	return new CallbackNC_CardroidEventStorm_message<T>(instance, 0, excb,
			sentcb);
}

template<class T, typename CT>
class Callback_CardroidEventStorm_message: public Callback_CardroidEventStorm_message_Base,
		public ::IceInternal::OnewayCallback<T, CT> {
public:

	typedef IceUtil::Handle<T> TPtr;

	typedef void (T::*Exception)(const ::Ice::Exception&, const CT&);
	typedef void (T::*Sent)(bool, const CT&);
	typedef void (T::*Response)(const CT&);

	Callback_CardroidEventStorm_message(const TPtr& obj, Response cb,
			Exception excb, Sent sentcb) :
			::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb) {
	}
};

template<class T, typename CT> Callback_CardroidEventStorm_messagePtr newCallback_CardroidEventStorm_message(
		const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_CardroidEventStorm_message<T, CT>(instance, cb, excb,
			sentcb);
}

template<class T, typename CT> Callback_CardroidEventStorm_messagePtr newCallback_CardroidEventStorm_message(
		const IceUtil::Handle<T>& instance,
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_CardroidEventStorm_message<T, CT>(instance, 0, excb,
			sentcb);
}

template<class T, typename CT> Callback_CardroidEventStorm_messagePtr newCallback_CardroidEventStorm_message(
		T* instance, void (T::*cb)(const CT&),
		void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_CardroidEventStorm_message<T, CT>(instance, cb, excb,
			sentcb);
}

template<class T, typename CT> Callback_CardroidEventStorm_messagePtr newCallback_CardroidEventStorm_message(
		T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&),
		void (T::*sentcb)(bool, const CT&) = 0) {
	return new Callback_CardroidEventStorm_message<T, CT>(instance, 0, excb,
			sentcb);
}

}

}

}

#endif
